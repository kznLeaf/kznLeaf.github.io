<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Valkey/Redis-如何通过多线程达到单点 1M RPS?</title>
    <link href="/2025/09/04/Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2025/09/04/Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Redis 的核心是单线程处理客户端的 SET/GET请求，但现在大多数机器都是<strong>多核</strong>的。为了利用到多核，减少单线程成为瓶颈，AWS为自己的 ElasticCache 做了很多改进，包括：（均已合并到Valkey 8.0） -2019年推出IO线程，承担一部分主线程的工作 -2021年进一步优化IO线程，将开启 TLS的集群加解密和连接处理操作从主线程移到 IO 线程 -2023年推出增强的IO多路复用 -2023年提出表示层卸载和内存访问摊销技术，实现单节点处理超过100万RPS。</p><h2 id="增强io处理">增强I/O处理</h2><p>增强的 I/O多路复用可显著改善大规模吞吐量和延迟。先看看以前的IO多路复用是怎么做的：</p><p><img src="https://s21.ax1x.com/2025/08/22/pVDDBVI.png" /></p><p>每个客户端都与单线程的处理引擎建立一个连接通道，因此引擎要单独为每一个客户端的建立网络连接、解析发来的请求、运行解析出来的命令。这样的架构有两个问题：</p><ol type="1"><li><strong>处理引擎必须亲自处理网络连接，必须亲自解析命令，不能专注于运行命令</strong></li><li><strong>多余的CPU核心没有得到利用</strong></li></ol><p>为了解决这几个问题，增强型的IO多路复用使用以下架构：</p><p><img src="https://s21.ax1x.com/2025/08/22/pVDDgxg.png" /></p><p>其余可用的 CPU核心用来分担主线程的压力，<strong>把处理网络IO的工作转移到 IO线程上</strong>，主线程负责给IO线程分配任务。使用多路复用时，每个增强型I/O线程不会为每个客户端打开一个通道（如上图所示），而是<strong>多个客户端共用一个IO线程</strong>，由IO线程把收集到的命令通过单个通道发送给主线程处理。</p><p>这样做带来了哪些好处？具体来说：</p><ol type="1"><li>增强型 I/O多路复用将源自多个客户端（有时是数千个）的命令组合到少量通道中，在相同连接数下通道的数量更少，提高了吞吐量。</li><li>通道数量的减少增加了<strong>访问局部性</strong>，从而提高了内存缓存的使用率。</li><li>缓存的命中率提高，于是命令的平均执行时间减少，降低了延迟。</li></ol><h2 id="表示层卸载">表示层卸载</h2><p>7.1 版本引入表示层卸载（Redis presentation layeroffloading），指的是客户端命令的解析操作。增强型 IO多路复用把网络IO的处理交给了单独的IO线程，而<strong>表示层卸载在此基础上更进一步，让IO 线程顺便把客户端的命令解析为 Redis二进制命令的格式，然后转发到主线程进行</strong>。这样有两个好处：</p><ol type="1"><li>多个CPU<strong>并行</strong>处理网络 IO和解析命令的工作，充分利用到每一个CPU核心，大大提升执行效率</li><li>主线程只需要专注于运行命令，提高了命令的执行效率</li></ol><figure><img src="https://s21.ax1x.com/2025/08/22/pVDDTiV.png"alt="表示层卸载" /><figcaption aria-hidden="true">表示层卸载</figcaption></figure><h2 id="内存访问摊销">内存访问摊销</h2><p>内存访问摊销（Memory accessamortization）是为了解决随机内存访问开销过大的问题，旨在降低内存访问成本，降低延迟。在7.1版本引入。</p><p>Redis执行命令时经常需要通过字典去寻找key，对于需要查找多个key的情况，传统的做法是一个一个找，找完一个再重新访问内存寻找下一个，换句话说<strong>哈希表遍历将串行运行</strong>。而内存访问摊销采用的方式如下：</p><p><img src="https://s21.ax1x.com/2025/08/22/pVDrv6g.png" /></p><p>分析：</p><ul><li><strong>并行访问内存</strong>，通过 <strong>dictPrefetch</strong>机制，将多个 IO 线程的读取请求合并到一起并行处理，并把结果放到主线程对应CPU 核的 L1/L2 私有缓存中，减少了 Redis主线程针对每个命令都要进行内存调用的消耗，提高了性能。</li></ul><h2 id="主从复制优化">主从复制优化</h2><p>在 Valkey/Redis进行主、从节点同步的时候，有时需要进行全量同步操作。比如有新的从节点加入，或者从节点和主节点复制延迟过大而主节点记录变更buffer 没有全部更新数据时，都会触发新的全量同步操作。Valkey 8.0通过<strong>双通道传输</strong>的机制，优化了全量同步，在某些情况下能降低50% 全量同步的时间，并减少 60% 的复制数据内存。</p><p>全量同步时，主节点会生成 RDB 文件，同时会将生成 RDB过程中的【增量更改信息】存储在专门的 <strong>client outputbuffer</strong> 中。RDB 生成完毕后，主节点会将 RDB文件传输给从节点，从节点拿到 RDB 文件并 apply 后，会继续从主节点读取client output buffer 中的<strong>增量日志</strong>。Valkey 7.2/Redis在生成 RDB 文件过程中采用的 Copy-on-Write 的机制，即先 fork一个进程，指向相同的内存空间。在生成 RDB文件过程中，如果前端应用修改了部分数据，Valkey/Redis会对修改的数据页进行一个拷贝，并在拷贝上进行修改。因此，全量同步的时间会影响Redis 主节点的性能。</p><p>Valkey 8.0 提出了<strong>双通道复制机制</strong>来分别复制 RDB和增量日志，同时将 client output buffer放到从节点。这样的改进使得主节点在进行 RDB文件生成的过程中，就可以将增量日志发送给从节点，<strong>将顺序传输的方式改成了并行传输</strong>，加快了同步速度。此外，从节点存放client output buffer，能够释放写节点的资源，避免 buffer过载，并使主节点更好地应对前端应用的负载。另外，同步速度加快，也能减少buffer 自身的大小，同时减少主节点 COW 的时间，降低对前端应用的影响。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Linux的swap分区的广泛误解-swappiness参数</title>
    <link href="/2025/08/28/Linux-swappiness/"/>
    <url>/2025/08/28/Linux-swappiness/</url>
    
    <content type="html"><![CDATA[<p><code>swappiness</code>是一个和Linux系统交换分区的行为有关的函数。通过下面的命令可以查看该参数的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/sys/vm/swappiness<br></code></pre></td></tr></table></figure><p><code>sudo nano /etc/sysctl.conf</code>可永久修改此参数。默认值是60.很多人认为这个参数给物理内存设定了一个阈值，当使用的内存超过(100-60)%时，就会开始内存交换，把内存中最远未使用的数据写入swap 分区。然而这样的说法其实是有很大问题的。</p><figure><img src="https://s21.ax1x.com/2025/08/28/pV60hm4.png"alt="阿里云也干了" /><figcaption aria-hidden="true"><ahref="https://www.alibabacloud.com/help/zh/ecs/support/how-do-i-configure-the-swap-partition-of-a-linux-instance">阿里云也干了</a></figcaption></figure><h2 id="问题发现">问题发现</h2><p>今天在 Debian 虚拟机上测试 ElasticSearch，因为 es本身内存占用较大，而我只给虚拟机分了 6G 内存，所以总内存占用一直维持在90% 左右。后来使用<code>btop</code>命令发现 swap 分区已经满了：</p><p><img src="https://s21.ax1x.com/2025/08/28/pV6wKVs.png" /></p><p>然后我去查阅了以一下，排名靠前的搜索结果都说 <code>swappiness</code>默认设定当内存占用超过 60% 的时候就会开始把文件写入 swap分区。但是又过了一段时间（期间只执行过几条 es命令，没有开启新的进程），<code>btop</code>显示：</p><p><img src="https://s21.ax1x.com/2025/08/28/pV6wMan.png" /></p><p>总内存占用几乎保持不变，但是 swap分区被清空了？按理来说不应该是内存占用降下去之后才把swap的数据写回内存吗。这说明这个说法多少是有点问题的。</p><h2 id="排查">排查</h2><p>在Google上搜索"Linux如何使用swap分区"，然后找到了<ahref="https://wiki.archlinuxcn.org/wiki/Swap">ArchWiki的条目</a>，里面提到：</p><blockquote><p>有一个常见的误解是<code>swappiness</code>会影响内存阈值或阻止使用交换空间，但它只影响释放文件页面而不是交换的偏好。有关更详细的解释，请参阅<ahref="https://www.howtogeek.com/449691/what-is-swapiness-on-linux-and-how-to-change-it/">这篇文章</a>或<ahref="https://github.com/torvalds/linux/blob/v6.2/mm/vmscan.c#L3000-L3014">内核源代码</a>中它的使用。</p></blockquote><p>下面简单总结一下。</p><h2 id="前置知识">前置知识</h2><h3 id="linux的内存结构">Linux的内存结构</h3><p>Linux系统并不会把内存看作一整个巨大的内存池，而是把内存划分成不同的<strong>区域</strong>（<code>Zone</code>）。x86架构的简化内存区域如下：</p><ul><li>DMA：物理内存的低16MB区域</li><li>DMA32：<strong>只存在于64位 Linux中</strong>，目的是兼容32位的DMA硬件设备。对应物理内存的低4GB。这是一种<strong>逻辑上的分区</strong>，64位DMA设备可以访问全部的内存，32位DMA设备只能访问低4GB的内存。</li><li>Normal：在 64 位计算机上，Normal 区是所有 高于 4 GB的内存（大致上）。在 32 位计算机上，它是 16 MB 到 896 MB 之间的RAM。</li><li>HighMem：这个区域<strong>只存在于 32 位 Linux 中</strong>。它指的是所有高于 896 MB 的内存，在拥有足够大内存的机器上，还包括高于 4 GB的部分。</li></ul><h3 id="区域zone和节点node">区域(Zone)和节点(Node)</h3><p><strong>区域（Zone）与节点（Node）相关联，节点又与CPU关联。内核通过与CPU 关联的节点为进程分配内存。</strong></p><p>一般的Linux计算机只有一个<code>Node 0</code>节点，所有的 Zone都属于这个节点。要查看计算机中的节点和区域，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">less /proc/buddyinfo<br></code></pre></td></tr></table></figure><p>6GB双核虚拟机输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Node</span> <span class="hljs-number">0</span>, zone      DMA      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">1</span>      <span class="hljs-number">3</span> <br><span class="hljs-attribute">Node</span> <span class="hljs-number">0</span>, zone    DMA32    <span class="hljs-number">388</span>    <span class="hljs-number">213</span>    <span class="hljs-number">142</span>    <span class="hljs-number">143</span>     <span class="hljs-number">56</span>     <span class="hljs-number">20</span>      <span class="hljs-number">6</span>      <span class="hljs-number">7</span>      <span class="hljs-number">3</span>      <span class="hljs-number">1</span>      <span class="hljs-number">5</span> <br><span class="hljs-attribute">Node</span> <span class="hljs-number">0</span>, zone   Normal    <span class="hljs-number">195</span>   <span class="hljs-number">1297</span>    <span class="hljs-number">966</span>    <span class="hljs-number">279</span>    <span class="hljs-number">116</span>     <span class="hljs-number">55</span>     <span class="hljs-number">37</span>     <span class="hljs-number">13</span>      <span class="hljs-number">6</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>从左到右，每一列分别表示4KB 8KB 16KB等等（因为内存是以4KB为单位进行分配的），数字表示不同块的数量。</p><p>如果总物理内存小于4GB，那么将不会有<code>Normal</code>区域。</p><h3 id="文件页和匿名页">文件页和匿名页</h3><p>页表中的内存映射可以是：</p><ul><li><strong>文件页(File backed)</strong>:页表项来源于磁盘中的文件，这种内存映射包含已经从任意类型文件中读取的数据。如果系统释放了这块内存，下次读取该文件的时候就必须访问磁盘。在释放内存之前，如果内存中的数据已被修改，需要先同步到磁盘，然后才能释放，防止修改丢失。</li><li><strong>匿名页(Anonymous)</strong>：匿名内存不映射到任何文件和设备，一般是程序动态请求的内存、堆栈等。这种数据并非来自磁盘文件或设备，而是动态产生的，所以必须在磁盘单独留一个专门的空间来存储它们，这个空间就是swap 分区或者 swap文件。在匿名数据页被内存释放之前，其中的数据会被写入swap空间。</li><li><strong>设备页</strong>(Devicebacked)：Linux系统通过块设备文件访问设备，这样可以像处理文件一样从中读取或者写入数据。设备支持的内存映射（devicebacked memorymapping），就是指映射的内存区域背后实际存放的是某个设备的数据。</li><li><strong>共享页</strong>(Shared)：不同的页表项可以映射到内存的同一区域，这样不同的进程可以非常高效地通信。</li><li><strong>写时复制</strong>：一种惰性分配技术，如果请求复制内存中已有的资源，则返回指向原始资源的映射。如果共享该资源的某个进程尝试写入该资源，才会把资源真正复制到另一块内存中，然后才能允许修改。即，写入命令只在第一个写入命令时进行。</li></ul><p>为了理解<code>swappiness</code>，只需要关心前两项。</p><h2 id="swappiness">Swappiness</h2><p>Linux内核文档是这样描述 swappiness 的：</p><blockquote><p>此参数用于定义内核交换内存页的积极程度，值为 0表示在空闲页面和文件页面的数量低于高水位线之前，内核不会启动swap过程。默认值是60.</p></blockquote><p>这里指出，将<code>swappiness</code>设置为 0的话并不会关闭交换功能，只是告诉内核在满足某些条件之前（“高水位线”）不会启动交换，但是最后还是会发生交换的。</p><p>在<ahref="https://github.com/torvalds/linux/blob/master/mm/vmscan.c#L176">内核源文件</a>中包含下面几行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * From 0 .. MAX_SWAPPINESS.  Higher means more swappy.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> vm_swappiness = <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><p>这里提到<code>swappiness</code>的取值范围是 0 ..MAX_SWAPPINESS。在<code>linux/include/linux/swap.h</code>可以找到这个宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SWAPPINESS 200</span><br></code></pre></td></tr></table></figure><p><ahref="https://github.com/torvalds/linux/blob/master/include/linux/swap.h#L417">代码地址</a></p><blockquote><p>顺便一提，<code>MAX_SWAPPINESS</code>在更早的版本是硬编码在代码中的，而且取值为100，而不是200。这一部分的源码在5.8版本后发生了比较大的修改，与<ahref="https://www.howtogeek.com/449691/what-is-swapiness-on-linux-and-how-to-change-it/">这篇文章</a>展示的代码差别很大。</p></blockquote><p><strong>也就是说<code>swappiness</code>的取值范围是0到200</strong>，所以之前所谓的<code>swappiness</code>是为内存交换设定了一个阈值的说法是<strong>不成立的</strong>，如果我把它设为大于100 会发生什么？负数阈值嘛。</p><p>继续挖<code>vmscan.c</code>这个源文件，可以找到下面的<ahref="https://github.com/torvalds/linux/blob/master/mm/vmscan.c#L2448">代码</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">calculate_pressure_balance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> scan_control *sc,</span><br><span class="hljs-params"><span class="hljs-type">int</span> swappiness, u64 *fraction, u64 *denominator)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> anon_cost, file_cost, total_cost;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ap, fp;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Calculate the pressure balance between anon and file pages.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The amount of pressure we put on each LRU is inversely</span><br><span class="hljs-comment"> * proportional to the cost of reclaiming each list, as</span><br><span class="hljs-comment"> * determined by the share of pages that are refaulting, times</span><br><span class="hljs-comment"> * the relative IO cost of bringing back a swapped out</span><br><span class="hljs-comment"> * anonymous page vs reloading a filesystem page (swappiness).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Although we limit that influence to ensure no list gets</span><br><span class="hljs-comment"> * left behind completely: at least a third of the pressure is</span><br><span class="hljs-comment"> * applied, before swappiness.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * With swappiness at 100, anon and file have equal IO cost.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 计算成本</span><br>total_cost = sc-&gt;anon_cost + sc-&gt;file_cost;<br>anon_cost = total_cost + sc-&gt;anon_cost;<br>file_cost = total_cost + sc-&gt;file_cost;<br>total_cost = anon_cost + file_cost;<br><br>ap = swappiness * (total_cost + <span class="hljs-number">1</span>); <span class="hljs-comment">// 匿名页压力，随swappiness增大而增大</span><br>ap /= anon_cost + <span class="hljs-number">1</span>;                <span class="hljs-comment">// 成本越大，压力越小</span><br><br>fp = (MAX_SWAPPINESS - swappiness) * (total_cost + <span class="hljs-number">1</span>);<span class="hljs-comment">//文件页压力，随swappiness增大而减小</span><br>fp /= file_cost + <span class="hljs-number">1</span>;<br><br>fraction[WORKINGSET_ANON] = ap; <span class="hljs-comment">// 匿名页压力比例</span><br>fraction[WORKINGSET_FILE] = fp; <span class="hljs-comment">// 文件页压力比例</span><br>*denominator = ap + fp;         <span class="hljs-comment">// 总压力</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>压力指的是LRU列表被扫描和回收的强度，压力最终会被转换为扫描的页数。压力越大，<strong>释放页</strong>的优先级就越高。对于文件页，释放意味着写入磁盘；对于匿名页，释放意味着写入交换区。</p></blockquote><p>最关键的有两行：</p><ul><li><code>ap = swappiness * (total_cost + 1)</code></li><li><code>fp = (MAX_SWAPPINESS - swappiness) * (total_cost + 1)</code></li></ul><p>压力代表的是回收的优先级，压力越大就意味着IO成本越小，越优先进行。<strong>上面两行说明匿名页和文件页的压力是此消彼长的关系，并且当swappiness=100时，两边的压力相等，即匿名页和文件页的释放成本相同</strong>。这就是为什么注释的最后一行说<em>With swappiness at 100, anon and file have equal IO cost.</em></p><h2 id="黄金比例">黄金比例</h2><p>对于文件页来说，我们总是可以通过从<strong>磁盘</strong>中读取文件来填充内存中的数据页，<strong>所以文件页是完全没有必要写入swap区的</strong>，释放文件页的话直接写入它在磁盘中的原来位置就行了。</p><p>对于匿名页，内存中的数据没有与磁盘相关联，因为是动态获取的。为了在释放以后能够把匿名页面恢复过来，需要把它存储在交换区。</p><p>无论文件页还是匿名页，释放内存的时候都会写入磁盘，由文件系统管理，读数据的话都要调用文件系统read，所以说这两种页面回收操作的成本都很高。从前面也可以看出，文件页和匿名页的回收强度是此消彼长的，试图通过最小化匿名页的交换来减少磁盘IO只会增加文件页读写的IO。</p><p><code>swappiness</code>不会设置任何阈值来决定何时使用交换空间，它主要是决定了内核释放数据页的<strong>倾向</strong>。当需要释放内存时，回收和交换算法会考虑<code>ap</code>和<code>fp</code>以及它们之间的比率，以确定优先考虑释放哪些类型的页面。这确定了硬盘是先处理磁盘文件，还是处理匿名页的交换分区/交换文件。</p><p>至于什么时候才会真正启用交换空间，根据上面的分析暂时确定的是<code>swappiness</code>决定了Linux内核会优先考虑释放内存中的文件页还是匿名页。实际上决定交换空间何时启用的是<strong>水位线</strong>。每个内存区域都有一个高水位线和一个低水位线。这些值由系统产生，是每个区域RAM的百分比，被用作交换空间的触发阈值。要检查高水位线和低水位线，使用以下命令查看<code>less /proc/zoneinfo</code>每个区域都有一组以页为单位的内存值，例如下面是DMA32区域的情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Node</span> <span class="hljs-number">0</span>, zone    DMA32<br>  <span class="hljs-attribute">pages</span> free     <span class="hljs-number">17298</span><br>        <span class="hljs-attribute">boost</span>    <span class="hljs-number">0</span><br>        <span class="hljs-attribute">min</span>      <span class="hljs-number">8525</span><br>        <span class="hljs-attribute">low</span>      <span class="hljs-number">10656</span><br>        <span class="hljs-attribute">high</span>     <span class="hljs-number">12787</span><br>        <span class="hljs-attribute">spanned</span>  <span class="hljs-number">1044480</span><br>        <span class="hljs-attribute">present</span>  <span class="hljs-number">782304</span><br>        <span class="hljs-attribute">managed</span>  <span class="hljs-number">765920</span><br>        <span class="hljs-attribute">cma</span>      <span class="hljs-number">0</span><br>        <span class="hljs-attribute">protection</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2875</span>, <span class="hljs-number">2875</span>, <span class="hljs-number">2875</span>)<br>      <span class="hljs-attribute">nr_free_pages</span> <span class="hljs-number">17298</span><br>      <span class="hljs-attribute">nr_zone_inactive_anon</span> <span class="hljs-number">715717</span><br>      <span class="hljs-attribute">nr_zone_active_anon</span> <span class="hljs-number">1144</span><br>      <span class="hljs-attribute">nr_zone_inactive_file</span> <span class="hljs-number">9386</span><br>      <span class="hljs-attribute">nr_zone_active_file</span> <span class="hljs-number">11214</span><br>      <span class="hljs-attribute">nr_zone_unevictable</span> <span class="hljs-number">0</span><br>      <span class="hljs-attribute">nr_zone_write_pending</span> <span class="hljs-number">0</span><br>      <span class="hljs-attribute">nr_mlock</span>     <span class="hljs-number">0</span><br>      <span class="hljs-attribute">nr_bounce</span>    <span class="hljs-number">0</span><br>      <span class="hljs-attribute">nr_zspages</span>   <span class="hljs-number">0</span><br>      <span class="hljs-attribute">nr_free_cma</span>  <span class="hljs-number">0</span><br>      <span class="hljs-attribute">numa_hit</span>     <span class="hljs-number">1135816</span><br>      <span class="hljs-attribute">numa_miss</span>    <span class="hljs-number">0</span><br>      <span class="hljs-attribute">numa_foreign</span> <span class="hljs-number">0</span><br>      <span class="hljs-attribute">numa_interleave</span> <span class="hljs-number">2</span><br>      <span class="hljs-attribute">numa_local</span>   <span class="hljs-number">1135816</span><br>      <span class="hljs-attribute">numa_other</span>   <span class="hljs-number">0</span><br>  <span class="hljs-attribute">pagesets</span><br>    <span class="hljs-attribute">cpu</span>: <span class="hljs-number">0</span><br>              <span class="hljs-attribute">count</span>: <span class="hljs-number">591</span><br>              <span class="hljs-attribute">high</span>:  <span class="hljs-number">5328</span><br>              <span class="hljs-attribute">batch</span>: <span class="hljs-number">63</span><br>  <span class="hljs-attribute">vm</span> stats threshold: <span class="hljs-number">24</span><br>    <span class="hljs-attribute">cpu</span>: <span class="hljs-number">1</span><br>              <span class="hljs-attribute">count</span>: <span class="hljs-number">2495</span><br>              <span class="hljs-attribute">high</span>:  <span class="hljs-number">5328</span><br>              <span class="hljs-attribute">batch</span>: <span class="hljs-number">63</span><br>  <span class="hljs-attribute">vm</span> stats threshold: <span class="hljs-number">24</span><br>  <span class="hljs-attribute">node_unreclaimable</span>:  <span class="hljs-number">0</span><br>  <span class="hljs-attribute">start_pfn</span>:           <span class="hljs-number">4096</span><br><br></code></pre></td></tr></table></figure><blockquote><p>在正常运行条件下，当某个内存区域（zone）的可用内存低于该区域的低水位线（lowwatermark）时，交换（swap）算法就会开始扫描内存页，寻找可以回收的内存。</p><p>如果 Linux 的 swappiness 值被设置为0，那么只有当文件页和空闲页两者的总和低于高水位线（high water mark）时，才会触发 swap。</p></blockquote><h2 id="总结">总结</h2><p><strong>交换分区不仅仅是内存空间不够用时释放内存的机制，而是系统正常运行的重要组成部分</strong>，没有它。Linux很难实现合理的内存管理。<code>swappniess</code>并不会设置所谓的交换阈值，<code>swappniess</code>代表了内核对于写入交换空间的偏好，较低的值会导致内核更倾向于释放打开的文件，较高的值会导致内核倾向于将匿名页写入交换空间，而值100意味着IO成本被假定为相等。不存在最合适的<code>swappniess</code>，因为不同的设备情况是不一样的。对于大部分的桌面用户，不需要改动该值，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结合Valkey聊聊Redis的持久化机制</title>
    <link href="/2025/08/20/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/08/20/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p>Valkey上关于持久化的很好的参考资料：<ahref="https://valkey.io/topics/persistence/">https://valkey.io/topics/persistence/</a></p><p>Valkey的全面介绍：<ahref="https://aws.amazon.com/cn/blogs/china/introduction-and-analysis-of-the-in-memory-key-value-database-valkey/">推陈出新– 内存 key-value 数据库 Valkey 介绍和剖析</a></p><p>关于<code>fork</code>：https://linux.die.net/man/2/fork</p><h2 id="前言">前言</h2><p>2024 年 3 月 20 日，Redis Labs 宣布从 Redis 7.4 开始，将 BSD-3-clause源码使用协议修改为 RSAv2 和 SSPLv1 协议。该变化意味着 Redis 在OSI（开放源代码促进会）定义下不再是严格的开源产品。实际上，Redis项目的贡献除了 Redis Labs的成员外，还有多位来自于其他公司的成员，贡献比例逐年上升，今年甚至达到了50% 左右。这些核心成员对 Redis Labs 更改 Redis协议的变动并不认可，所以由 Linux 基金会组织成立了 Valkey开源项目。Valkey 采用 BSD 源码使用协议，在 2024 年 4 月 16 日推出了7.2.5 版本，该版本从 Redis 7.2.4 fork而来，可以帮助用户无缝完成切换。</p><p>Arch Linux于今年上半年正式将官方仓库中的 redis 替换为 Valkey。</p><p>Arch Linux安装 Valkey 的方式非常简单，只需要执行一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S redis<br></code></pre></td></tr></table></figure><p>软件包只有不到10MB，非常非常精简</p><p>(虽然软件包的名字还是redis，但是软件包本身已经被换成Valkey了)</p><p>然后启用Valkey服务即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start valkey<br></code></pre></td></tr></table></figure><p>使用命令<code>valkey-cli</code>即可进入Valkey客户端工具。</p><p>Valkey和Redis的命令是完全兼容的，所以下面涉及到Valkey的部分同样也适用于Redis。</p><h2 id="持久化方式简介">持久化方式简介</h2><p>两种方式：RDB和AOF。RDB记录数据本身，AOF追加记录文本命令。默认只启用了RDB，AOF不建议单独使用。</p><p>处理这两种持久化的进程统一称为<code>background saving process</code>，细分为<code>background save</code>和<code>AOF log background rewriting</code>，前者在后台向磁盘写入RDB文件，后者在后台重写AOF文件。</p><h2 id="rdb">RDB</h2><p>全称：Redis Database BackupFile，redos数据备份文件，也被称为<strong>快照</strong>，也就是把内存中的所有数据记录到磁盘中，默认保存到<code>/var/lib/valkey/dump.rdb</code>。有两个命令可以刷盘RDB：</p><ul><li><code>save</code>：由<strong>主进程</strong>执行RDB写入磁盘，同步保存，产生一个时间点的快照。</li><li><code>bgsave</code>：创建子进程<code>background saving child</code>负责保存RDB，主进程不受影响。</li></ul><h3 id="bgsave创建快照流程">bgsave创建快照流程</h3><p>技术：<strong>写时复制</strong></p><ul><li>创建 RDB快照文件，使用写时复制技术，父进程调用<code>fork()</code>创建子进程（复制了父进程的页表，指向同一块物理内存区域），然后子进程把读到的数据写入硬盘，替换旧的rdb文件。而主进程继续处理命令。</li><li>从这块物理内存的角度来看，子进程只有读操作，但是父进程不一定，可能会产生修改。</li><li>主进程如果有新的写操作，操作系统会把该物理区域复制一份，主进程的页表改为指向新的物理空间，然后主进程对这个物理页进行写操作和读操作。</li><li>缺点：若快照期间主进程有大量写入，会频繁复制页面，导致内存占用翻倍。</li></ul><p><img src="https://s21.ax1x.com/2025/07/20/pV8Q6Z4.png" /></p><p><strong>精简版：</strong></p><ul><li>Redis fork 一个子进程。我们现在有一个子进程和一个父进程。</li><li>子进程开始将数据集写入临时 RDB 文件。</li><li>当子进程完成写入新的 RDB 文件时，它将<strong>替换旧的 RDB文件</strong>。</li></ul><p><strong>RDB的缺点</strong></p><ul><li>RDB的执行时间间隔长。两次RDB之间的写入数据有丢失的风险</li><li>for子进程、RDB文件的压缩和写入都比较耗时</li></ul><h2 id="aof">AOF</h2><h3 id="基础">1.基础</h3><p>启用 AOF的命令：<code>valkey-cli config set appendonly yes</code></p><p>全称：Append OnlyFile，仅追加文件。每一个命令都会记录在AOF文件，类似于逻辑日志。默认配置下，每秒系统自动执行一次<code>fsync</code>，将AOF文件同步到磁盘。</p><p>在新版本中，AOF不单单只有一个文件。Valkey 将 AOF拆分成多个部分，也就是说，原始的单个 AOF文件被拆分为<strong>基本文件</strong>（最多只有一个）和<strong>增量文件</strong>（可能不止一个）。基本文件表示AOF 重写时数据的初始快照（RDB 或 AOF 格式）。增量文件包含自上一个基本AOF文件创建以来的增量更改。所有这些文件都放在单独的目录中，并由<strong>清单文件</strong>进行跟踪。</p><p>由于AOF会不加思考地记录用户输入的每一调命令，AOF文件的体积往往比较大。为了去掉冗余的命令，精简AOF 大小，引入了 <strong>AOF 重写机制</strong>，重新生成体积更小的 AOF文件，覆盖原来的文件。<code>bgrewriteaof</code>可以手动异步执行重写功能，不过也有自动执行的机制。自动机制见配置文件章节。</p><h3 id="重写原理">2.重写原理</h3><p>和RDB一样，日志重写（Logrewriting）也使用了相同的<strong>写时复制</strong>技巧。</p><ul><li>Valkey fork一个子进程，于是现在我们有一个父进程和一个子进程</li><li>子进程开始向临时文件中写入新的 base AOF文件</li><li>父进程打开一个新的增量AOF文件，往这里写入更新。<strong>如果子进程的重写失败了</strong>，那么：旧基本文件、旧增量文件（如果有的话），再加上新打开的增量文件，三者形成了新的完整的AOF文件，所以没有安全问题</li><li><strong>子进程重写成功以后</strong>，父进程会收到一个信号，用<code>新打开的增量文件</code>和<code>子进程生成的基本文件</code>构建一个<strong>临时清单文件</strong>（tempmanifest），并将其持久化到磁盘。</li><li>Valkey对清单文件进行原子交换，使得 AOF重写的结果生效。Valkey还会清理旧的基本文件和所有未使用的增量文件。</li></ul><h3 id="查看aof本地文件">3.查看AOF本地文件</h3><p>如图所示，在Linux系统中查看<code>/var/lib/valkey/appendonlydir/</code>目录下的AOF文件。</p><p><img src="https://s21.ax1x.com/2025/08/18/pVBmjeI.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@Arch ~]# <span class="hljs-built_in">cd</span> /var/lib/valkey/<br>[root@Arch valkey]# <span class="hljs-built_in">ls</span><br>appendonlydir  dump.rdb<br>[root@Arch valkey]# <span class="hljs-built_in">cd</span> appendonlydir/<br>[root@Arch appendonlydir]# <span class="hljs-built_in">ls</span><br>appendonly.aof.1.base.rdb  appendonly.aof.1.incr.aof  appendonly.aof.manifest<br>[root@Arch appendonlydir]# <span class="hljs-built_in">cat</span> appendonly.aof.1.base.rdb <br>REDIS0011�<br>valkey-ver8.1.3�<br>[root@Arch appendonlydir]# <span class="hljs-built_in">cat</span> appendonly.aof.1.incr.aof <br>*2<br><span class="hljs-variable">$6</span><br>SELECT<br><span class="hljs-variable">$1</span><br>0<br>*3<br><span class="hljs-variable">$3</span><br><span class="hljs-built_in">set</span><br><span class="hljs-variable">$4</span><br>Aket<br><span class="hljs-variable">$3</span><br>111<br>[root@Arch appendonlydir]# <span class="hljs-built_in">cat</span> appendonly.aof.manifest <br>file appendonly.aof.1.base.rdb <span class="hljs-built_in">seq</span> 1 <span class="hljs-built_in">type</span> b<br>file appendonly.aof.1.incr.aof <span class="hljs-built_in">seq</span> 1 <span class="hljs-built_in">type</span> i<br></code></pre></td></tr></table></figure><p>如前文所述，AOF不止一个文件，位于单独的目录<code>/var/lib/valkey/appendonlydir/</code>下。这里生成了三个文件：</p><ul><li>appendonly.aof.1.base.rdb 基本文件</li><li>appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof 增量文件</li><li>appendonly.aof.manifest 清单文件</li></ul><p>查看文件的具体内容，发现：</p><ul><li>基本文件的内容出现乱码，这很好理解，因为这里是以RDB格式存储的，<code>REDIS0011</code>表示RDB文件头，虽然扩展名是<code>.aof</code>，但它其实就是一个RDB文件。</li><li>增量文件保存的是文本命令，采用<strong>RESP协议</strong>记录命令</li><li>描述AOF的组成，包括：<ul><li><code>...base.rdb seq 1 type b</code>：指明base文件（RDB格式），序号为1</li><li><code>...incr.aof seq 1 type i</code>：指明增量文件，序号1</li><li>valkey启动时，会先加载<code>type b</code>的RDB文件，再回放增量文件。</li></ul></li></ul><p>从上面可以看出，清单文件的目的就是记录哪个文件是基本文件，哪个文件是增量文件。这为我们带来了极大的灵活性————如果要更改AOF基本文件，只需修改清单文件即可。</p><h3 id="触发机制">4.触发机制</h3><p>见配置文件参数章节。</p><h2 id="rdb和aof的比较">RDB和AOF的比较</h2><p><img src="https://s21.ax1x.com/2025/07/20/pV8l5hn.png" /></p><p>结合Valkey手册再补充几点：</p><ul><li>RDB非常适合备份，相当于存档，比如可以每天保存一个快照，出什么事就直接回档</li><li>RDB的重启速度更快</li><li>RDB最大化了Valkey的性能，因为父进程只需要 fork一个子进程，由子进程完成所有的持久化工作。</li><li>AOF可以设置不同的fsync策略，数据一致性更强</li><li>AOF是仅追加日志，不会出现磁盘的<strong>寻道</strong></li><li>当 AOF 文件过大时，Valkey能够在后台<strong>自动重写</strong>。重写过程非常安全，因为 Valkey会在继续向旧文件追加数据的同时，使用创建当前数据集所需的最少操作生成一个全新的AOF 文件。一旦第二个文件准备就绪，Valkey 就会切换两个 AOF文件，并开始向新文件追加数据。</li><li>不推荐单独使用AOF，因为RDB的数据库备份作用还是很重要的。</li></ul><h2 id="配置文件的参数">配置文件的参数</h2><p>以下内容来自Valkey/Redis的配置文件及注释。</p><h3 id="rdb-1">RDB</h3><p>除非另有规定，服务器将会自动保存DB：</p><ul><li>执行了至少一次修改的1h以后</li><li>执行了至少100次修改的5min后</li><li>10000修改的60s后</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">3600</span> <span class="hljs-number">1</span> <span class="hljs-number">300</span> <span class="hljs-number">100</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>如果RDB最近一次的后台保存（backgroundsave）失败了，那么服务器将会停止接受写入，以提醒用户持久化失败。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">stop-<span class="hljs-built_in">write</span>-<span class="hljs-keyword">on</span>-bgsave-<span class="hljs-keyword">error</span> yes<br></code></pre></td></tr></table></figure><p>默认情况下，生成<code>.rdb</code>文件采用 LZF压缩，以节省空间，代价是增高了子进程的CPU占用率。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdbcompression</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>默认开启校验和，rdb文件的末尾包含一个校验和，这样在保存和加载rdb文件的时候都会校验这个校验和，造成大约10%的性能损失。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rebchecksum</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h3 id="append-only-mode">APPEND ONLY MODE</h3><p>AOF是一种更安全的策略，默认情况下最多只丢失1s的数据。AOF和RDB可以同时启用，而AOF提供了更好的持久性保障，所以<strong>服务器启动的时候会优先加载AOF</strong>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>AOF文件的名字。AOF文件由多个文件组成，包含两种基本类型：</p><ul><li><strong>Basefiles</strong>，基本文件，就是代表所有数据集在该文件被创建的时刻的完整状态的一个快照。细分为两种格式：RDB（二进制序列化的）或者 AOF（文本命令）</li><li><strong>Incrementalfiles</strong>，增量文件，包含了应用于数据集的额外命令</li></ul><p>除此之外，<strong>manifestfiles</strong>（清单文件）用来追踪文件被创建、应当被使用的顺序。</p><p>AOF文件是按照一定的规则命名的，其中文件名的前缀就是下面定义的<code>appendonly.aof</code>，例如下面几个文件可能会被创建：</p><ul><li>appendonly.aof.1.base.rdb 基本文件</li><li>appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof 增量文件</li><li>appendonly.aof.manifest 清单文件</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><p>为了方便期间，服务器会把所有的持久化AOF文件放到一个专用的目录下，该目录的名字由下面的参数决定:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appenddirname</span> <span class="hljs-string">&quot;appendonlydir&quot;</span><br></code></pre></td></tr></table></figure><p><code>fsync()</code>调用告诉操作系统将数据立即写入磁盘，而不是先放到缓冲区积攒更多的数据。Valkey支持以下三种刷盘模式：</p><ul><li><code>no</code>：不主动调用<code>fsync()</code>，让操作系统自己决定什么时候刷盘。最快。</li><li><code>always</code>：每次<code>write</code>都会调用<code>fsync()</code>，最安全，最慢。</li><li><code>everysec</code>：每秒调用一次<code>fsync()</code>。折中。</li></ul><p>默认是第三种，毕竟在速度和安全性之间折中往往是正确的选择。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># appendfsync always</span><br><span class="hljs-attribute">appendfsync</span> everysec<br><span class="hljs-comment"># appendfsync no</span><br></code></pre></td></tr></table></figure><p>但是在 AOF 重写（BGREWRITEAOF）的过程中，磁盘 I/O压力很大，如果这时还频繁执行fsync，可能会导致性能急剧下降。如果启用下面的参数，在执行AOF重写时，不执行<code>fsync</code>，而是只写入操作系统缓存。这样可以避免IO阻塞，但是也会带来安全风险。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p><strong>AOF自动重写机制</strong>：</p><ul><li>当前 AOF 文件大小比上次重写后的大小翻倍（增加100%），就会触发自动重写</li><li>大前提：当前AOF文件大于64MB。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自动重写 AOF 文件。</span><br><span class="hljs-comment"># Redis 能够在 AOF 日志文件增大到指定百分比后，自动调用 BGREWRITEAOF 来进行重写。</span><br><br><span class="hljs-comment"># 工作原理如下：Redis 会记住最近一次重写后的 AOF 文件大小（如果重写还未发生过，则使用启动时 AOF 文件的大小）。</span><br><br><span class="hljs-comment"># 这个基准大小会与当前 AOF 文件大小进行比较。如果当前大小超过了指定百分比，就会触发重写操作。</span><br><span class="hljs-comment"># 同时你还需要设置一个 AOF 文件的最小大小，以避免文件虽然增长了指定百分比，但总体仍然太小就进行重写。</span><br><br><span class="hljs-comment"># 如果将百分比设为 0，就会禁用 AOF 自动重写功能。</span><br><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><p><strong>AOF 文件加载与重写机制</strong>：</p><p>如果启动过程中发现AOF文件末尾被截断，就会用到这个参数。服务器将发出以下日志：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">* Reading RDB preamble from AOF file...<br>* Reading the remaining AOF tail...<br># !!! Warning: short read while loading the AOF file !!!<br># !!! Truncating the AOF at offset <span class="hljs-number">439</span> !!!<br># AOF loaded anyway because aof-load-truncated is enabled<br></code></pre></td></tr></table></figure><p>默认情况下只是会丢弃最后一条不正确的命令，继续加载，</p><ul><li>aof-load-truncated 控制 Redis 在 AOF文件末尾损坏时是否仍然加载有效数据并启动，默认开启增强容错性；</li><li>aof-use-rdb-preamble 允许 Redis 在 AOF 重写时使用 RDB格式开头，加速数据恢复，提升性能。两者结合使 AOF 更可靠和高效。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Redis 启动过程中在加载 AOF 数据时，可能会发现 AOF 文件末尾被截断。</span><br><span class="hljs-comment"># 这种情况通常出现在 Redis 所在的系统崩溃时，特别是在 ext4 文件系统未启用 data=ordered 选项的情况下。</span><br><span class="hljs-comment"># 但如果只是 Redis 自身崩溃，而操作系统仍正常，这种问题通常不会发生。</span><br><br><span class="hljs-comment"># 当 Redis 发现 AOF 文件末尾被截断时，可以选择两种行为：</span><br><span class="hljs-comment"># 1. 报错并停止启动（默认不是这样）</span><br><span class="hljs-comment"># 2. 或者尽可能加载有效数据，并继续启动（默认行为）</span><br><br><span class="hljs-comment"># 这个配置项控制上面提到的行为：</span><br><span class="hljs-comment"># 如果设置为 yes，Redis 会加载尽可能多的有效数据并启动，同时记录日志提醒用户。</span><br><span class="hljs-comment"># 如果设置为 no，Redis 会报错并拒绝启动，要求用户使用 redis-check-aof 工具修复 AOF 文件。</span><br><br><span class="hljs-comment"># 注意：如果 AOF 文件中间部分损坏，无论这个选项设置为 yes 或 no，Redis 都会拒绝启动。</span><br><span class="hljs-comment"># 此选项仅适用于 AOF 文件**末尾**不完整的情况。</span><br><br>aof-load-truncated <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># Redis 在重写 AOF 文件时，可以在 AOF 文件开头使用 RDB 格式的数据来加快重写和恢复过程。</span><br><span class="hljs-comment"># 启用这个选项后，重写后的 AOF 文件由两个部分组成：</span><br><br><span class="hljs-comment">#   [RDB 数据部分][AOF 命令部分]</span><br><br><span class="hljs-comment"># RDB格式往往更快更高效，推荐开启</span><br><br>aof-use-rdb-preamble <span class="hljs-built_in">yes</span><br><br></code></pre></td></tr></table></figure><p>服务器支持把时间戳注解记录在AOF文件中，但是启用的话改变AOF的格式，可能和先存在AOF转换器不兼容。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">aof-<span class="hljs-type">timestamp</span>-<span class="hljs-keyword">enable</span><br></code></pre></td></tr></table></figure><p>valkey附带的有工具修复的原始文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valkey-check-aof --fix &lt;filename&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL技术内幕》读书笔记3-InnoDB</title>
    <link href="/2025/08/17/MySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-InnoDB/"/>
    <url>/2025/08/17/MySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-InnoDB/</url>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ol type="1"><li><a href="#不同存储引擎的比较">不同存储引擎的比较</a></li><li><a href="#连接mysql">连接MySQL</a></li><li><a href="#innodb存储引擎架构">InnoDB存储引擎架构</a><ol type="1"><li><a href="#后台线程">后台线程</a></li><li><a href="#内存">内存</a><ol type="1"><li><a href="#缓冲池">缓冲池</a></li><li><a href="#如何管理内存区域">如何管理内存区域</a></li><li><a href="#重做日志缓冲">重做日志缓冲</a></li></ol></li></ol></li><li><a href="#checkpoint">Checkpoint</a></li><li><a href="#旧版本master-thread">旧版本Master Thread</a><ol type="1"><li><a href="#loop">Loop</a></li><li><a href="#background-loop">background loop</a></li></ol></li><li><a href="#新版本主线程的变化">新版本主线程的变化</a></li><li><a href="#innodb关键特性">InnoDB关键特性</a><ol type="1"><li><a href="#插入缓冲">插入缓冲</a></li><li><a href="#doublewrite">doublewrite</a></li><li><a href="#自适应哈希索引">自适应哈希索引</a></li><li><a href="#异步io">异步IO</a></li><li><a href="#刷新邻居页">刷新邻居页</a></li></ol></li></ol><h2 id="不同存储引擎的比较">不同存储引擎的比较</h2><ul><li>MyISAM:不支持事务、表锁，支持全文索引，缓冲池只缓冲索引文件而不会缓冲数据文件</li></ul><p>面试题可能会让比较InnoDB和MyISAM</p><p><img src="https://s21.ax1x.com/2025/08/13/pVwN15d.png" /></p><p>MyISAM相比于InnoDB的主要缺陷：</p><ul><li><strong>不支持事务</strong>（最大的区别）</li><li>不支持哈希索引</li><li>不支持数据缓存</li><li>不支持外键</li><li>不支持 MVCC/快照读</li></ul><p>InnoDB引擎最大的区别就是：<strong>事务，外键，行级锁</strong>。</p><h2 id="连接mysql">连接MySQL</h2><p><strong>本质上是进程间通信</strong>。</p><p>复习常见的进程间通信方式：</p><ul><li><strong>管道</strong>（Pipe）：半双工通信方式，数据只能单向流动。通常用于父子进程之间的通信。管道分为无名管道和有名管道，无名管道只能在具有亲缘关系的进程间使用，有名管道可以在任意进程间使用。</li><li><strong>消息队列</strong>（MessageQueue）：消息队列是一种消息的链表，存放在内核中，并由消息队列标识符标识。进程可以通过发送和接收消息来进行通信。消息队列可以实现异步通信，发送方和接收方不需要同时运行。</li><li><strong>共享内存</strong>（SharedMemory）：多个进程可以共享一块内存区域，直接对内存进行读写操作，速度非常快。需要使用同步机制（如信号量）来协调对共享内存的访问，以避免竞争条件。另外，共享内存由内核负责管理。</li><li><strong>信号量</strong>（Semaphore）：用于控制多个进程对共享资源的访问。信号量是一个整数，通过对其进行加1 和减 1操作来实现对资源的占用和释放。可以用于实现进程的同步和互斥。</li><li><strong>套接字</strong>（Socket）：可用于不同主机上的进程间通信，也可以用于同一主机上的进程间通信。支持多种通信协议，如TCP、UDP 等。</li></ul><h2 id="innodb存储引擎架构">InnoDB存储引擎架构</h2><p><img src="https://s21.ax1x.com/2025/08/13/pVwdUr6.png" /></p><p>后台线程负责刷新内存池中的数据（LRU），此外把已经修改的数据文件刷新到磁盘文件。</p><h3 id="后台线程">后台线程</h3><p>InnoDB存储引擎是多线程的模型：</p><ul><li>Master Thread 主要负责将缓冲池中的数据异步刷新到磁盘</li><li>IO Thread：负责处理异步 IO 请求的回调，包括write, read, insertbuffer, log IO thread</li><li>Purge Thread：回收不用的undolog</li><li>Page Cleaner Thread：单独的线程，专门用来刷新脏页</li></ul><h3 id="内存">内存</h3><h4 id="缓冲池">缓冲池</h4><ul><li>数据库读取页时，先把从磁盘读到的页缓存在内存缓冲池中。下次再读相同的页时，先看看缓冲池里面有没有，有的话直接读取。</li><li>修改操作，先修改缓冲池中的页，然后再以一定的频率刷新到磁盘。<strong>数据页通过Checkpoint 机制刷新到磁盘</strong>。</li></ul><p>缓冲池缓存的数据页有各种类型，插入缓冲、自适应哈希索引等是不受LRU算法管理的。内存结构如下：</p><figure><img src="https://s21.ax1x.com/2025/08/13/pVw0KNF.png"alt="InnoDB引擎内存结构" /><figcaption aria-hidden="true">InnoDB引擎内存结构</figcaption></figure><p>缓冲池也可以有多个，是可以配置的。</p><h4 id="如何管理内存区域">如何管理内存区域</h4><p>涉及LRU list; Free list; Flush list.</p><p><strong>中点插入策略</strong></p><p>缓冲池以页为单位进行管理，一页是16KB，使用改进的 LRU算法对缓冲池进行管理。具体来说，InnoDB存储引擎引入了 midpoint insertionstrategy，最新访问的页不会直接移动到链表约头部，而是先放到<code>midpoint</code>。该位置可以通过下面的命令查询：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_old_blocks_pct&#x27;</span>;<br></code></pre></td></tr></table></figure><p>默认值为<code>37</code>，表示距离尾部37%的位置。该 midpoint将LRU链表分为两部分：</p><ul><li>young区 前5/8，属于热点区</li><li>old区，后3/8，属于老旧区</li></ul><p><strong>延迟提升机制</strong></p><p><code>innodb_old_blocks_time</code>，页第一次被插入中点后，如果下次访问距离上次访问时间小于该数值（默认1000ms），不会被提升到热点区。如果页成功熬过该时间被晋升到热点区，就称之为<code>page made young</code>。</p><p><strong>空闲列表</strong></p><p>空闲列表 Free list记录了尚未被使用的内存页。<code>Free Buffers</code>就是空闲列表中页的数量，<code>Database pages</code>则是LRU列表中页的数量。</p><ul><li>如果LRU列表尚未满，就从空闲列表中寻找可用的内存页，找到就删除，放入LRU列表。如果</li><li>Page Cleaner线程检查剩余页的数量，如果LRU列表的空闲页不足100个，根据LRU算法淘汰尾部的页，把释放的空间分配给新的页。</li></ul><p>LRU链表支持压缩页，通过unzip_LRU列表管理，原来16KB的页可以被压缩到8KB和4KB。</p><p><strong>Flush List</strong></p><p>Flush List用于管理脏页刷新到磁盘。Flush List和LRUList都记录了脏页，后者用于管理页的可用性，前者用于刷盘。</p><h4 id="重做日志缓冲">重做日志缓冲</h4><p>重做日志首先被写入这个缓冲区，然后按照一定的频率刷新到磁盘文件。<strong>重做日志文件的刷盘时机</strong>：</p><ul><li>Master Thread 每秒刷盘一次</li><li>每个事务提交时</li><li>redo log buffer剩余空间小于1/2时</li></ul><p>查看重做日志缓冲区大小的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> varaibles <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_log_buffer_size&#x27;</span>\G;<br></code></pre></td></tr></table></figure><p>我查出来的是16MB。重做日志缓冲区不会太大，因为刷频时机足够频繁，缓冲区不会积累过多的日志。</p><h2 id="checkpoint">Checkpoint</h2><blockquote><p><strong>WAL策略</strong>：<strong>事务提交时，先写重做日志，再修改数据页</strong>。当由于系统崩溃导致数据丢失时，通过重做日志来完成数据的恢复。</p></blockquote><p>检查点技术的目的：</p><ul><li>缩短数据库的恢复时间</li><li>缓冲池不够用时，强制执行检查点，根据LRU算法将溢出的脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页。重做日志是循环可重用的，不需要的日志会被覆盖。如果即将被覆盖的日志还需要使用，就需要执行检查点，将磁盘至少同步到即将被覆盖的日志以后的状态，防止状态丢失。</li></ul><p>InnoDB存储引擎通过LSN来标记版本，日志、页、检查点都有自己的LSN。数据库启动时，从checkpoint的LSN开始向后读取重做日志，恢复数据库。</p><h2 id="旧版本master-thread">旧版本Master Thread</h2><p>Master Thread内部包含多个循环。</p><h3 id="loop">Loop</h3><p><strong>Loop</strong>称为主循环，包含每秒钟的操作和每十秒钟的操作。每秒一次的操作包括：</p><ul><li><strong>把日志缓冲刷新到磁盘，即使事务还没有提交</strong>（总是）</li><li>（可能）合并插入缓冲，前提是IO压力很小</li><li>（可能）最多刷新100个缓冲池中的脏页到磁盘，前提是缓冲池脏页的比例超过90%（后来刷新脏页被分离给了单独的线程）</li><li>（可能）如果没有用户活动，切换到background loop</li></ul><p>每十秒的操作包括以下内容：</p><ul><li>（可能）刷新100个脏页到硬盘</li><li>（总是）合并最多五个插入缓冲</li><li>（总是）将日至缓冲刷新到磁盘</li><li>（总是）删除无用的undo页。对表进行delete、update时，原先的行被标记为删除，版本信息被保留，由这一步fullperge删除。</li><li>（总是）刷新100个或者10个脏页到磁盘</li></ul><h3 id="background-loop">background loop</h3><p>数据库空闲或者关闭时，就会切换到这个循环。该循环进行以下操作</p><ul><li>（总是）删除无用的undo页</li><li>（总是）合并20个插入缓冲</li><li>（总是）如果不空闲，回到主循环</li><li>否则跳转到flush loop，刷新缓冲池100个脏页</li></ul><h2 id="新版本主线程的变化">新版本主线程的变化</h2><ul><li>刷新到磁盘的页数量不再限制为100，可以通过<code>innodb_io_capacity</code>设定，默认200。从缓冲区刷新脏页时，刷新脏页的数量为<code>innodb_io_capacity</code>；合并插入缓冲是这个值的5%。</li><li>原来脏页达到90%才会开始刷新，后来把默认值改成了75%。</li><li><code>innodb_adaptive_flushing</code>，通过判断重做日志的产生速度决定刷新脏页的数量。</li><li>可以根据需要修改 full perge 每次回收的脏页数量。</li><li>最后把刷新脏页的操作单独分了到了一个线程 Page Cleaner。</li></ul><h2 id="innodb关键特性">InnoDB关键特性</h2><p><img src="https://s21.ax1x.com/2025/08/14/pVwgttP.png" /></p><h3 id="插入缓冲">插入缓冲</h3><p><code>Insert Buffer</code></p><p>插入缓冲不是缓存(cache)，而是表空间的一部分，主要用于处理非唯一索引的插入和更新操作。</p><ul><li>行数据的插入顺序是按照逐渐递增的顺序插入，速度非常快</li><li>存放顺序还是主键，导致非聚集索引页的访问是离散的，插入也是离散的，速度较慢</li></ul><p>如果辅助索引是<strong>非唯一</strong>的，那么就可以使用<strong>插入缓冲</strong>来<strong>提高辅助索引的插入性能</strong>：</p><p>对于非唯一索引，辅助索引的修改操作并非实时更新索引页，而是把若干对同一页面的更新缓存起来做，合并为一次性更新操作，减少IO。而且转随机IO为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能。</p><blockquote><p>插入或者更新辅助索引时，先判断要插入的页是否在缓冲池中，如果是则直接插入，否则先放入到缓冲池的插入缓冲对象，后续再合并，这样一次能执行多个插入。</p></blockquote><p><code>Change Buffer</code></p><p>插入缓冲的升级版，适用于非唯一的辅助索引，涵盖了插入，更新，删除三个操作。</p><p><strong>插入缓冲内部实现</strong></p><p>数据库全局拥有一个B+树，负责对所有表的辅助索引进行插入缓冲。B+树存放在共享表空间。非叶子节点存放的是searchkey键值，即：</p><p>合并插入缓冲见P65.合并的目的，是把插入缓冲记录的辅助索引合并到真正的辅助索引中。</p><p>工作流程：</p><ol type="1"><li>Buffering：当需要插入或者更新辅助索引时，如果索引页在缓冲池则直接更新，如果相应的索引页不在缓冲池中，那么就把修改操作缓存在<code>插入缓冲</code>中。</li><li>Bitmaptracking：用一个位图页跟踪缓冲池中每个索引页的空闲空间。<br /></li><li>合并：被缓冲的更改会被定期合并回真正的索引页。</li></ol><p>合并发生的时机：</p><blockquote><p>The buffered changes are periodically merged back into the actualindex pages. This can happen in several scenarios:</p><ul><li>On-demand merge: When a page containing buffered changes is accessed(read), the changes are merged before the page is returned.</li><li>Scheduled merge: The InnoDB master thread periodically checks formerge operations.</li><li>Bitmap-triggered merge: If the Insert Buffer Bitmap indicates thatan index page has little free space left, a merge operation istriggered.</li></ul></blockquote><h3 id="doublewrite">doublewrite</h3><p>双写主要用来解决数据页刷新到磁盘时，因为意外导致写了不完整的数据页的问题。</p><p>关于IO的最小单位：</p><ol type="1"><li><p>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</p></li><li><p>文件系统IO的最小单位是4K（也有1K的）</p></li><li><p>磁盘IO的最小单位是512字节</p></li></ol><p>重做日志以页为单位进行恢复，但是如果在数据页刷新到磁盘的过程中（每次4KB，但是完整的一页是16KB），页本身发生损坏（比如写到一半的时候宕机了），那redo也无力回天。</p><blockquote><p>重做日志是以<strong>日志块</strong>（redo logblock）为单位进行存储的，而一个日志块的大小是（512字节），原因就在上面。得益于此，日志块512字节的写入也都是原子的，而且不管是缓存中还是磁盘中，重做日志都是以块的方式存储的。所以写日志到磁盘的过程不需要担心页写不完整的问题。</p></blockquote><p>doublewrite由两部分组成，一部分为内存中的<code>doublewrite buffer</code>，其大小为2MB，另一部分是磁盘上共享表空间(ibdatax)中<strong>连续</strong>的128个页，即2个区(extent)，大小也是2M。双写的工作原理：</p><blockquote><p>触发脏页刷新过程时，先把脏页复制到内存中的<code>doublewrite buffer</code>，然后写入磁盘共享表空间中的区域，最后马上调用<code>fsync</code>，把缓冲区中的脏页写入实际的磁盘文件（离散写）。</p></blockquote><p>尽管双写操作要求每个页面写入两次，但其开销远低于一般的两次写操作。磁盘中的共享表空间区域都是连续的，因此开销非常低。它还允许Innodb 节省 <code>fsync()</code> 操作——Innodb 无需为每个页面写入都调用<code>fsync()</code>，而是提交多个页面写入并调用<code>fsync()</code>，这使得操作系统能够优化写入的执行顺序，并并行使用多个设备。虽然这种优化可以在没有双写操作的情况下使用，但它只是同时实现的。因此，总体而言，我预计使用双写操作的性能损失不会超过5-10%。</p><p><strong>崩溃恢复</strong></p><p>如果将页写入磁盘中实际文件的过程中宕机，那么innoDB可以从磁盘共享表空间区域找到副本，复制到正确的位置即可，这样就恢复了页，再读取redolog，就恢复了所有记录。</p><h3 id="自适应哈希索引">自适应哈希索引</h3><p>InnoDB自动建立哈希索引，从B+树改造而来，尤其是热点数据。</p><h3 id="异步io">异步IO</h3><p>当前数据库都采用异步IO操作。脏页的刷新（磁盘的写入）全部由异步IO完成.</p><h3 id="刷新邻居页">刷新邻居页</h3><p>当刷新一个脏页时，检测该页所在区的所有页，如果是脏页则一起刷新。可以关闭，对于固态硬盘不需要这个。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL技术内幕》读书笔记2-事务</title>
    <link href="/2025/08/17/MySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2025/08/17/MySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ol type="1"><li><a href="#事务的特性">事务的特性</a></li><li><a href="#事务的分类">事务的分类</a></li><li><a href="#redo">redo</a><ol type="1"><li><a href="#binlog">binlog</a></li><li><a href="#log-block-重做日志存储格式">log block重做日志存储格式</a></li><li><a href="#log-group">log group</a></li><li><a href="#重做日志内容格式">重做日志内容格式</a></li><li><a href="#lsn">LSN</a></li></ol></li><li><a href="#undo">undo</a><ol type="1"><li><a href="#undolog的格式">undolog的格式</a></li><li><a href="#purge">purge</a></li></ol></li><li><a href="#group-commit">group commit</a></li><li><a href="#事务的隔离级别">事务的隔离级别</a></li><li><a href="#分布式事务">分布式事务</a><ol type="1"><li><a href="#xa事务">XA事务</a></li><li><a href="#两阶段提交">两阶段提交</a></li></ol></li><li><a href="#长事务">长事务</a></li></ol><h2 id="事务的特性">事务的特性</h2><p>ACID</p><table><thead><tr><th>特性</th><th>英文缩写</th><th>关键点</th><th>实现机制</th></tr></thead><tbody><tr><td>原子性</td><td>A</td><td>全部成功或全部失败</td><td>undo log</td></tr><tr><td>一致性</td><td>C</td><td>数据从一种一致状态到另一种一致状态</td><td>依赖 A、I、D</td></tr><tr><td>隔离性</td><td>I</td><td>并发事务互不干扰</td><td>锁、MVCC</td></tr><tr><td>持久性</td><td>D</td><td>提交的数据不会丢</td><td>redo log</td></tr></tbody></table><h2 id="事务的分类">事务的分类</h2><ul><li>扁平事务 Flat</li><li>带有保存点的扁平事务 Savepoints</li><li>链事务 Chained</li><li>嵌套事务 Nested</li><li>分布式事务 Distributed</li></ul><p><strong>扁平事务</strong>：最简单的一种，BEGIN开始，COMMIT结束，要么都提交，要么都不提交。</p><p>带有保存点的扁平事务允许部分回滚，这是通过设置保存点来实现的。用法：<code>SAVEPOINT 保留点的名称</code>，回滚<code>ROLLBACK TO 保留点的名字</code></p><p>扁平事务的保存点在系统崩溃后会丢失，而<strong>链事务</strong>解决了这一问题。当一个事务提交（COMMIT）或回滚（ROLLBACK）后，数据库会<strong>立即自动开启一个新的事务</strong>，提交事务的操作和开启下一个事务的操作是一个原子操作，就好像在一个事务中进行的一样。而且，链事务只能回滚到最近的一个保存点。</p><p><strong>嵌套事务</strong>：嵌套结构，顶层事务控制着下面的子事务，子事务既可以是扁平的也可以是嵌套的，形成一个树状结构，如图所示：</p><figure><img src="https://s21.ax1x.com/2025/08/11/pVdrlJe.png"alt="嵌套事务的层次结构" /><figcaption aria-hidden="true">嵌套事务的层次结构</figcaption></figure><p>类似数据结构中的树，处于根节点的事务被称为顶层事务，其他事务被称为儿子事务；事务的前驱被称为父事务，下一层被称为儿子事务。</p><p>任何子事务在顶层事务提交后才会真正被提交；树中的任意一个事务的回滚会引起它的所有的子事务一同回滚。</p><p><strong>InnoDB并不原生支持嵌套事务</strong></p><h2 id="redo">redo</h2><p>重做日志用来实现<strong>事务</strong>的<strong>持久性</strong>，由两部分组成：</p><ul><li>内存中的<strong>重做日志缓冲</strong></li><li>硬盘中的<strong>重做日志文件</strong></li></ul><p><em>事务提交时，必须将所有的缓冲重做日志都写入到磁盘中</em>。为了确保这一点，InnoDB引擎会调用<code>fsync</code>，目的是将文件系统写缓冲区的数据立即写入磁盘。</p><p><code>innodb_flush_log_at_trx_commit</code>控制重做日志刷新到磁盘的策略。默认情况下，值为1，事务提交时必须调用fsync。0表示把写入重做日志的操作交给主线程，每隔1秒执行一次；2表示事务提交时把重做日志写入文件系统的写缓冲中，由文件系统决定延迟写入。</p><p>手动关闭<code>fsync</code>（把参数设置成0或者2）可以明显提高数据库的性能，代价是丧失了事务的ACID特性。</p><h3 id="binlog">binlog</h3><p>binlog，二进制日志，用于<strong>主从复制和数据恢复</strong>。binlog有三种模式：</p><ul><li>ROW: 记录每一行的变化</li><li>STATEMENT：记录原始SQL语句</li><li>MIXED：默认该模式，优先使用STATEMENT，如果可能导致主从不一致才会使用ROW。</li></ul><p>如果是STATEMENT，binlog的原理和操作系统的文件系统日志差不多，都属于逻辑日志，与 redo日志的区别：</p><ul><li>管辖范围：redo日志由 InnoDB存储引擎产生，不记录存储引擎以外的操作；binlog在MySQL数据库的上层产生，一个数据库可以使用多个存储引擎，任何存储引擎对数据库更改都会产生二进制日志。</li><li>binlog是一种逻辑日志，记录SQL语句；redo日志是物理日志，记录具体的修改数据。</li><li>二进制日志只在事务提交完成后写入一次，redo日志在执行时就不断写入缓冲区</li></ul><table><thead><tr><th>特性</th><th>binlog</th><th>redo log</th></tr></thead><tbody><tr><td>写入时机</td><td>事务提交时一次性写入</td><td>执行过程中不断写入</td></tr><tr><td>记录内容</td><td>逻辑操作（SQL 或行变更事件）</td><td>物理页修改</td></tr><tr><td>顺序</td><td>严格按事务提交顺序</td><td>按物理修改产生的先后顺序（可能交错）</td></tr><tr><td>作用</td><td>归档、复制</td><td>崩溃恢复（保证持久性）</td></tr></tbody></table><p>具体解释一下，对于 redo日志来说，事务执行时，每条修改语句立即把对应的物理页修改记录写入 redolog buffer缓冲区中，这里借用了文件系统的缓冲区，一旦写入，文件系统就会根据自身的规则延迟将其写入磁盘。因此事务没提交时，redolog也可能<strong>已经部分写入磁盘</strong>，提交时调用<code>fsync</code>是为了确保所有尚未写入磁盘的数据都能被写入完毕。</p><p>对于 binlog 来说，每条会产生 binlog的语句会把对应的逻辑操作记录写入<code>binlog cache</code>，<strong>事务提交前永远也不会写入磁盘</strong>，事务提交时才开始写入（缓冲写），避免记录未提交的事务。</p><h3 id="log-block-重做日志存储格式">log block 重做日志存储格式</h3><blockquote><p>磁盘提供的原子性保证：磁盘保证任何 512字节的写入都会发生或不发生。</p></blockquote><p>重做日志是以<strong>日志块</strong>（redo logblock）为单位进行存储的，而一个日志块的大小是（512字节），原因就在上面。得益于此，日志块512字节的写入也都是原子的，而且不管是缓存中还是磁盘中，重做日志都是以块的方式存储的。所以重做日志不需要doublewrite机制维护页的完整性，因为磁盘本身已经保证了。</p><p><strong>redo buffer的结构</strong>（磁盘上的结构跟这个差不多）</p><p><img src="https://s21.ax1x.com/2025/08/11/pVd6kRg.png" /></p><ul><li>块头部：12字节</li><li>数据块：492字节</li><li>块尾部：8字节</li></ul><p><strong>日志块头部</strong>又由四部分组成，从上到下一次占用4、2、2、4字节。从上到下的作用依次为：</p><ol type="1"><li>标记该块在缓冲区中的位置，循环使用</li><li>该块已经被使用的大小，最大<code>0x200</code>即512字节</li><li>该日志块中，第一个新日志的偏移量。因为一个数据块中可能包含某个较大的重做日志的后半部分，所以需要加一个偏移量用来标记下一个日志的起点位置。</li><li>检查点的编号，检查点的意思是在次之前的数据和元数据都已经写入磁盘，全局递增</li></ol><p><strong>尾部</strong>字段和头部的第一个字段的值相同，可用于<strong>完整性校验</strong>，因为写入redo日志时是先写头部、数据块，再写尾部，如果尾部还没写完，就能判断这个块不完整。</p><h3 id="log-group">log group</h3><p><strong>重做日志组</strong>，是由一组 redo日志文件构成的集合。磁盘中的的 redo log并不是一个文件，而是<strong>一组大小相等的日志文件</strong>，也就是日志组。日志组和日志文件之间的关系：</p><p><img src="https://s21.ax1x.com/2025/08/11/pVd6ISg.png" /></p><p>日志组中的第一个日志文件还保存了2KB的元数据，用于恢复存储引擎。其余日志文件保留2KB的区域，但是不写入数据。这2KB区域的结构如下：</p><table><thead><tr><th>名称</th><th>大小（字节）</th><th>作用</th></tr></thead><tbody><tr><td>log file header</td><td>512</td><td>记录日志组的配置信息，如groupID、LSN</td></tr><tr><td>检查点1</td><td>512</td><td>第一份检查点信息</td></tr><tr><td>空</td><td>512</td><td>保留区</td></tr><tr><td>检查点2</td><td>512</td><td>第二份检查点的信息</td></tr></tbody></table><p>其中检查点信息用于存储最近一次检查点的 LSN 位置，即已经持久化到磁盘的redo 日志的位置。</p><figure><img src="https://s21.ax1x.com/2025/08/11/pVdNdmD.png" alt="逻辑结构" /><figcaption aria-hidden="true">逻辑结构</figcaption></figure><h3 id="重做日志内容格式">重做日志内容格式</h3><p><strong>InnoDB基于页进行管理，所以重做日志的格式也是基于页的</strong>。下面讨论重做日志的logblock里存储的内容是按照什么格式进行的。</p><ul><li>通用头部<ul><li>redo_log_type：重做日志的类型</li><li>space：表空间的id</li><li>page_no：页的偏移量。</li></ul></li><li>redo log body：内容根据重做日志的类型而不同</li></ul><p>log buffer根据一定的规则持久化到磁盘中的日志文件中，而且属于<strong>追加写入</strong>。</p><h3 id="lsn">LSN</h3><p>前面提到，日志组的第一个重做日志文件存储的 log file header存储了LSN。LSN 的全称是 Log SequenceNumber，<strong>日志序列号</strong>，是数据库中为每条日志记录分配的唯一且递增的编号，通常以字节偏移量表示日志在日志文件中的位置。<strong>在InnoDB 里，LSN 记录了重做日志写入的总字节数，从数据库实例启动时开始累计递增</strong>。</p><p>日志、页、检查点都有自己的LSN。</p><p>LSN不仅位于重做日志，也位于每个页的头部，页头部的LSN表示该页最后一次被修改时LSN 的大小，用于检测是否需要恢复操作。如果页的 LSN小于重做日志，说明需要恢复。</p><p>使用<code>show engine innodb status</code>查看LSN的情况：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-string">LOG</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">Log</span> <span class="hljs-string">sequence</span> <span class="hljs-string">number</span> <span class="hljs-number">116339</span><br><span class="hljs-string">Log</span> <span class="hljs-string">flushed</span> <span class="hljs-string">up</span> <span class="hljs-string">to</span>   <span class="hljs-number">116339</span><br><span class="hljs-string">Pages</span> <span class="hljs-string">flushed</span> <span class="hljs-string">up</span> <span class="hljs-string">to</span> <span class="hljs-number">116339</span><br><span class="hljs-string">Last</span> <span class="hljs-string">checkpoint</span> <span class="hljs-string">at</span>  <span class="hljs-number">116323</span><br></code></pre></td></tr></table></figure><p>解释：</p><ul><li>LSN序列号，表示重做日志的进度</li><li>刷新到重做日志文件的LSN，这里表示日志文件中已经包含了所有的最新记录。</li><li>缓存到 Buffer Pool中的数据页已经写入磁盘的进度，实时刷新。这里表示所有的数据页都已经刷新到磁盘。</li><li>检查点是崩溃恢复的起始标记，检查点按照一定规则定期刷新</li></ul><p>InnoDB引擎会记录最后一次检查点的位置，每次在启动引擎时，都会进行恢复操作，<strong>从上一次检查点开始读取重做日志</strong>进行恢复。又因为重做日志是物理日志，记录的是具体的数据，所以恢复速度要快得多。而且重做日志是可以多线程<strong>并行</strong>进行的，具体的实现方法是把日志分成无冲突的不同分区，交给不同的线程并行执行，而有冲突的操作必须顺序执行。</p><h2 id="undo">undo</h2><p>redo 用于数据库的恢复，而 undo用于<strong>回滚</strong>，属于逻辑日志。对数据库的修改既会产生 redo日志，也会产生 undo，同时 undo 日志也有对应的 redo 日志，因为 undo也是需要持久化，保证断电或崩溃后能正确回滚。</p><p>uodo日志主要有两个作用：</p><ul><li><strong>逻辑回滚</strong>rollback</li><li><strong>MVCC实现非锁定读</strong>。当读取记录时，若该记录被其他事务加锁，或当前版本对该事务不可见，则可以通过undo log 读取之前的版本数据，以此实现非锁定读。</li></ul><p>执行回滚操作时读取 undo日志，将数据库<strong>逻辑地</strong>恢复到原来的样子。比如，一个用户插入了10W条数据，这会导致表空间的增大，但是undo日志只是记录相反的操作<code>DELETE</code>，并不会把表空间的大小也缩小到原来的状态。</p><p><strong>存储位置：</strong>表空间的<code>undo segment</code>。<strong>管理方式</strong>：<code>rollback segment</code>，一个rollback段包含1024个undo segment。以段为单位申请页。</p><p>事务提交时，undo log的去向：</p><ul><li>将 undo log 放入一个链表(History List)</li><li>判断 undo log 所在的页是否可以重用，可以就继续分配给下一个事务</li></ul><p>由 purge 线程负责最终删除 undo log。</p><h3 id="undolog的格式">undolog的格式</h3><p>分为两种，一种是针对不存在的数据，一种是针对已经存在的数据</p><ul><li>insert undo log。</li><li>update undo log，包含 update 和 delete 两个操作</li></ul><p>insert日志可以在事务提交后直接删除，但是update不行，还要用于MVCC机制，所以先放入历史链表中，链表头部是最新的记录。</p><p>用下面的命令可以查看事务状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.innodb_trx\G<br></code></pre></td></tr></table></figure><h3 id="purge">purge</h3><p>清理思路：清理之前的delete和update，使其最终完成。适用于已经不被任何事务引用的操作。</p><p>先从HistoryList找到第一个需要被清理的日志，然后从该日志所在的页继续找别的需要清理的日志，找不到就回到链表往下找。</p><p><img src="https://s21.ax1x.com/2025/08/12/pVdoKGn.png" /></p><h2 id="group-commit">group commit</h2><ul><li>对于只读事务，不涉及磁盘文件的更改，所以提交时不需要fsync</li><li>对于非只读事务，必须在事务提交时立即执行fsync，保证 redo日志都已经写入磁盘。</li></ul><p>传统单事务提交每个事务都要调用一次fsync，groupcommit是为了提高fsync的效率，一次性将多个重做日志写入磁盘。<strong>工作原理</strong>：</p><ul><li>当第一个事务请求提交时，会发起磁盘同步请求。</li><li>在磁盘同步完成前，如果有其他事务也发起提交，这些事务不会立即调用fsync，而是等待第一个事务的同步结果。</li><li>这样，多个事务的日志写入可以被合并到一个磁盘写入操作中，一次 fsync同时保证了多个事务的持久化。</li><li>等待的事务在磁盘同步完成后，统一收到提交成功的通知，完成提交流程。</li></ul><p>同时提交的事务越多，groupcommit的效果越明显，数据库性能的提升就越大。</p><hr /><p>InnoDB 1.2 之前，开启 binlog会让事务提交流程串行执行，<code>binlog fsync</code> 和<code>redo log fsync</code> 不能并行或者合并执行，从而让 group commit失效。MySQL 5.6 引入 binlog group commit 才解决了这个问题：</p><p><img src="https://s21.ax1x.com/2025/08/12/pVwPUxK.png" /></p><h2 id="事务的隔离级别">事务的隔离级别</h2><p>有四种事务隔离的级别标准，但是很少有数据厂商遵循这些标准，比如Oracle不支持RR隔离级别。</p><ul><li>RU：READ UNCOMMITED</li><li>RC: READ COMMITED</li><li>RR: REPEATABLE READ</li><li>SERIALIZABLE</li></ul><p>InnoDB存储引擎默认RR，但是附带Next-key算法，避免了幻读。默认RR没有幻读保护。</p><h2 id="分布式事务">分布式事务</h2><p>分布式事务允许多个不同的事务来源参与到一个全局事务中。使用分布式事务必须把InnoDB引擎的事务隔离等级提升为SERIALIZABLE。</p><h3 id="xa事务">XA事务</h3><p>XA事务是一种分布式事务协议，它扫描多个资源来源，比如数据库、消息队列，可以确保不同资源之间的一致性。XA事务使用<strong>两阶段提交协议</strong>，由全局事务管理器控制，可以确保要么更改全部被提交，要么全部不提交。</p><p>XA事务分为<strong>外部和内部两种</strong>：</p><ul><li>外部XA事务：<strong>由外部事务管理器负责协调</strong>，MySQL也只是一个参与者（RM），MySQL不负责全局事务的协调</li><li>内部XA事务：<strong>MySQL本身就是协调器</strong>，主要发生在 MySQL的内部，InnoDB存储引擎和binlog之间，用于主从复制。</li></ul><p>XA 的组成：</p><ul><li>AP，Application Program，事务发起方，应用程序</li><li>TM，TransactionManager，事务管理器，也叫协调器，负责调度多个资源的提交和回滚，与所有参与全局事务的资源管理器进行通信。</li><li>RM，ResourceManager，资源管理器，也叫参与者，提供访问事务资源的方法，比如数据库，消息队列</li></ul><h3 id="两阶段提交">两阶段提交</h3><p>参考：https://en.wikipedia.org/wiki/Two-phase_commit_protocol</p><p>Two-phase commit, 2PC</p><p>2PC是一种<strong>分布式算法</strong>，用于协调参与到分布式原子事务的进程是否提交或者终止/回滚事务。为了从故障中恢恢复，参与者需要记录日志。</p><p><strong>外部XA：</strong></p><ol type="1"><li>预提交请求阶段：应用程序发起事务，每个资源管理器执行事务但不真正提交，并记录足够的日志以保证之后可以安全提交或回滚。所有参与者告诉事务管理器准备就绪或者失败。</li><li>如果所有的参与者都返回准备就绪，事务管理器就发送commit请求，有任何一个失败则发送终止或回滚请求。</li></ol><p><strong>内部XA：</strong>用于保证<strong>主从复制的一致性</strong></p><p><img src="https://s21.ax1x.com/2025/08/12/pVwPIaj.png" /></p><ol type="1"><li>主库把事务的修改写入 redo logbuffer，调用<code>fsync</code>，然后标记为<code>prepare</code>状态，<strong>先不提交事务</strong>。</li><li>MySQL服务层将事务的SQL语句写入binlogcache，然后<code>fsync</code>持久化到binlog文件。</li><li>（仅限主从复制同步）主库把binlog文件发送给从库，从库IO线程将其写入<code>relay log</code>，这一步是为了复制同步</li><li>服务层调用commit，InnoDB 将之前准备状态的redolog改成commit状态，正式提交事务。此时redo log和 binlog 都持久化。</li></ol><blockquote><ul><li>redolog目的是恢复已经提交，但是还没有完全写入磁盘的事务，循环写，会覆盖旧日志，只能恢复到最近一次崩溃前的状态。只限于InnoDB内部使用。目的是保证事务持久性。</li><li>binlog记录MySQL的所有逻辑操作，文件无限追加，可长期保存，所以可以恢复到任意时间点。主从复制时，从库可以读取binlog用于复制。能够跨引擎使用。负责复制和历史恢复（尤其是从机）。只能从头重放，速度非常慢，所以不适合用来崩溃恢复。</li></ul></blockquote><p>重启恢复时，MySQL先检查binlog，如果找不到事务的记录就直接回滚到原来的状态；如果能找到，说明第二步已经执行过了,继续看redo log的状态：如果是<code>preapare</code>，说明两个日志都已经写入磁盘，就差最后一步提交了，那就直接补一个<code>commit</code>指令即可。</p><h2 id="长事务">长事务</h2><p>例如：更新表中的一亿条数据。采用分批处理的思想比较好。伪代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql">void ComputeInterest(<span class="hljs-keyword">double</span> interest_rate) &#123;<br>    long last_account_done, max_account_no, log_size;<br>    <span class="hljs-type">int</span> batch_size <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br><br>    <span class="hljs-comment">-- 检查是否存在上下文</span><br>    <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> log_size <span class="hljs-keyword">FROM</span> batchcontext;<br><br>    <span class="hljs-comment">-- 首次执行的逻辑</span><br>    if (SQLCODE <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> <span class="hljs-operator">||</span> log_size <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> batchcontext;<br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> batchcontext (last_account_done <span class="hljs-type">BIGINT</span>);<br><br>        last_account_done <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> batchcontext <span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">-- 从上下文表中获取上次处理的位置</span><br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">SELECT</span> last_account_no<br>                 <span class="hljs-keyword">INTO</span> last_account_done<br>                 <span class="hljs-keyword">FROM</span> batchcontext;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> max_account_no<br>             <span class="hljs-keyword">FROM</span> account LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br><br>    WHILE (last_account_no <span class="hljs-operator">&lt;</span> max_account_no) &#123;<br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">START</span> TRANSACTION;<br><br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">UPDATE</span> account<br>                 <span class="hljs-keyword">SET</span> account_total <span class="hljs-operator">=</span> account_total <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> interest_rate)<br>                 <span class="hljs-keyword">WHERE</span> account_no <span class="hljs-keyword">BETWEEN</span> last_account_no<br>                                       <span class="hljs-keyword">AND</span> last_account_no <span class="hljs-operator">+</span> batch_size;<br><br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">UPDATE</span> batchcontext<br>                 <span class="hljs-keyword">SET</span> last_account_done <span class="hljs-operator">=</span> last_account_done <span class="hljs-operator">+</span> batch_size;<br><br>        <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">COMMIT</span> WORK;<br><br>        last_account_done <span class="hljs-operator">=</span> last_account_done <span class="hljs-operator">+</span> batch_size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心设计思想：</strong></p><ol type="1"><li>分批处理策略：设定一个固定批次大小，分批处理</li><li>断点续传机制：使用<code>batchcontext</code>表<strong>记录处理进度</strong>，支持中断后从上次停止的位置继续执行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL技术内幕》读书笔记1-锁</title>
    <link href="/2025/08/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
    <url>/2025/08/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="锁的类型">锁的类型</h2><p>InnoDB引擎有两种行级锁：</p><ul><li><strong>共享锁</strong> S：允许事务读一行数据</li><li><strong>排他锁</strong> X: 允许事务删除或者更新一行数据。</li></ul><p>除此之外还有意向锁，意向锁是为了告诉表在更细的粒度上加锁</p><ul><li><strong>意向共享锁：事务想要获得某几行的共享锁</strong></li><li><strong>意向排他锁：事务想要获得某一行的排他锁</strong></li></ul><h3 id="读操作">读操作</h3><p><strong>一致性非锁定读：</strong></p><blockquote><p>如果读取的行正在执行删除或者更新操作，这时不会去等待锁的释放，而是读取锁的一个快照数据。</p></blockquote><p><strong>一致性锁定读：</strong></p><p>某些情况下，需要显式加锁，这就需要带锁的查询语句：</p><ul><li>select for update 加一个X行锁</li><li>select in share mode 加一个S行锁</li></ul><h3 id="自增长加锁">自增长加锁</h3><p>InnoDB老版本采用的策略是单独调用一个语句，为整张表加上特殊的表锁来更新自增计数器的值，完成插入后马上释放，但是这样仍然会带来较大的开销。新版本采用更细的方式，根据不同的语句加不同的锁，互斥量、传统表锁都有用到。</p><h3 id="外键和锁">外键和锁</h3><p>InnoDB会自动为外键加上索引。</p><p>如果父表在操作时已经为外键加上了X锁，那么子表不能再对外键加上S锁或者X锁，必须等待父表执行完毕。</p><h3 id="表级锁">表级锁</h3><h4 id="表锁">表锁</h4><p>粒度是整张表，主要是防止其他线程对表或者结构进行冲突操作。适用于全表备份。</p><p>一般情况下只有当你显式使用<code>LOCK TABLES ... READ/WRITE</code>才会加表锁。在极少数情况下（不使用索引导致的全表扫描，崩溃恢复，DDL）也会自动加表锁。</p><h4 id="元数据锁">元数据锁</h4><p><strong>任何涉及到访问表的语句（无论 DML 还是 DDL）都会自动加MDL</strong>。</p><p>作用是保护表结构的一致性，防止在读/写表数据时表结构被改掉。<strong>自动加锁</strong>，<strong>增删改查会申请元数据共享锁，修改表会申请元数据排他锁</strong>。共享锁意味着，读写是可以并发的，但是和排他锁是互斥的。排他锁意味着，调用DDL 后，必须等所有正在执行的 DML/DQL 完成之后才能开始执行。</p><blockquote><ul><li><strong>兼容</strong>：两种锁可以同时存在，不会互相阻塞</li><li><strong>互斥</strong>：会互相阻塞，必须等待另一方释放锁</li></ul></blockquote><p>规则总结：</p><p>首先，从 MySQL 5.5 开始，<strong>所有对表的操作（查询 / 增删改 /DDL）都会自动加元数据锁</strong>，自动加的锁有以下几种类型：</p><ul><li>普通查询 (SELECT) → <code>SHARED_READ</code><ul><li>和查询、DML 兼容</li><li>和 DDL 互斥</li></ul></li><li>增删改：DML (INSERT / UPDATE / DELETE) → <code>SHARED_WRITE</code><ul><li>和查询、DML 兼容</li><li>和 DDL 互斥</li></ul></li><li>修改表结构：DDL (ALTER / DROP / RENAME TABLE) →<code>EXCLUSIVE</code><ul><li>和任何锁互斥</li><li>必须等所有读/写锁释放才能执行</li></ul></li></ul><p>其次，如果主动调用<code>LOCK TABLES xxx READ / WRITE;</code>，MySQL会给表加更强的<strong>手动锁</strong>，对应的 MDL模式就是下面的<code>SHARED_READ_ONLY</code>和<code>SHARED_NO_READ_WRITE</code>。这两种锁的特点：</p><ul><li><code>LOCK TABLES t READ</code>：其他会话只能读（可以加<code>SHARED_READ</code>），不能写，但是自己可以读</li><li><code>LOCK TABLES t WRITE;</code>：其他对话既不能读，也不能写，但是自己可以的读写。属于<strong>独占强锁</strong>。</li></ul><table><thead><tr><th>模式</th><th>常见触发 SQL</th><th>作用</th></tr></thead><tbody><tr><td><strong>SHARED_READ</strong></td><td>普通 <code>SELECT</code></td><td>允许并发读写，阻止 DDL</td></tr><tr><td><strong>SHARED_WRITE</strong></td><td><code>INSERT/UPDATE/DELETE</code></td><td>允许并发写，阻止 DDL</td></tr><tr><td><strong>EXCLUSIVE</strong></td><td><code>ALTER TABLE</code></td><td>独占表元数据，阻止所有读写</td></tr><tr><td><strong>SHARED_READ_ONLY</strong></td><td><code>LOCK TABLES t READ</code></td><td>限制其他会话不能写</td></tr><tr><td><strong>SHARED_NO_READ_WRITE</strong></td><td><code>LOCK TABLES t WRITE</code></td><td>限制其他会话不能读也不能写</td></tr></tbody></table><h4 id="意向锁">意向锁</h4><p>MySQL 的<strong>意向锁</strong>（Intention Lock）是 <strong>InnoDB引擎特有</strong>的一种表级锁，它本身不会阻塞普通的读写，而是用来表示事务即将在哪些行上加行锁，从而<strong>让表锁和行锁能够共存、协调</strong>。</p><p>如果一张表已经被加上了行锁，那么加表锁之前就要<strong>扫描全表</strong>，检查哪些行已经被锁住了，非常低效。有了意向锁，事务在加行锁之前，要先给表加上一个意向锁，表明自己会给哪些行加锁；这样以后加表锁之前只要检查一下意向锁就能快速定位已经加上的行锁，快速判断会不会发生冲突。</p><blockquote><p>意向锁的存在意义就是加速表锁与行锁之间的冲突检测，避免全表扫描。</p></blockquote><p><strong>InnoDB 有两种意向锁（都是表级锁）</strong>：</p><ul><li>意向共享锁（IS, Intention SharedLock）表示事务打算在某些行上加共享锁（S 锁，读锁）。</li><li>意向排他锁（IX, Intention ExclusiveLock）表示事务打算在某些行上加排他锁（X 锁，写锁）。</li></ul><p>行级操作会加行级锁，同时为整张表加上对应的表级意向锁。以后要加别的表级锁之前，直接检查意向锁就可以判断是否冲突了。</p><h2 id="锁的算法">锁的算法</h2><h3 id="行锁的三种算法">行锁的三种算法</h3><p>行锁必须依赖索引才能生效，包括以下三种。无索引查询必须扫描全表。</p><ul><li>Record Lock：单个行记录的锁（锁住索引记录）</li><li>GapLock：间隙锁，锁定一个范围，但是不包含记录本身。防止幻读（防止新数据插入影响当前事务的范围查询结果），只有在RR 隔离级别且锁定读语句或者范围更新、删除才会出现。</li><li>Next-KeyLock：上面两种锁的组合，锁定一个范围，并且锁定记录本身。如果是point类型（只涉及到一个记录），那么该记录前后的间隙都会被锁住。<strong>扫描索引的时候不仅会锁住索引本身，还会锁住这些索引覆盖的范围</strong>，主要作用是防止其他事务在被覆盖的区间内进行插入操作。</li></ul><p>如果<code>Next_key</code>查询的索引含有<strong>唯一</strong>属性（比如是主键），那么会被<strong>降级</strong>为<code>Record Lock</code>，提高应用的并发性。聚集索引可以降级为<code>Record Lock</code>，辅助索引用作<code>Next-Key Lock</code>，锁住更大的区间。举一个例子，看下面这张表：</p><table><thead><tr><th>a</th><th>number</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>4</td></tr><tr><td>4</td><td>4</td></tr><tr><td>6</td><td>6</td></tr></tbody></table><p>其中a是主键，number加了辅助索引。如果执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> number <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>那么number的<code>(1, 6)</code>的范围都会被 Next-key锁住，如果插入的数据落在这个范围内，无法进行插入操作。一个例外是如果查询的是这个区间内的不存在的number（比如<code>5</code>），会马上返回Emptyset，不会阻塞，这是因为根据索引很容易就能发现不存在的记录。，</p><blockquote><p><strong>幻读</strong>指的是在同一事务下，连续执行两次同样的 SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p></blockquote><p>InnoDB存储引擎通过Next_key算法解决了幻读的问题。</p><p>对于范围查询，例如要查询主键<code>a &gt; 2</code>的所有记录，那么会锁住主键<code>[2, +♾️)</code>的整个范围加上X锁。</p><h2 id="锁的问题">锁的问题</h2><h3 id="脏读">脏读</h3><p>脏读指的是在不同的事务下，当前事务可以读到另外事务未提交的数据，也就是脏数据。这违反了事务的隔离性。在<code>READ UNCOMMITED</code>隔离级别下才有可能发生。</p><h3 id="不可重复读">不可重复读</h3><p>含义：在第一个事务内，由于第二个事务的修改，导致两次读到的数据是不一样的。(事务隔离级别为RC)</p><blockquote><p><strong>脏读</strong>是读到未提交的数据，不可重复读读到的是已经提交的数据，但是违反了事务一致性的要求。</p></blockquote><p>不可重复读的后果没有那么严重，在RC隔离级别下是允许的。InnoDB引擎解决的方法是<code>Next-Key Lock</code>算法，<strong>扫描索引的时候不仅会锁住索引本身，还会锁住这些索引覆盖的范围</strong>。避免了在关心的范围内其他事务修改数据造成的不可重复读的问题。</p><h3 id="丢失更新">丢失更新</h3><blockquote><p>丢失更新指的是一个事务的更新会被另一个事务的更新所覆盖,从而导致数据的不一致.</p></blockquote><p>在任何隔离级别下都不会产生丢失更新问题.虽然数据库本身不会出现丢失更新, 但是存在一种逻辑上丢失更新的情况:</p><ol type="1"><li>事务T1查询一行数据,显示给用户u1;</li><li>事务T2也查询这行数据, 并将取得的数据显示给用户u2;</li><li>u1修改这行记录, 更改数据库并提交;</li><li>u2也修改这行记录, 更改数据库并提交.</li></ol><p>结果: <strong>u1的修改操作被u2覆盖.</strong></p><p>解决方法: 换作<code>select .. for update</code>查询, 加上一个<strong>X 锁</strong>, 而不是无锁查询.这样, 事务 T2 必须等待事务 T1的查询和修改动作都结束之后才能开始查询和修改.</p><h2 id="阻塞">阻塞</h2><ul><li><code>innodb_lock_wait_timeout</code>: 控制超时时间.默认50s,可以动态设置</li><li><code>innodb_rollback_on_timeout</code>:用来设定是否在超时时进行回滚, 默认OFF, 静态.</li></ul><p><strong>一般情况下,事务在抛出异常后既不会自动提交,也不会回滚</strong>（死锁除外，自动回滚）,必须由用户<strong>手动决定</strong>. 异常之前做过的操作会被保留.</p><h2 id="死锁">死锁</h2><blockquote><p><strong>死锁</strong>是指两个或者两个以上的事务在执行的过程中,因为争夺锁资源而造成的一种互相等待的现象.</p></blockquote><p>解决方式:</p><ul><li>设置超时, 让互相等待的事务的其中一方回滚. 缺点:回滚事务也要花费时间, 可能回滚花费的时间比执行另一个事务的时间还长.</li><li><code>wait-for graph</code>,译为"等待图",<strong>主动检测死锁</strong>.</li></ul><p>等待图要求数据库保存如下信息:</p><ul><li>锁的信息链表(哪一行有哪些锁在等待)</li><li>事务等待链表</li></ul><p>如下图所示:</p><p><img src="https://s21.ax1x.com/2025/08/10/pVdmK1A.png" /></p><p>规定:<code>t1 -&gt; t2</code>表示事务 t1 在等待 t2持有的某些锁,比如上图中 t1 在等待 t2 对 row1 加的X锁.根据这一规则画出来的图如下:</p><p><img src="https://s21.ax1x.com/2025/08/10/pVdmwXq.png" /></p><p>容易发现 t1 和 t2 存在死锁.</p><blockquote><p>每当有事务请求锁并发生等待时, 都会判断是否有死锁, 如果有就回滚 undo量最小的事务.</p></blockquote><p>死锁的另一个例子:</p><ol type="1"><li>会话 A: <code>SELECT * FROM t WHERE a = 4 FOR UPDATE;</code>获取 a=4这一行记录的X锁, <strong>而且这个锁会一直持续到事务结束</strong>.</li><li>会话 B:<code>SELECT * FROM t WHERE a &lt;= 4 LOCK IN SHARE MODE;</code>想要获取a&lt;=4 的S锁,但是获取失败, 阻塞.</li><li>会话 A: <code>INSERT INTO t VALUES(3);</code>企图获取 X 锁,但是会话B正在等待,所以也阻塞等待.</li></ol><p>分析：</p><ul><li>会话 A：持有a=4的排他锁，等待插入a=3（被会话B阻塞）</li><li>会话 B：等待a=4的共享锁（被会话A阻塞），同时阻塞了a=3位置的操作</li></ul><p>两个会话相互等待对方释放资源，形成了循环等待，数据库检测到死锁后选择回滚其中一个事务（会话A），并返回错误<code>1213</code>。</p><h2 id="锁升级">锁升级</h2><h3 id="innodb管理锁的方式">InnoDB管理锁的方式</h3><p>先说说InnoDB存储引擎是如何管理锁信息的：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">锁信息存储结构：以页为单位存储锁的状态<br><span class="hljs-bullet">- </span>每个数据页维护一个锁位图<br><span class="hljs-bullet">- </span>位图中每一位对应页中的一条记录<br><span class="hljs-bullet">- </span>1表示该记录被锁定，0表示未锁定<br></code></pre></td></tr></table></figure><p><strong>行级锁的管理机制：</strong></p><ol type="1"><li><strong>以行为单位加锁</strong>，锁定具体的一行记录</li><li><strong>以页为单位管理锁信息</strong>，每一页都要维护一个该页的锁状态位图</li><li><strong>位图</strong>方式存储：用位图高效记录哪些行是被加锁了</li></ol><p>表锁采用了另一种独立的锁机制：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">表锁信息存储在：<br><span class="hljs-bullet">- </span>数据字典（Data Dictionary）中<br><span class="hljs-bullet">- </span>表的元数据结构中<br><span class="hljs-bullet">- </span>不依赖页内的位图<br></code></pre></td></tr></table></figure><p>最后，意向锁用于协调表锁和行锁的关系，每次加行锁之前都会先加上意向锁。</p><h3 id="锁升级的概念">锁升级的概念</h3><p>锁升级指的是将锁从细粒度的锁升级成粗细粒度的锁，比如将行锁升级为表锁。锁升级一般用于“锁是一种稀缺资源”的数据库种，比如微软的SQL服务器就认为锁是一种稀缺的对象，会自动升级，减小维护锁需要的额外开销。锁升级有利有弊：</p><ul><li>好处：减小了锁资源占用的内存</li><li>坏处：锁粒度加大，减小了并发性能</li></ul><p>微软SQL为每行记录都产生一个锁对象，资源占用很大。</p><p>InnoDB的行锁是以数据页为单位、用位图管理锁的状态的，资源开销会小得多，所以不存在锁升级的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用-select, poll, epoll的区别</title>
    <link href="/2025/08/10/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <url>/2025/08/10/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ol type="1"><li><a href="#select">select</a><ol type="1"><li><a href="#函数原型">函数原型</a></li><li><a href="#作用">作用</a></li><li><a href="#应用示例">应用示例</a></li></ol></li><li><a href="#poll">poll</a><ol type="1"><li><a href="#函数原型-1">函数原型</a></li><li><a href="#示例代码">示例代码</a></li><li><a href="#与select的区别">与select的区别</a></li></ol></li><li><a href="#epoll">epoll</a><ol type="1"><li><a href="#三个核心系统调用">三个核心系统调用</a></li><li><a href="#示例代码-1">示例代码</a></li><li><ahref="#两种触发模式-事件通知机制">两种触发模式-事件通知机制</a></li><li><a href="#三个函数的区别">三个函数的区别</a></li></ol></li></ol><h2 id="select">select</h2><h3 id="函数原型">函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, </span><br><span class="hljs-params">           fd_set *<span class="hljs-keyword">restrict</span> readfds,  </span><br><span class="hljs-params">           fd_set *<span class="hljs-keyword">restrict</span> writefds,  </span><br><span class="hljs-params">           fd_set *<span class="hljs-keyword">restrict</span> errorfds, </span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval *<span class="hljs-keyword">restrict</span> timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li>在每个集合中都会检查前<code>nfds</code>个文件描述符。<code>select()</code>内部会遍历<code>0 ~ nfds-1</code>之间的<strong>所有</strong>fd（至于需要重点关注哪个，取决于后面传入的fds），所以 nfds必须是<code>所有监听的 fd 中最大值 + 1</code>。</li><li><code>readfds</code>：指定需要监控的可读事件的fd。常用方法有：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">FD_ZERO(&amp;readfds);      <span class="hljs-comment">// 清空集合</span><br>FD_SET(fd, &amp;readfds);   <span class="hljs-comment">// 把 fd 加入集合</span><br></code></pre></td></tr></table></figure><ul><li><code>writefds</code>：指定需要监控可写事件的fd</li><li><code>errorfds</code>：指定需要监控的异常事件的fd</li><li><code>timeout</code>结构体：<code>NULL</code>表示无限等待。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><br>    <span class="hljs-type">long</span> tv_sec;   <span class="hljs-comment">// 秒</span><br>    <span class="hljs-type">long</span> tv_usec;  <span class="hljs-comment">// 微秒（百万分之一秒）</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>用于在<strong>一个线程</strong>中<strong>监听多个文件描述符</strong></li><li>返回值：大于零表示已经准备好的 IO文件描述符的个数；等于零表示超时；-1表示出错</li></ul><h3 id="作用">作用</h3><p><code>select</code><strong>用于同时监控多个文件描述符，可以同时处理多个输入源；当任何一个IO准备就绪的时候，select就会返回，否则一直阻塞，不会浪费CPU。</strong></p><ul><li>优点：只有一个线程，所以不存在并发问题；资源消耗量低，因为避免了为每个IO创建单线程的开销。</li><li>缺点：可传入文件描述符的数量有限制；每次需要遍历所有的文件描述符；不允许阻塞调用，否则这个系统都会被阻塞。而且。每次调用select 都要重新把 fd 集合拷贝到内核中。</li></ul><h3 id="应用示例">应用示例</h3><p>应用示例：监控终端的输入（为简单起见只有一个IO操作）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最简单的select例子：只监控标准输入</span><br><span class="hljs-comment"> * 演示select如何等待输入事件</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一些文字（输入quit退出）：\n&quot;</span>);<br>    <br>    fd_set read_fds;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 1. 清空并设置文件描述符集合</span><br>        FD_ZERO(&amp;read_fds);<br>        FD_SET(STDIN_FILENO, &amp;read_fds);  <span class="hljs-comment">// 只监控标准输入</span><br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;等待输入...\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2. select等待输入事件</span><br>        <span class="hljs-type">int</span> result = select(STDIN_FILENO + <span class="hljs-number">1</span>, &amp;read_fds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 3. 检查标准输入是否有数据</span><br>            <span class="hljs-keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;read_fds)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;检测到输入！\n&quot;</span>);<br>                <br>                <span class="hljs-keyword">if</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入了: %s&quot;</span>, buffer);<br>                    <br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序结束\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">╭─ ~<span class="hljs-string">/Desktop/c-dev</span>          <br>╰─❯ <span class="hljs-string">./main</span><br>请输入一些文字（输入<span class="hljs-keyword">quit</span>退出）：<br>等待输入<span class="hljs-string">...</span><br>我输入了一段文字。<br>等待结束！检测到输入！<br>你输入了: 我输入了一段文字。<br>等待输入<span class="hljs-string">...</span><br>^C<br></code></pre></td></tr></table></figure><p>这个例子说明：</p><ol type="1"><li><code>select(STDIN_FILENO + 1, &amp;read_fds, NULL, NULL, NULL)</code><ul><li>监控标准输入（文件描述符0）</li><li>程序会阻塞在这里，等待用户输入</li></ul></li><li>当用户按下回车键时：<ul><li><code>select</code>检测到有输入数据</li><li>返回值 &gt; 0，表示有事件发生</li><li><code>FD_ISSET</code>检查确认是标准输入有数据</li><li>然后读取并处理数据</li></ul></li><li>如果没有select：<ul><li><code>fgets</code>会直接阻塞地等待输入</li><li>无法同时处理多个输入源</li><li>这就是<code>select</code>的价值所在</li></ul></li></ol><h2 id="poll">poll</h2><p>跟<code>select</code>相比，它的优点是<strong>没有传入文件描述符数量的限制</strong>，<code>select</code>收到<code>FD_SETSIZE</code>的影响，监控的数量是有限的（通常是1024）；而且精简了传入参数的数量，将原来的读文件描述符、写文件描述符、错误文件描述符一律使用<code>pollfd</code>结构体数组来表示。</p><h3 id="函数原型-1">函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>fds</code>：一个<code>struct pollfd</code><strong>数组</strong>，每个元素都描述一个要监视的文件描述符及其事件类型</li><li><code>nfds</code>：数组的元素个数</li><li><code>timeout</code>：等待时间，单位：毫秒，<code>0</code>表示立即返回，<code>-1</code>表示一直阻塞</li></ul><p><code>struct pollfd</code>结构如下，在调用<code>poll()</code>之前应该赋值完毕，而且可以按需直接修改数组中的<code>events</code>属性值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-type">int</span> fd;         <span class="hljs-comment">// 文件描述符</span><br>    <span class="hljs-type">short</span> events;   <span class="hljs-comment">// 关心的事件（输入事件）</span><br>    <span class="hljs-type">short</span> revents;  <span class="hljs-comment">// 实际发生的事件（输出事件）；调用返回后由内核写回该值</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>fd</code>应当传入诸如<code>STDIN_FILENO</code>的文件描述符</li><li><code>events</code>赋值为输入的事件，调用<code>poll()</code>后，<strong>内核</strong>会监视这些fd，直到发生了事件/超时（<code>timeout</code>）/被信号中断</li><li><code>revents</code>：当<code>poll()</code>返回时，<strong>内核</strong>会清空<code>fds[i].revents</code>的值，然后把实际发生事件的值写进去，<strong>读取时要用按位与</strong>：例如<code>fds[i].revent &amp; POLLIN</code>。</li></ul><p>常用事件（<code>events</code>/<code>revents</code>）：</p><ul><li>POLLIN → 数据可读</li><li>POLLOUT → 可以写入数据</li><li>POLLERR → 发生错误</li><li>POLLHUP → 对端关闭连接</li><li>POLLNVAL → 无效的 FD</li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 改写后的poll版本</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== POLL 版本 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一些文字（输入quit退出）：\n&quot;</span>);<br><br>    <span class="hljs-comment">// 定义pollfd结构体数组，只监控一个文件描述符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[1];</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-comment">// 设置要监控的文件描述符和事件</span><br>    fds[<span class="hljs-number">0</span>].fd = STDIN_FILENO; <span class="hljs-comment">// 监控标准输入</span><br>    fds[<span class="hljs-number">0</span>].events = POLLIN; <span class="hljs-comment">// 监控可读事件</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;等待输入...\n&quot;</span>);<br><br>        <span class="hljs-comment">// poll等待输入事件，-1表示无限等待</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;revents at beginning: %d\n&quot;</span>, fds[<span class="hljs-number">0</span>].revents);<br>        <span class="hljs-type">int</span> result = poll(fds, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 检查标准输入是否有数据可读</span><br>            <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">0</span>].revents &amp; POLLIN) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;检测到输入！\n&quot;</span>);<br><br>                <span class="hljs-keyword">if</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入了: %s&quot;</span>, buffer);<br><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;revents at end: %d\n&quot;</span>, fds[<span class="hljs-number">0</span>].revents &amp; POLLIN);<br>            <span class="hljs-comment">// 清除事件标志（可选，因为下次poll会重新设置revents）</span><br>            fds[<span class="hljs-number">0</span>].revents = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序结束\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">╭─ ~/Desktop/c-dev              <br>╰─❯ ./main                 <br><span class="hljs-section">=== POLL 版本 ===</span><br>请输入一些文字（输入quit退出）：<br>等待输入...  <br>测试输入   <br>检测到输入！<br>你输入了: 测试输入<br>revents at end: 1<br>等待输入...<br>revents at beginning: 0<br>^C<br></code></pre></td></tr></table></figure><h3 id="与select的区别">与select的区别</h3><table><thead><tr><th>方面</th><th><code>select</code></th><th><code>poll</code></th></tr></thead><tbody><tr><td>监控对象数</td><td>受 <code>FD_SETSIZE</code> 限制（通常1024）</td><td>理论无限制</td></tr><tr><td>数据结构</td><td><code>fd_set</code>（位图）</td><td><code>struct pollfd</code> 数组</td></tr><tr><td>修改方式</td><td>每次调用前都要重置集合</td><td>可以直接改数组中的 events</td></tr><tr><td>兼容性</td><td>POSIX 标准</td><td>POSIX 标准</td></tr></tbody></table><h2 id="epoll">epoll</h2><p>epoll，它算是 <strong>Linux</strong> 下 I/O 多路复用的“高配版”，比select 和 poll 更高效，尤其适合同时监控大量文件描述符的场景。</p><p><code>select</code>和<code>poll</code>每次调用都要手动传入所有用到的fd（不记录状态），而且返回后又手动逐个检查全部的fd才知道哪个就绪（前者循环检查<code>if (FD_ISSET(指定文件描述符, &amp;read_fds))</code>，后者循环检查<code>if (fds[i].revents &amp; POLLIN)</code>）。<code>epoll</code>对这两点都做了改进，体现在：</p><ol type="1"><li>fd集合可以只注册一次，后面可以<strong>反复调用</strong>（由内核记住），相比之下每次调用<code>select / poll</code>都必须重新传入整个FD集合。</li><li>只返回<strong>已经就绪的fd列表</strong>，不用手动遍历</li><li>支持水平触发（LT）和边缘触发（ET）两种模式</li><li>理论上FD的数量没有限制</li></ol><h3 id="三个核心系统调用">三个核心系统调用</h3><ol type="1"><li><strong>创建 epoll 实例</strong></li></ol><p>两种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-type">int</span> __size); <span class="hljs-comment">// 返回一个 epoll 文件描述符</span><br><span class="hljs-type">int</span> epfd = epoll_create1(<span class="hljs-type">int</span> __flags);<br></code></pre></td></tr></table></figure><ul><li><code>epoll_create</code>返回新 epoll实例的文件描述符，在新版本中<code>size</code>已经被忽略，但是必须大于0。</li><li><code>epoll_create1</code>与<code>epoll_create</code>相同，不过带有<code>FLAGS</code>参数，而且移除了用不上的<code>size</code>参数。</li></ul><ol start="2" type="1"><li><strong>添加/修改/删除 监听的 FD</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>epfd</code>：刚才创建实例返回的epfd</li><li><code>op</code>：三种取值，<code>EPOLL_CTL_ADD</code><code>EPOLL_CTL_MOD</code> <code>EPOLL_CTL_DEL</code></li><li><code>fd</code>：要操作的文件描述符</li><li><code>event</code>：事件的信息</li></ul><ol start="3" type="1"><li><strong>等待事件的发生</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>等待事件发生，返回<strong>就绪的文件描述符数量</strong>。可以看到这里不需要传入监听的事件集合，因为已经保存到内核中了，不需要重新传入。</p><ul><li><code>epfd</code>: epoll实例</li><li><code>events</code>: 用于接收就绪事件的数组</li><li><code>maxevents</code>: 最多返回的事件数</li><li><code>timeout</code>:超时时间（毫秒），-1表示阻塞等待所有事件完成</li></ul><p><code>epoll_event</code>结构体：位于<code>sys/epoll.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">void</span> *ptr;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">uint32_t</span> u32;<br>  <span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint32_t</span> events;<span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;<span class="hljs-comment">/* User data variable 一般用来存fd*/</span> <br>&#125; __EPOLL_PACKED;<br></code></pre></td></tr></table></figure><p>比较常用的有两个：<code>ev.events = EPOLLIN</code>，<code>ev.data.fd = 文件描述符</code>。用于接收就绪事件的数组events的字段<code>events[i].data.fd</code>等于注册时<code>ev.data.fd</code>里放的值，常见做法是放FD 本身，但也可以放别的。</p><h3 id="示例代码-1">示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">simple_epoll_example</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 简单epoll示例：监控标准输入 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入文字（输入quit退出）：\n&quot;</span>);<br><br>    <span class="hljs-comment">// 1. 创建epoll实例</span><br>    <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;epoll_create失败&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 准备要监控的事件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span>                 <span class="hljs-comment">// ev 用于监控可读事件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENTS</span>];</span> <span class="hljs-comment">// events 用于接收就绪事件</span><br><br>    <span class="hljs-comment">// 设置要监控标准输入的读事件</span><br>    ev.events = EPOLLIN;       <span class="hljs-comment">// 监控可读事件</span><br>    ev.data.fd = STDIN_FILENO; <span class="hljs-comment">// 关联的文件描述符</span><br><br>    <span class="hljs-comment">// 3. 将标准输入添加到epoll监控中</span><br>    <span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;ev) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;epoll_ctl失败&quot;</span>);<br>        close(epfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--------------\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;等待输入...\n&quot;</span>);<br><br>        <span class="hljs-comment">// 4. 等待事件发生</span><br>        <span class="hljs-type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;epoll_wait失败&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nfds: %d\n&quot;</span>, nfds);<br><br>        <span class="hljs-comment">// 5. 处理就绪的事件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;检测到输入！\n&quot;</span>);<br><br>                    <span class="hljs-keyword">if</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入了: %s&quot;</span>, buffer);<br><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">goto</span> cleanup;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>cleanup:<br>    close(epfd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序结束\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    simple_epoll_example();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">=== 简单epoll示例：监控标准输入 ===<br>请输入文字（输入quit退出）：<br>--------------<br>等待输入...<br>这是一个句子<br>nfds: <span class="hljs-number">1</span><br>检测到输入！<br>你输入了: 这是一个句子<br>--------------<br>等待输入...<br></code></pre></td></tr></table></figure><h3 id="两种触发模式-事件通知机制">两种触发模式-事件通知机制</h3><ul><li><p>水平触发（LT）：只要有数据就通知。当有数据可读时，会重复多次通知，直到数据处理完成。</p></li><li><p>边缘触发（ET）：只在状态变化时通知一次（比如已经读完-有未读消息），这时只要读过一次，<code>epoll_wait</code>就不会提示还有事件，即使这一次没有读完。</p></li></ul><h3 id="三个函数的区别">三个函数的区别</h3><p>select 模式存在的三个问题</p><ul><li>监听的 FD 最大不超过 1024<br /></li><li>每次 select 都需要把所有要监听的 FD 都拷贝到内核空间<br /></li><li>每次都要遍历所有 FD 来判断就绪状态</li></ul><p>poll 模式的问题</p><ul><li>poll 利用链表解决了 select 中监听 FD 上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll 模式中如何解决这些问题？</p><ul><li>基于 epoll 实例中的<strong>红黑树</strong>保存要监听的FD，理论上无上限，而且增删改查效率都非常高，性能不会随着监听的 FD数量增多而下降<br /></li><li>每个 FD 只需要执行一次 <code>epoll_ctl</code> 添加到红黑树，以后每次<code>epoll_wait</code> 无需传递任何参数，无需重复拷贝 FD到内核空间<br /></li><li>内核会将就绪的 FD 直接拷贝到用户空间的指定位置，用户进程无需遍历所有FD 就能知道就绪的是谁</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-虚拟化CPU知识梳理</title>
    <link href="/2025/08/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96CPU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2025/08/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96CPU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>《操作系统导论》官网：https://pages.cs.wisc.edu/~remzi/OSTEP/</p><p>作业代码下载地址：https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html</p><p>参考解答：https://github.com/xxyzz/ostep-hw</p><h1 id="目录">目录</h1><ol type="1"><li><a href="#全书主要内容一览">全书主要内容一览</a></li><li><a href="#一虚拟化的概念和api">一、虚拟化的概念和API</a><ol type="1"><li><a href="#抽象进程">抽象：进程</a></li><li><a href="#进程api">进程API</a><ol type="1"><li><a href="#fork">fork</a></li><li><a href="#wait">wait</a></li><li><a href="#exec">exec</a></li><li><a href="#应用shell">应用：shell</a></li></ol></li></ol></li><li><a href="#二虚拟化cpu">二、虚拟化CPU</a><ol type="1"><li><ahref="#受限直接执行limited-direct-execution">受限直接执行（limiteddirect execution）</a><ol type="1"><li><a href="#直接运行协议">直接运行协议</a></li><li><a href="#受限的控制权">受限的控制权</a></li><li><a href="#在进程之间切换">在进程之间切换</a><ol type="1"><li><a href="#协作方式">协作方式</a></li><li><a href="#非协作方式">非协作方式</a></li><li><a href="#保存和恢复上下文">保存和恢复上下文</a></li></ol></li></ol></li></ol></li><li><ahref="#三进程调度一单处理器进程调度">三、进程调度（一）单处理器进程调度</a><ol type="1"><li><a href="#最短任务优先sjf">最短任务优先SJF</a></li><li><a href="#最短完成时间优先stcf">最短完成时间优先STCF</a></li><li><a href="#轮转rr">轮转(RR)</a></li><li><a href="#io操作">IO操作</a></li><li><a href="#多级反馈队列mlfq调度">多级反馈队列MLFQ调度</a><ol type="1"><li><a href="#基本规则">基本规则</a></li><li><a href="#优先级调整算法">优先级调整算法</a></li><li><ahref="#饥饿问题自动提升优先级">“饥饿”问题——自动提升优先级</a></li></ol></li><li><a href="#比例份额调度">比例份额调度</a><ol type="1"><li><a href="#基本概念">基本概念</a></li><li><a href="#实现彩票调度算法">实现彩票调度算法</a></li><li><a href="#步长调度算法">步长调度算法</a></li><li><a href="#番外查看cpu具体信息">番外：查看CPU具体信息</a></li></ol></li></ol></li><li><ahref="#四进程调度二多处理器进程调度">四、进程调度（二）多处理器进程调度</a><ol type="1"><li><a href="#多处理器架构">多处理器架构</a></li><li><a href="#单队列多处理器调度sqms">单队列多处理器调度SQMS</a></li><li><a href="#多队列多处理器调度">多队列多处理器调度</a></li><li><a href="#gnulinux采用的策略">GNU/Linux采用的策略</a></li><li><a href="#总结">总结</a></li></ol></li></ol><h1 id="全书主要内容一览">全书主要内容一览</h1><p><strong>虚拟化</strong>：操作系统将物理资源，转换成更通用、更强大更易于使用的形式.</p><ul><li><strong>虚拟化CPU</strong>：就算只有一个处理器，操作系统也能做到有很多CPU在同时运行的“<strong>假象</strong>”(illusion)，让很多程序看似同时运行，这就是所谓的<strong>虚拟化CPU</strong>（virtualizingthe CPU）</li><li><strong>虚拟化内存</strong>：<ul><li>程序将所有数据结构保存在内存中，因此每次读取指令都必须访问内存；</li><li><code>malloc()</code>动态分配一块指定大小的内存，并返回指向这块内存的指针。</li><li>好像每个正在运行的程序都有自己的私有内存，而不是与其他正在运行的程序共享相同的物理内存</li><li>本质：每个进程都在访问自己的<strong>私有虚拟地址空间</strong>，操作系统以某种方式映射到机器的物理内存上，不同进程的内存引用互不影响。]]</li></ul></li><li><strong>并发</strong>, 例如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">// 可能在 common.h 中已经包含了</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// #include &quot;common.h&quot;  // 假设这个头文件定义了 Pthread_create 和 Pthread_join 的包装宏</span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局共享变量，使用 volatile 避免编译器优化</span><br><span class="hljs-type">int</span> loops;<br><br><span class="hljs-comment">// 线程执行函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br>        counter++; <span class="hljs-comment">// 注意：此处存在竞态条件（race condition）</span><br>        <span class="hljs-comment">// sleep(1);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-comment">// 传入的参数即 counter 增加的次数</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: threads &lt;value&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    loops = atoi(argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 将参数转换为整数</span><br>    <span class="hljs-type">pthread_t</span> p1, p2, p3, p4;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initial value : %d\n&quot;</span>, counter);<br><br>    pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p3, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p4, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br><br>    pthread_join(p1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p3, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p4, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Final value   : %d\n&quot;</span>, counter);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>磁盘，另外没有虚拟磁盘一说，磁盘中的信息可以随时共享。而持久化指的是如何把内存中的数据保存到硬盘上</li></ul><h1 id="一虚拟化的概念和api">一、虚拟化的概念和API</h1><h2 id="抽象进程">抽象：进程</h2><ul><li><strong>进程</strong>（process）就是操作系统为正在运行的程序提供的抽象</li><li><strong>地址空间</strong>：进程可以访问的私有内存</li><li><strong>时间片</strong>：操作系统为线程或者进程<strong>分配的CPU执行时间的最小单位</strong><ul><li>时间片太小，则上下文切换开销较大</li><li>时间片太大，则相应变慢，实时性差</li><li>Linux查看时间片大小：<code>cat /proc/sys/kernel/sched_latency_ns</code></li></ul></li><li><strong>时分共享</strong>（timesharing）：操作系统共享资源的最基本的技术之一，资源由一个进程运行一小段时间后切换到另一个进程使用</li><li><strong>空分共享</strong>：比如磁盘，把资源从空间上划分给需要的数据</li></ul><hr /><p><strong>进程API</strong></p><ul><li>创建 create</li><li>销毁 destroy</li><li>等待 wait</li><li>其他控制 miscellaneous control：例如暂停线程然后恢复</li><li>状态 statu</li></ul><p><strong>创建进程的细节</strong></p><ul><li>操作系统从磁盘读取代码和静态数据，加载到内存中该进程的地址空间中，如下图：</li></ul><p><img src="https://s21.ax1x.com/2025/07/22/pVGC8mV.png" /></p><ul><li>采用<strong>惰性加载</strong>，只有程序执行期间用得上的的代码或数据片段，才会被加载</li><li>加载到内存后，操作系统必须先为<strong>运行时栈</strong>分配内存，用于存放局部变量、函数参数和返回地址。</li><li>为<strong>堆</strong>分配内存，显式请求内存的指令（如<code>malloc()</code>）会申请堆中的空间</li><li>还要执行与<strong>IO设置</strong>相关的任务</li></ul><p>最后，启动程序，从<code>main()</code>入口开始执行，OS将CPU的控制权转移到新创建的进程，程序开始运行。</p><p><strong>进程状态</strong></p><ul><li>运行 running：正在执行指令</li><li>就绪 ready</li><li>阻塞 blocked：主动等待资源，</li></ul><p>就绪 -&gt; 运行 称之为被调度（scheduled）;<br />运行 -&gt; 就绪 称之为取消调度（descheduled）</p><p>一个进程被阻塞时，CPU控制权可以交给其他线程，例如</p><figure><img src="https://s21.ax1x.com/2025/07/22/pVGPtDP.png" alt="阻塞" /><figcaption aria-hidden="true">阻塞</figcaption></figure><p>从磁盘读取数据和等待网络数据包就是典型的IO阻塞过程。关于<code>Process1</code>完成后是否立即切换回去，这是一个决策的问题，这里只是举了一个例子。</p><p><strong>上下文切换</strong> (contextswitch)：任务的执行上下文包括寄存器内容、程序计数器、堆栈指针，为了能之后恢复任务的执行状态，系统必须保存当前任务的执行上下文（寄存器内容、程序计数器、堆栈指针等），再加载另一个任务的上下文。进程和线程都有上下文切换，线程切换更快一些。</p><h2 id="进程api">进程API</h2><h3 id="fork">fork</h3><p>fork，英文动词，意为派生。在父进程的基础上派生出来一个新的进程，新的进程的内从空间指向和父进程同一块物理内存，直到某一方试图修改物理内存的数据才会开始复制物理内存</p><p>示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br><br>    <span class="hljs-type">int</span> rc = fork();  <span class="hljs-comment">// 创建一个子进程</span><br><br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// fork 失败</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程执行这里</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 父进程执行这里</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>, rc, (<span class="hljs-type">int</span>) getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>) <br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">parent</span> <span class="hljs-selector-tag">of</span> <span class="hljs-number">29147</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)  <br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">child</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29147</span>) <br></code></pre></td></tr></table></figure><ul><li><code>int rc = fork();</code>这一行<code>fork</code>了一个<strong>子进程</strong>，子进程和父进程几乎完全相同，但是有区别：<ul><li>子进程是从<code>fork()</code>指令以后开始执行的</li><li>子进程获得的<code>rc</code>为<code>0</code></li><li>父进程获得的 <code>rc</code>为子进程的pid</li></ul></li></ul><h3 id="wait">wait</h3><p>可用于父进程等待子进程运行结束。示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>      <span class="hljs-comment">// 标准输入输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>     <span class="hljs-comment">// exit() 函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>     <span class="hljs-comment">// fork()、getpid()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span>   <span class="hljs-comment">// wait()</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>    <span class="hljs-comment">// 打印当前进程的 PID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">int</span> rc = fork();<br><br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// fork 失败</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程执行的代码</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 父进程执行的代码</span><br>        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>, rc, wc, (<span class="hljs-type">int</span>) getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exec">exec</h3><p><code>exec</code>函数的作用是为fork的子进程分配不同于父进程的任务，它有多个实现，下面以<code>execvp</code>为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>      <span class="hljs-comment">// 标准输入输出函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>     <span class="hljs-comment">// exit() 函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>     <span class="hljs-comment">// fork(), execvp(), getpid()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>     <span class="hljs-comment">// strdup()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span>   <span class="hljs-comment">// wait()</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br><br>    <span class="hljs-type">int</span> rc = fork(); <span class="hljs-comment">// 创建子进程</span><br><br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// fork 失败</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程 exec()</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br><br>        <span class="hljs-type">char</span> *myargs[<span class="hljs-number">3</span>];<br>        myargs[<span class="hljs-number">0</span>] = strdup(<span class="hljs-string">&quot;wc&quot;</span>);       <span class="hljs-comment">// 命令名：&quot;wc&quot;（单词计数程序）</span><br>        myargs[<span class="hljs-number">1</span>] = strdup(<span class="hljs-string">&quot;p3.c&quot;</span>);     <span class="hljs-comment">// 参数：文件名 &quot;p3.c&quot;</span><br>        myargs[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;               <span class="hljs-comment">// 参数数组结束标志</span><br><br>        execvp(myargs[<span class="hljs-number">0</span>], myargs);      <span class="hljs-comment">// 执行 wc 命令，统计 p3.c 文件的行/词/字节数</span><br><br>        <span class="hljs-comment">// 如果 execvp 执行失败，才会执行下面这一行</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this shouldn&#x27;t print out\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 父进程执行</span><br>        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>, rc, wc, (<span class="hljs-type">int</span>) getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>给定参数<code>myargs[0], myargs</code>后，直接将当前的子进程替换为给定的运行程序，在这里是<code>wc</code>；子进程在执行该<code>exec()</code>之后，不会返回结果。</p><h3 id="应用shell">应用：shell</h3><p>shell本质上也是一个用户程序，和上面实例中的父进程一样。当我们向shell输入命令的时候，shell会从文件中找到需要的程序，并且<code>fork</code>一个子进程出来，子进程调用<code>exec()</code>来具体地执行我们传入的命令，同时shell也会调用<code>wait</code>等待子进程执行完成。子进程结束以后，shell 会打印返回值并再次输出提示符，提示用户继续输入下一条命令。</p><p>下面的示例代码描述了<strong>输出重定向的实现原理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>      <span class="hljs-comment">// 标准输入输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>     <span class="hljs-comment">// exit()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>     <span class="hljs-comment">// fork(), execvp(), close()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>     <span class="hljs-comment">// strdup()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>      <span class="hljs-comment">// open() 的文件控制选项</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span>   <span class="hljs-comment">// wait()</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>    <span class="hljs-type">int</span> rc = fork(); <span class="hljs-comment">// 创建子进程</span><br><br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// fork 失败</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程：将标准输出重定向到文件</span><br>        close(STDOUT_FILENO); <span class="hljs-comment">// 关闭标准输出（文件描述符1）</span><br>        open(<span class="hljs-string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);<br>        <span class="hljs-comment">// 打开文件作为新的标准输出（文件描述符将是 1）</span><br><br>        <span class="hljs-comment">// 执行 wc 命令，统计 p4.c 文件的行、词、字节数</span><br>        <span class="hljs-type">char</span> *myargs[<span class="hljs-number">3</span>];<br>        myargs[<span class="hljs-number">0</span>] = strdup(<span class="hljs-string">&quot;wc&quot;</span>);     <span class="hljs-comment">// 命令名</span><br>        myargs[<span class="hljs-number">1</span>] = strdup(<span class="hljs-string">&quot;p4.c&quot;</span>);   <span class="hljs-comment">// 参数：文件名</span><br>        myargs[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;             <span class="hljs-comment">// 参数数组结束标志NULL</span><br><br>        execvp(myargs[<span class="hljs-number">0</span>], myargs);   <span class="hljs-comment">// 执行命令</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 父进程：等待子进程完成</span><br>        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码相当于直接在shell输入<code>wc p4.c &gt; ./p4.output</code>，解释：</p><ul><li><code>STDOUT_FILENO</code>是在<code>&lt;unistd.h&gt;</code>中定义的宏常量，数值为0，代表<strong>标准输出</strong>，类似的还有：<ul><li><code>STDIN_FILENO</code>：标准输入，数值 = 1</li><li><code>STDERR_FILENO</code>：标准错误，数值 = 2</li></ul></li><li>运行该程序后，控制台并没有任何输出，实际上父进程先 fork了一个子进程来负责将运行结果重新写入指定的文件<code>./p4.output</code>，并且子进程一上来就关掉了标准输出，而是<code>open</code>目标文件作为新的标准输出，所以shell中看不到任何打印的信息。</li></ul><p>管道符<code>|</code>的实现原理也类似，但是这时候一个进程的输出通过一个管道直接连接到另一个进程的输入，实现无缝连接。</p><h1 id="二虚拟化cpu">二、虚拟化CPU</h1><p>虚拟化CPU存在两个挑战：</p><ul><li>性能，尽可能地提高运行效率</li><li>控制权，防止程序危害系统</li></ul><h2 id="受限直接执行limited-direct-execution">受限直接执行（limiteddirect execution）</h2><p>受限直接执行的目的就是限制程序的权限，因为每个程序都会有需要调用内核权限的情况，比如硬盘IO操作，如果不加以限制，很可能会危害系统。</p><h3 id="直接运行协议">直接运行协议</h3><p>当操作系统希望启动程序时，会做以下步骤：</p><figure><img src="https://s21.ax1x.com/2025/07/23/pVGWVzR.png"alt="简单，但是有问题" /><figcaption aria-hidden="true">简单，但是有问题</figcaption></figure><p>有两个仍待解决的问题：</p><ol type="1"><li>如何控制程序的权限</li><li>如何切换进程，以实现CPU虚拟化</li></ol><h3 id="受限的控制权">受限的控制权</h3><p>硬件层面提供了多种不同的执行模式，具有不同的权限：</p><ul><li><strong>用户模式</strong>(usermode)：用户模式下，程序不能完全访问硬件资源，例如不能发出IO请求</li><li><strong>内核模式</strong>(kernelmode)：操作系统就运行在内核模式，具有最高的权限</li><li>如果用户也需要执行某些特权操作（系统调用）：程序执行<strong>陷阱（trap）指令</strong>，该指令进入内核，<strong>获得内核模式的权限</strong>，完成操作后操作系统调用<strong>从陷阱返回（return-from-trap）指令</strong>，该指令返回到用户程序，回到用户模式</li><li>内核在启动的时候会设置一个叫做<strong>陷阱表</strong>（traptable）的东西，告诉硬件在发生异常的时候需要执行哪些代码，然后硬件就会记住这些位置，于是硬件就会知道发生系统调用和异常时需要跳转到哪些位置</li></ul><p><strong>为什么叫“陷阱”指令</strong>？因为程序需要执行系统调用的时候掉都需要陷入内核中，由内核执行系统调用的工作，然后再浮出来。</p><p>受限的直接运行协议的全过程如图：</p><figure><img src="https://s21.ax1x.com/2025/07/23/pVGWIfJ.png" alt="LDE协议" /><figcaption aria-hidden="true">LDE协议</figcaption></figure><h3 id="在进程之间切换">在进程之间切换</h3><p>关键：进程是在CPU上运行的，控制权在进程手里，想要切换进程，操作系统必须重新拿到CPU的控制权。为了实现进程之间的切换，有两种方式：协作方式和非协作方式。</p><h4 id="协作方式">协作方式</h4><p>这是一种乐观的思路，它假定所有进程都会合理地<strong>主动让出CPU地控制权</strong>。</p><p>唯一的例外是非法操作，如果发生非法操作，这时CPU的控制权也会转移给操作系统，执行非法活动的进程会被操作系统直接终止。</p><p>但是协作方式存在一个<strong>缺陷</strong>：如果某个程序因为自身原因陷入了死循环，既没有执行非法操作也不会让出控制权，怎么办？所以更为通用的是非协作方式：</p><h4 id="非协作方式">非协作方式</h4><p><strong>时钟中断</strong></p><p>硬件功能——时钟中断，可以通过编程控制时钟中断产生的周期。产生中断时，<strong>中断处理程序</strong>（interrupthandler）会被运行，<strong>控制权返还给操作系统</strong>。中断发生时，硬件也要把各种寄存器保存在内核栈，和主动系统调用的情况类似。</p><p>所以说，一旦时钟开始运行，操作系统就不用再担心控制权回不到自己手中了。</p><h4 id="保存和恢复上下文">保存和恢复上下文</h4><p><strong>调度程序：scheduler</strong>，它属于操作系统的一部分。</p><p>调度程序的作用：决定操作系统拿到控制权以后是继续运行当前进程还是切换进程。</p><p>在上下文切换时需要保存原线程的：</p><ul><li>通用寄存器</li><li>程序计数器</li><li>当前进程的内核栈指针</li></ul><p>同时恢复新进程的通用寄存器、程序计数器、新进程的内核指针。</p><hr /><p>A进程切换到B进程的具体过程：</p><ol type="1"><li>时钟中断（或者是别的）操作系统获得CPU的控制权</li><li>将A进程的寄存器保存到A的内核栈</li><li>启用内核模式，跳到陷阱处理程序</li><li>将A的寄存器值保存到A的进程结构，恢复B的进程结构</li><li>从陷阱返回</li><li>从内核栈恢复B的寄存器，进入用户模式，跳到B的程序计数器</li><li>进程B开始运行</li></ol><h1id="三进程调度一单处理器进程调度">三、进程调度（一）单处理器进程调度</h1><h3 id="最短任务优先sjf">最短任务优先SJF</h3><p>Shortest Job First</p><p>这是一种非抢占式的策略，<strong>先运行耗时最短的任务，再运行耗时较长的任务</strong></p><blockquote><p>补充一个概念：<strong>抢占式</strong>，指的是操作系统可以强制中断正在运行的进程或线程，并把CPU 分配给另一个更“合适”的进程或线程。</p></blockquote><h3 id="最短完成时间优先stcf">最短完成时间优先STCF</h3><p>最短完成时间优先（Shortest Time-to-CompletionFirst，<strong>STCF</strong>）或抢占式最短作业优先（Preemptive ShortestJob First ，PSJF）调度程序</p><p>含义：每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间<strong>最少</strong>，然后调度该工作</p><div class="note note-info">            <p><strong>响应时间</strong>定义为从任务到达系统到首次运行的时间，以STCF为例：</p><p><img src="https://s21.ax1x.com/2025/07/24/pVG7pUx.png" /></p><p>A和B的响应时间都是0，C的响应时间是10</p><p><strong>周转时间</strong>则指的是任务从到达，到彻底完成的时间。上面这个例子的总周转时间为120。STCF可以降低周转时间，但是牺牲了响应时间。</p>          </div><p>STCF的响应时间不是很好，为了改善响应时间，提出了<strong>轮转</strong>（Round-Robin）调度。</p><h3 id="轮转rr">轮转(RR)</h3><p>基本含义：<strong>在一个时间片内运行一个任务后马上切换到下一个任务（而不用等待任务结束），这样交替进行</strong>。交替周期是时钟周期的整数倍。</p><figure><img src="https://s21.ax1x.com/2025/07/24/pVG7kxe.png"alt="SJF和轮转的对比，时间片为1s" /><figcaption aria-hidden="true">SJF和轮转的对比，时间片为1s</figcaption></figure><p>时间片的选择：折中，因为</p><ul><li>时间片太短会导致频繁的上下文切换，成本上升</li><li>时间片太长会导致响应时间变慢</li></ul><p>轮转调度对于周转时间很不友好，毕竟轮转的目的正是<strong>均摊</strong>每个任务的时间。轮转是一种<strong>公平</strong>的政策，公平的政策往往要以周转时间为代价，换取响应时间。周转时间和响应时间不可兼得。</p><hr /><p>以上的所有讨论都是建立在<strong>任务没有IO操作</strong>、且<strong>每个任务的运行时间都是已知的</strong>基础上。下面专门来讨论这两个条件：</p><h3 id="io操作">IO操作</h3><ul><li>发起IO指令的程序，在结果返回之前不会执行任何操作，只是<strong>阻塞</strong>地等待任务完成。在此期间CPU应当去执行别的任务以提高执行效率，避免空闲。</li><li>IO完成时会触发<strong>中断</strong>，CPU可以将阻塞的进程转移到就绪状态。</li></ul><p>高效使用CPU的例子：A一共要执行4个IO操作，B是纯粹的CPU密集型任务：</p><p><img src="https://s21.ax1x.com/2025/07/24/pVG7ssJ.png" /></p><p>交替执行可以最大化CPU的利用。</p><h2 id="多级反馈队列mlfq调度">多级反馈队列MLFQ调度</h2><p>多级反馈队列（Multi-level Feedback Queue，MLFQ）</p><p>我们的目标是，在不知道进程的运行时间的情况下，构建出一个良好的调度程序；调度程序在运行时可以学习进程的特征，从而做出更好的决策。<strong>用历史经验预测未来</strong>。</p><h3 id="基本规则">基本规则</h3><ul><li>MLFQ中有很多队列，<strong>每个队列都有不同的优先级</strong>，MLFQ1优先执行高优先级队列中的工作</li><li>同一个队列中的工作采用轮转调度处理</li></ul><p>对CPU占用时间越短的进程，优先级越高；CPU占用时间越长，优先级越低。MLFQ有两条基本规则：</p><blockquote><ol type="1"><li>如果 A 的优先级 &gt; B 的优先级，运行A</li><li>如果 A 的优先级 = B 的优先级，轮转运行 A 和 B</li></ol></blockquote><h3 id="优先级调整算法">优先级调整算法</h3><p>不同的工作主要可以分为两类：</p><ol type="1"><li>运行时间短，频繁放弃CPU的交互型工作，比如键盘输入</li><li>运行时间长，占用CPU时间长，响应时间不重要的计算密集型工作</li></ol><p>优先级调整算法：</p><blockquote><p>工作初次进入系统，先把它放到最高优先级队列： -每当分给工作的整个时间片被用完，就降低它的优先级 -每当在时间片内就释放了CPU，那么保持当前优先级不变</p></blockquote><p>这样一来，CPU计算密集型工作的优先级会逐次递减，直至最低优先级。如果此时来了一个交互型工作，因为初始优先级是最高的，所以优先执行交互型工作，并且很快就执行完毕。可见，<strong>MLFQ具有SJF 的优点</strong>。</p><p>混合IO工作也是同理，CPU占用时间较短所以一直维持在高优先级，一旦执行IO让出CPU就会把控制权交给低优先级的计算密集型工作，循环往复。</p><p><img src="https://s21.ax1x.com/2025/07/24/pVGbu38.png" /></p><h3 id="饥饿问题自动提升优先级">“饥饿”问题——自动提升优先级</h3><p>交互型工作太多的情况下，会持续占用CPU，不给低优先级任务运行的机会，称之为<strong>饥饿</strong>；另一方面，如果某些进程使点小花招，比如在自己的时间片快用完之前主动调用IO操作，这样就能一直维持自己的高优先级，即使自己其实是长时间的任务。以上种种均表明，目前的MLFQ 算法仍然是有缺陷的。</p><p>首先，为了防止饥饿现象：</p><blockquote><ul><li>每经过一段时间 S，就把系统中的所有工作重新加入最高优先级队列</li></ul></blockquote><p>缺陷：S的值不好把控。</p><p>其次，防止程序耍花招的方式：</p><blockquote><p>一旦任务用完了在<strong>某一层</strong>中被分配的时间（不管中途放弃了多少次控制权），就降低它的优先级</p></blockquote><p>实际上，大多数MLFQ都支持不同队列具有不同的时间片长度。有的采用时分调度程序，也有的采用数学公式调整优先级。</p><h2 id="比例份额调度">比例份额调度</h2><p>比例份额（proportional-share）是一种不同于MLFQ的调度程序，也被称为公平份额（fair-share）。目标：<strong>确保每个工作都能获得一定比例的CPU时间</strong>。比例份额算法在容易确定比例的情况下比较实用。</p><h3 id="基本概念">基本概念</h3><p>每个进程持有一定数量的“彩票(ticket)”，比如进程A持有1到75，B进程持有76到100，那么调度程序不断定时地抽取数字，数字位于哪个范围就执行哪个进程。</p><h3 id="实现彩票调度算法">实现彩票调度算法</h3><p>只需要这几样东西：</p><ul><li>随机数生成器</li><li>单向链表，用于记录所有的进程</li><li>票的总数</li></ul><p>每个进程（或称作任务/job）都有一个<code>tickets</code>字段，代表它拥有的“彩票票数”。系统会从0到总票数之间随机抽取一个“中奖号”。然后遍历所有进程的票数，累计票数，当累计值超过中奖号时，当前进程即为“中奖者”，获得CPU 使用权。</p><h3 id="步长调度算法">步长调度算法</h3><p>假如A、B、C的票数分别为100、50、250，用一个大数1000作为总行程，为了确保A、B、C的运行时间维持为2:1:5，取步长分别为10，20，4。每个调度周期，如果发现某个进程的行程比较小，下一次就运行这个行程，使得所有进程的行程始终相同。</p><p><strong>步长调度算法的目的是尽可能是的所有进程的运行时间调整为预期的比例。步长调度依赖于全局状态，不适合处理新加入的进程。</strong></p><h3 id="番外查看cpu具体信息">番外：查看CPU具体信息</h3><p>迄今为止已经学了一堆关于CPU虚拟化和内存虚拟化的理论，下面就来看看真实存在的例子。</p><p>在 GNU/Linux系统中使用<code>lscpu</code>命令可以直接查看CPU的具体信息，以我自己的4核8线程R5 3500U 为例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">╰─❯ lscpu<br>架构：                       x86_64<br>  CPU 运行模式：             <span class="hljs-number">32</span>-<span class="hljs-keyword">bit, </span><span class="hljs-number">64</span>-<span class="hljs-keyword">bit</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">Address </span>sizes:             <span class="hljs-number">43</span> <span class="hljs-keyword">bits </span>physical, <span class="hljs-number">48</span> <span class="hljs-keyword">bits </span>virtual<br>  字节序：                   Little Endian<br><span class="hljs-symbol">CPU:</span>                         <span class="hljs-number">8</span><br>  在线 CPU 列表：            <span class="hljs-number">0</span><span class="hljs-number">-7</span><br>厂商 ID：                    AuthenticAMD<br>  型号名称：                 AMD Ryzen <span class="hljs-number">5</span> <span class="hljs-number">3500</span>U with Radeon Vega Mobile Gfx<br>    CPU 系列：               <span class="hljs-number">23</span><br>    型号：                   <span class="hljs-number">24</span><br>    每个核的线程数：          <span class="hljs-number">2</span><br>    每个座的核数：            <span class="hljs-number">4</span><br>    座：                     <span class="hljs-number">1</span><br>    步进：                   <span class="hljs-number">1</span><br>    Frequency <span class="hljs-keyword">boost: </span>       启用<br>    CPU(s) <span class="hljs-keyword">scaling </span>MHz:     <span class="hljs-number">80</span>%<br>    CPU 最大 MHz：           <span class="hljs-number">2100</span>.<span class="hljs-number">0000</span><br>    CPU 最小 MHz：           <span class="hljs-number">1400</span>.<span class="hljs-number">0000</span><br>    <span class="hljs-keyword">BogoMIPS： </span>              <span class="hljs-number">4192</span>.<span class="hljs-number">15</span><br>    标记：                   fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca c<br>                             mov pat pse36 clflush mmx fxsr sse sse2 ht <span class="hljs-keyword">syscall </span>nx mmxe<br>                             xt fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good <span class="hljs-keyword">nopl </span>n<br>                             onstop_tsc cpuid <span class="hljs-keyword">extd_apicid </span>aperfmperf rapl pni pclmulqdq<br>                              monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsa<br>                             ve avx f16c rdrand lahf_lm cmp_legacy svm <span class="hljs-keyword">extapic </span>cr8_lega<br>                             cy abm sse4a misalignsse <span class="hljs-number">3</span>dnowprefetch osvw skinit wdt tce<br>                              topoext perfctr_core perfctr_nb <span class="hljs-keyword">bpext </span>perfctr_llc mwaitx <br>                             cpb hw_pstate ssbd ibpb vmmcall fsgsbase <span class="hljs-keyword">bmi1 </span>avx2 smep <span class="hljs-keyword">bm</span><br><span class="hljs-keyword"></span>                             i2 rdseed adx smap clflushopt <span class="hljs-keyword">sha_ni </span>xsaveopt xsavec xgetb<br>                             <span class="hljs-built_in">v1</span> <span class="hljs-keyword">clzero </span>xsaveerptr arat npt <span class="hljs-keyword">lbrv </span>svm_lock nrip_save tsc_<br>                             <span class="hljs-keyword">scale </span>vmcb_clean flushbyasid decodeassists <span class="hljs-keyword">pausefilter </span>pft<br>                             hreshold avic v_vmsave_vmload vgif overflow_recov succor s<br>                             mca sev sev_es<br>Virtualization features:     <br>  虚拟化：                   AMD-V<br><span class="hljs-keyword">Caches </span>(sum of all):         <br><span class="hljs-symbol">  L1d:</span>                       <span class="hljs-number">128</span> KiB (<span class="hljs-number">4</span> <span class="hljs-keyword">instances)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">  L1i:</span>                       <span class="hljs-number">256</span> KiB (<span class="hljs-number">4</span> <span class="hljs-keyword">instances)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">  L2:</span>                        <span class="hljs-number">2</span> MiB (<span class="hljs-number">4</span> <span class="hljs-keyword">instances)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">  L3:</span>                        <span class="hljs-number">4</span> MiB (<span class="hljs-number">1</span> <span class="hljs-keyword">instance)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">NUMA:</span>                        <br>  NUMA 节点：                <span class="hljs-number">1</span><br>  NUMA 节点<span class="hljs-number">0</span> CPU：           <span class="hljs-number">0</span><span class="hljs-number">-7</span><br><span class="hljs-symbol">Vulnerabilities:</span>             <br>  Gather data sampling:      Not affected<br><span class="hljs-symbol">  Ghostwrite:</span>                Not affected<br>  Indirect target selection: Not affected<br>  Itlb <span class="hljs-keyword">multihit: </span>            Not affected<br><span class="hljs-symbol">  L1tf:</span>                      Not affected<br><span class="hljs-symbol">  Mds:</span>                       Not affected<br><span class="hljs-symbol">  Meltdown:</span>                  Not affected<br>  Mmio stale data:           Not affected<br>  Reg file data sampling:    Not affected<br><span class="hljs-symbol">  Retbleed:</span>                  Mitigation<span class="hljs-comment">; untrained return thunk; SMT vulnerable</span><br>  Spec rstack overflow:      Mitigation<span class="hljs-comment">; Safe RET</span><br>  Spec store <span class="hljs-keyword">bypass: </span>        Mitigation<span class="hljs-comment">; Speculative Store Bypass disabled via prctl</span><br>  Spectre <span class="hljs-built_in">v1</span>:                Mitigation<span class="hljs-comment">; usercopy/swapgs barriers and __user pointer sa</span><br>                             nitization<br>  Spectre v2:                Mitigation<span class="hljs-comment">; Retpolines; IBPB conditional; STIBP disabled; </span><br>                             RSB filling<span class="hljs-comment">; PBRSB-eIBRS Not affected; BHI Not affected</span><br><span class="hljs-symbol">  Srbds:</span>                     Not affected<br><span class="hljs-symbol">  Tsa:</span>                       Not affected<br>  Tsx async abort:           Not affected<br></code></pre></td></tr></table></figure><ul><li><code>AMD-V</code>表示这颗CPU支持虚拟化技术，可以运行虚拟机</li><li><code>L1d</code>是数据缓存，每个核心32KB，共128KB，每个核心都有独立的数据缓存</li><li><code>L1i</code>是指令缓存，同样每个核心都有独立的指令缓存</li><li><code>L2</code>是二级缓存，速度略慢于L1，但是更大，每个核私有</li><li><code>L3</code>是三级缓存，所有核心共享</li></ul><h1id="四进程调度二多处理器进程调度">四、进程调度（二）多处理器进程调度</h1><h2 id="多处理器架构">多处理器架构</h2><p>多CPU和单CPU的主要区别在<strong>对硬件缓存的应用</strong>。</p><p>首先，缓存之所以有用，是因为<strong>局部性（locality）原理</strong>：</p><ul><li><strong>时间局部性</strong>：当一个数据被访问后，它很有可能在不久的将来再次被访问。</li><li><strong>空间局部性</strong>：当程序访问地址 x的数据后，很可能会紧接着访问 x 附近的数据。（比如：遍历数组）</li></ul><p><img src="https://s21.ax1x.com/2025/07/24/pVGXMin.png" /></p><p>在单CPU的架构下，如果缓存未命中，只需要把从内存读到的数据存入CPU缓存；但是在多CPU架构下，不同CPU的缓存共享一个内存区域，会发生<strong>缓存一致性问题</strong>（cachecoherence）：一个CPU修改内存中的某个值后，另一个CPU并不知情，仍然从自己的缓存中读取旧值。硬件的解决方案是通过一条<strong>总线</strong>让缓存监控内存的访问，如果内存的值被修改，马上更新自己缓存的数据。</p><p>在多个CPU并发访问共享的数据时，需要使用锁才能保证数据的一致性（无锁数据结构较少使用）</p><p><strong>缓存亲和度</strong>（cacheaffinity）：P88，指的是不同CPU上如果缓存的情况不同，运行速度也不一样，已经有对应缓存的CPU运行速度会快得多。</p><h2 id="单队列多处理器调度sqms">单队列多处理器调度SQMS</h2><figure><img src="https://s21.ax1x.com/2025/07/24/pVGj3tA.png"alt="SQMS示意图" /><figcaption aria-hidden="true">SQMS示意图</figcaption></figure><p><code>Single Queue Multiprocessor Scheduling，SQMS</code></p><p>将所有需要调度的工作放入一个单独的队列中，每次由一个CPU取出一个任务。</p><ul><li>优点：负载均衡较好，容易构建</li><li>缺点：1. 加锁的开销较大，扩展性差，CPU核越多效率越低2.不同的进程不断在不同的CPU上转移，缓存的亲和性较差</li></ul><h2 id="多队列多处理器调度">多队列多处理器调度</h2><p><img src="https://s21.ax1x.com/2025/07/24/pVGj8fI.png" /></p><p>每个CPU都有一个任务队列，不同CPU的调度之间相互独立。除此之外，通过迁移技术，把工作分配给空闲的CPU；或者通过工作窃取，让工作量较少的CPU偷看其他CPU的工作情况，拿到工作。但是检查间隔如何选取又是一个问题。</p><h2 id="gnulinux采用的策略">GNU/Linux采用的策略</h2><ul><li><strong>O(1)调度程序</strong>：多队列，基于优先级。类似于MLFQ</li><li><strong>完全公平调度程序（CFS）</strong>：多队列、比例调度</li><li><strong>BF调度程序（BFS）</strong>：单队列、比例调度</li></ul><p>这里可以参考：</p><p>[M11]“Towards Transparent CPU Scheduling”Joseph T. Meehean<br />Doctoral Dissertation at University of Wisconsin—Madison, 2011</p><p>GNU/Linux系统查看指定进程的调度策略的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chrt -p &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>调度策略一览：</p><table><thead><tr><th>策略名</th><th>参数值</th><th>简介</th></tr></thead><tbody><tr><td>SCHED_OTHER</td><td>0</td><td>普通时间共享策略（默认）</td></tr><tr><td>SCHED_FIFO</td><td>1</td><td>先进先出实时策略</td></tr><tr><td>SCHED_RR</td><td>2</td><td>实时轮转调度策略</td></tr><tr><td>SCHED_BATCH</td><td>3</td><td>批处理策略</td></tr><tr><td>SCHED_IDLE</td><td>5</td><td>空闲任务调度（最低优先级）</td></tr><tr><td>SCHED_DEADLINE</td><td>6</td><td>Deadline 策略（用于确定性需求场景）</td></tr></tbody></table><p>测试一下：</p><p><img src="https://s21.ax1x.com/2025/07/24/pVJp9Ig.png" /></p><h2 id="总结">总结</h2><ul><li>单队列多处理器调度：负载均衡性较好，但是因为加锁，扩展性差，因为进程频繁在多个CPU切换，缓存亲和度差</li><li>多队列多处理器调度：扩展性和缓存亲和度好，但是负载均衡性较差</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存机制梳理</title>
    <link href="/2025/08/06/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86/"/>
    <url>/2025/08/06/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="get和post">GET和POST</h2><p><strong>GET：从服务器获取指定的资源，请求的参数一般写在URL中</strong>。</p><p><strong>POST是根据请求体的内容对指定的资源做出处理</strong>。POST请求携带数据的位置一般是写在请求体中，json格式比较常见。</p><p>HTTP协议中的<strong>安全</strong>和<strong>幂等</strong>：</p><ul><li>安全 指的是请求方法不会破坏服务器上的资源</li><li>幂等 指的是多次执行相同的操作，结果都是相同的。</li></ul><p>结论：</p><ol type="1"><li>GET请求是安全且幂等的，因为它不会对服务器上的数据动手脚，每次返回的结果都相同。正因如此，GET请求返回的响应是可以被缓存的，浏览器基本都有这个功能，而且浏览器还可以吧GET请求保存为书签。</li><li>POST可能会修改服务器上的资源，所以不安全；多次提交就会多次修改资源，结果不一样，所以不幂等。所以浏览器既不会把POST请求缓存，也不会保存为书签。</li></ol><p>GET请求也是可以带请求体的。RFC规范定义的GET请求时获取资源，从这个意思上讲它不需要请求体，但也没有规定说禁止使用请求体。</p><h2 id="etag">ETag</h2><p>HTTP首部字段 ETag能告知客户端实体标识，它是一种可以将资源以字符串形式唯一性标识的方式。服务器会为每一份资源分配对应的ETag 值。当资源更新时，ETag 也需要更新。生成ETag时，没有统一的算法规则，而仅仅是由服务器来分配。</p><h2 id="http缓存">HTTP缓存</h2><p>HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。</p><p>当响应可复用时，源服务器不需要处理请求——因为它不需要解析和路由请求、根据cookie恢复会话、查询数据库以获取结果或渲染模板引擎。<strong>这减少了服务器上的负载</strong>。</p><p>有两种不同类型的缓存：<strong>私有缓存和共享缓存</strong>。</p><h3 id="强制缓存">强制缓存</h3><blockquote><p>强制缓存，只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，也就是说是否使用缓存的决定权在浏览器身上。</p></blockquote><p>强制缓存启用时，服务器返回的状态码仍然是<code>200</code>，但是后面会加个括号，例如<code>200 OK (从磁盘缓存)</code></p><h4 id="cache-control">Cache-Control</h4><p>浏览器缓存的一个例子（来自对某个背景图片的GET请求的响应标头）</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">14400</span><br></code></pre></td></tr></table></figure><p>意思是这个资源可以被缓存，并且最大存活时间是14400秒，即四个小时。四个小时以内访问这个资源，浏览器都会直接从缓存中读取，不会访问服务器。超过4 小时后，再访问这个资源，就会重新请求服务器以确认是否有更新。</p><p><code>Cache-Control: max-age</code>的值是由后端开发者或运维根据资源的变化频率和使用场景<strong>手动设定</strong>的，不同类型的资源设定不同，目的是在“节省带宽”与“数据新鲜度”之间取得平衡。<strong>服务器本身并不会“自动判断”资源是否应该缓存，这是人为配置出来的行为</strong>。开发者可以在后端代码里显式指定服务器应当采取的配置。</p><p>静态资源如背景图片、CSS、JS等变化较少，可以长时间缓存。JSON则根据业务需求确定。</p><p>还有一个比较古老的字段：<code>Expire</code>。它指定资源失效的<strong>绝对时间</strong>，但有一个问题：到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致缓存命中的误差。<strong>在HTTP 1.1 的版本，Expires 被 Cache-Control 替代</strong>。</p><blockquote><p>Q:还有个问题，如果某张图片的响应标头的Cache-Control的值设置的是4小时，但是在它过期之前，服务器修改了这张背景图片，那么客户端必须等到过期时间到来才会受到通知吗？</p><p>A:是这样的，设置了<code>Cache-Control: max-age=14400</code>后，客户端在 4小时内会直接使用本地缓存，不会向服务器发送请求，也就无法感知到服务器资源的变化。这是强缓存的代价之一。</p></blockquote><h4 id="cache-control的执行流程">Cache-Control的执行流程</h4><ol type="1"><li>浏览器第一次请求访问服务器上的资源，服务器根据配置，在返回资源的同时在响应标头加上<code>Cache-Control</code>，设置过期时间的大小</li><li>浏览器再次访问这个资源，浏览器会先根据自己上次请求的时间和过期时间进行比较，如果还没过期，就不请求了。</li><li>服务器再次受到请求后，会更新响应标头的字段。</li></ol><h3 id="共享缓存">共享缓存</h3><p>共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为代理缓存和托管缓存。</p><p>共享cache主要用在一些<strong>web代理</strong>上，比如web代理服务器，因为web代理服务器可能会为众多的用户提供资源服务，对于这些用户共同访问的资源就不必要每个用户保存一份了，只需要在web代理服务器中保存一份即可，这样可以减少资源的无效拷贝。</p><h3 id="协商缓存">协商缓存</h3><p>省流：</p><blockquote><p>HTTP 协商缓存是通过 ETag 和 Last-Modified机制实现的。每次请求需要让服务器判断一下资源是否更新过，服务器根据资源是否修改来决定返回304 Not Modified还是新内容，从而决定客户端浏览器是否使用缓存。它比强缓存更灵活，能确保资源最新状态，但性能略差于强缓存。</p></blockquote><p>也叫对比缓存。与强制缓存相比，这次是服务器负责判断缓存的资源有没有过期，如果返回304说明没有过期。</p><p>协商缓存的两个主要机制：</p><table><thead><tr><th>机制</th><th>请求头（浏览器）</th><th>响应头（服务器）</th></tr></thead><tbody><tr><td><strong>Last-Modified</strong></td><td><code>If-Modified-Since</code></td><td><code>Last-Modified</code></td></tr><tr><td><strong>ETag</strong></td><td><code>If-None-Match</code></td><td><code>ETag</code></td></tr></tbody></table><p>图解如下：</p><figure><img src="https://s21.ax1x.com/2025/08/06/pVUHqoQ.jpg"alt="if-None-Match" /><figcaption aria-hidden="true">if-None-Match</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/08/06/pVUHOij.jpg"alt="if-Modified-Since" /><figcaption aria-hidden="true">if-Modified-Since</figcaption></figure><ol type="1"><li><strong>第一次请求资源</strong></li></ol><p>如果服务器的响应头返回</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Last</span>-Modified: Tue, <span class="hljs-number">03</span> Jun <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT<br><span class="hljs-attribute">ETag</span>: <span class="hljs-string">&quot;v1.23abc&quot;</span><br><span class="hljs-attribute">Cache</span>-Control: no-cache<br></code></pre></td></tr></table></figure><p>就说明不允许使用强制缓存，但是可以协商缓存。</p><p><code>Last-Modified</code>表示这个资源的最后修改时间;<code>ETag</code>告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）</p><ol start="2" type="1"><li><strong>再次请求资源</strong></li></ol><p>请求头：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">If</span>-Modified-Since: Tue, <span class="hljs-number">03</span> Jun <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT<br><span class="hljs-attribute">If</span>-None-Match: <span class="hljs-string">&quot;v1.23abc&quot;</span><br></code></pre></td></tr></table></figure><p>如果资源没有发生变化，服务器返回</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">304</span> Not Modified<br></code></pre></td></tr></table></figure><ul><li><p><code>If-Modified-Since</code>是浏览器在询问服务端资源是否过期，后面紧跟的日期是客户端上次从服务器那里收到的最后修改日期。</p></li><li><p><code>If-None-Match</code>发出去的值就是上次从服务器收到的值。服务器会比较请求资源的现在的<code>Etag</code>的值和客户端发过来的值是否相同，不一致说明这个资源已经被修改过了，那么就返回最新资源，状态码200.如果没有被修改过，返回304。</p></li></ul><p>实际项目中两种方式常常同时使用。ETag-<code>If-None-Match</code>的实现方式更优越：</p><ul><li>文件内容没有发生更改的情况下，最后修改时间也可能改变，造成误判；</li><li><code>Last-Modified</code>方式精确到秒，如果需要资源在一秒内刷新多次，只有<code>ETag</code>能做到</li><li>有的服务器不能精确获取文件的最后修改时间</li></ul><p>如果通过<code>ETag</code>已经判断过，就<strong>不会</strong>再使用<code>Last-Modified</code>。</p><p><a href="https://imgse.com/i/pVCros1"><imgsrc="https://s21.ax1x.com/2025/06/03/pVCros1.png"alt="pVCros1.png" /></a></p><p><strong>注意：协商缓存只有在强制缓存过期/未启用的情况下才会被采用</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-Unix风格文件系统知识梳理</title>
    <link href="/2025/07/31/Unix%E9%A3%8E%E6%A0%BC%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2025/07/31/Unix%E9%A3%8E%E6%A0%BC%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Unix风格文件系统总结，本文的所有命令均在Linux上运行过。</p><p>最近学到这一块的时候找不到质量很高的相关文章，干脆自己总结一下好了。</p><ol type="1"><li><a href="#目录directory">目录（directory）</a><ol type="1"><li><a href="#简介">简介</a></li><li><a href="#存储位置">存储位置</a></li></ol></li><li><a href="#文件的元数据">文件的元数据</a></li><li><a href="#文件描述符">文件描述符</a><ol type="1"><li><a href="#什么是文件描述符">什么是文件描述符</a></li><li><a href="#如何分配">如何分配？</a></li><li><a href="#通过终端查看文件描述符">通过终端查看文件描述符</a></li></ol></li><li><a href="#inode">⭐inode⭐</a><ol type="1"><li><a href="#什么是inode">什么是inode</a></li><li><a href="#什么是inode-number">什么是inode number</a></li><li><a href="#inode和数据块的关系">inode和数据块的关系</a></li><li><a href="#inode节点的大小">inode节点的大小</a></li><li><a href="#inode编号和文件名的关系">inode编号和文件名的关系</a></li></ol></li><li><a href="#创建文件-link">创建文件-link</a><ol type="1"><li><a href="#硬链接">硬链接</a></li><li><a href="#软链接">软链接</a></li></ol></li><li><ahref="#文件描述符文件表和inode表的关系">文件描述符、文件表和inode表的关系</a></li><li><a href="#读写磁盘">读写磁盘</a><ol type="1"><li><a href="#读取文件无缓存">读取文件（无缓存）</a></li><li><a href="#写入文件无缓冲">写入文件（无缓冲）</a></li><li><a href="#cahe-and-buffering">cahe and buffering</a></li></ol></li><li><a href="#崩溃一致性">崩溃一致性</a><ol type="1"><li><a href="#问题提出">问题提出</a></li><li><a href="#解决方法">解决方法</a></li></ol></li><li><a href="#参考链接">参考链接</a></li></ol><h2 id="目录directory">目录（directory）</h2><h3 id="简介">简介</h3><p>目录是用于描述文件系统信息的数据结构。目录文件的结构非常简单，就是一系列目录项的列表。每个目录项，由两部分组成：<code>文件名 -&gt; inode number</code>。</p><p><strong>只有拿到目录的<code>inode</code>节点，才能访问它的目录项</strong>。（后面会说inode）</p><p>每个目录都有两个固有的隐藏的条目：<code>.</code>和<code>..</code>，前者指向自己，后者指向上一级目录。使用<code>ll -a</code>可以查看隐藏目录，例如：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">╭─ ~/Desktop/c-dev                   <br>╰─❯ ll -a<br>总计 56K<br>drwxr-xr-x<span class="hljs-number"> 1 </span>kznleaf kznleaf <span class="hljs-number"> 278 </span> 7月30日 11:12 .<br>drwxr-xr-x<span class="hljs-number"> 1 </span>kznleaf kznleaf <span class="hljs-number"> 262 </span> 7月25日 19:56 ..<br>drwxr-xr-x<span class="hljs-number"> 1 </span>kznleaf kznleaf <span class="hljs-number"> 128 </span> 7月28日 22:43 Lock<br>drwxr-xr-x<span class="hljs-number"> 1 </span>kznleaf kznleaf <span class="hljs-number"> 110 </span> 7月27日 12:03 .vscode<br>-rw-r--r--<span class="hljs-number"> 1 </span>kznleaf kznleaf  <span class="hljs-number"> 20 </span> 7月23日 17:48 .clang-format<br>-rw-r--r--<span class="hljs-number"> 1 </span>kznleaf kznleaf <span class="hljs-number"> 778 </span> 7月23日 19:09 home1.c<br>-rw-r--r--<span class="hljs-number"> 1 </span>kznleaf kznleaf  <span class="hljs-number"> 79 </span> 7月23日 19:19 home2.c<br></code></pre></td></tr></table></figure><p>其中<code>.</code> <code>..</code><code>.vscode</code>都属于隐藏目录。</p><h3 id="存储位置">存储位置</h3><p><strong>目录可以被视为一种特殊的文件类型</strong>，只不过保存的不是字节数组，而是一系列目录项。因此存储位置和一般的文件没有区别（从上面命令的输出结果也可以看出来，目录和文件的地位是相同的）。字母<code>d</code>代表目录类型，例如<code>drwxr-xr-x</code>；其余两种文件类型分别是<code>-</code>（普通文件）和<code>l</code>（符号链接）。</p><h2 id="文件的元数据">文件的元数据</h2><p>描述文件本身的信息被称为<strong>元数据</strong>，在Linux系统下使用<code>stat</code>可以获取文件的元数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─❯ <span class="hljs-built_in">stat</span> test.lua               <br>  文件：test.lua<br>  大小：20              块：8          IO 块大小：4096   一般文件<br>设备：0,37      Inode: 111926      硬链接：1<br>权限：(0644/-rw-r--r--)  Uid: ( 1000/ kznleaf)   Gid: ( 1000/ kznleaf)<br>访问时间：2025-07-30 11:06:21.136822528 +0800<br>修改时间：2025-07-27 12:02:15.742179634 +0800<br>变更时间：2025-07-27 12:02:15.742179634 +0800<br>创建时间：2025-07-27 12:01:52.866903170 +0800<br></code></pre></td></tr></table></figure><h2 id="文件描述符">文件描述符</h2><h3 id="什么是文件描述符">什么是文件描述符</h3><p>以程序发起 IO 系统调用为例来说明：</p><p>IO 操作往往需要获取系统权限，比如硬盘 IO操作，必须发起系统调用、交给内核，让内核负责完成能保证安全（如果直接交给进程去干的话，恶意程序就可以清空你的硬盘而不会受到任何阻拦）。那么内核怎么知道进程想要访问的是哪个文件？靠的就是文件描述符。每一个文件描述符都相当于一个系统调用的“权限”，或者说“句柄”，拿到这个句柄就可以执行相应的操作了。</p><p>更具体的信息：</p><ul><li>英文：file descriptor (<strong>FD</strong>, less frequently fildes)译名：文件描述符</li><li>取值范围：有效的FD是一个非负整数，负数一般表示不存在或者error。</li><li>文件描述符 是 POSIX API 的一部分。除了守护进程之外的每个 Unix进程都默认打开三个标准 POSIX文件描述符：标准输入(0)、标准输出(1)、标准错误(2)。</li></ul><h3 id="如何分配">如何分配？</h3><p>每次执行<strong>IO操作</strong>，操作系统会<strong>从当前进程的文件描述符表中找最小的可用描述符编号</strong>作为返回值，例如下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-type">int</span> fd2 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-type">int</span> fd3 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件描述符: %d, %d, %d\n&quot;</span>, fd1, fd2, fd3); <br>    <span class="hljs-comment">//close(fd);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Linux下运行，每一次的输出都是<code>文件描述符：3, 4, 5</code>，之所以从3 开始是因为0、1、2被三个默认的文件描述符占用了。后续每次调用<code>open</code>，都会分配一个描述符。</p><p>值得一提的是，一旦某个系统调用被关闭，那么它占用的文件描述符也会被一并归还。测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;first: %d\n&quot;</span>, fd1);<br>    close(fd1);<br>    <span class="hljs-type">int</span> fd2 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;second: %d\n&quot;</span>, fd2);<br>    close(fd2);<br>    <span class="hljs-type">int</span> fd3 = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;third: %d\n&quot;</span>, fd3);<br>    close(fd3);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件描述符: %d, %d, %d\n&quot;</span>, fd1, fd2, fd3);<br>    <span class="hljs-comment">// close(fd);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid: %d\n&quot;</span>, getpid());<br>    <span class="hljs-comment">// sleep(10);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">╭─ ~/Desktop<span class="hljs-keyword">/c-dev/</span>Lock                          <br>╰─❯ ./main                     <br><span class="hljs-symbol">first:</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">second:</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">third:</span> <span class="hljs-number">3</span><br>文件描述符: <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-symbol">pid:</span> <span class="hljs-number">5323</span><br></code></pre></td></tr></table></figure><p>三个<code>open</code>调用的文件描述符都是3，因为每个调用发起之后，在第二个调用发起之前就被关闭了，占用的文件描述符3 也被一并归还。</p><h3 id="通过终端查看文件描述符">通过终端查看文件描述符</h3><blockquote><p>在 Linux上，一个进程的文件描述符的集合可以直接通过路径<code>/proc/PID/fd/</code>访问，其中PID是进程标识符。<code>/proc/PID/fd/0</code>是stdin，<code>/proc/PID/fd/1</code>是stdout，<code>/proc/PID/fd/2</code>是stderr。任何运行中的进程也可以通过<code>/prec/self/fd</code>和<code>/dev/fd</code>访问自己的文件描述符。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/File_descriptor">[1]</span></a></sup></p></blockquote><p>可以得到如下信息：</p><ul><li>每个进程都拥有一个私有的由文件描述符构成的集合</li><li>可以通过进程标识符（PID）访问指定进程的文件描述符集合</li><li>运行中的进程可以通过<code>/prec/self/fd</code>访问自己的文件描述符</li></ul><p>继续用最开始的的代码进行测试，不过这次在<code>return 0</code>之前加上<code>sleep</code>语句，为我们在终端敲命令预留时间。先运行运行测试代码，返回PID12551，所以在终端输入<code>ll /proc/12551/fd</code>返回如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">╭─ ~                                                                       <br>╰─❯ ll /proc/12551/fd<br>总计 0<br>lrwx------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 0 </span>-&gt; /dev/pts/1<br>lrwx------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 1 </span>-&gt; /dev/pts/1<br>lrwx------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 2 </span>-&gt; /dev/pts/1<br>lr-x------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 3 </span>-&gt; /home/kznleaf/Desktop/c-dev/Lock/test.txt<br>lr-x------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 4 </span>-&gt; /home/kznleaf/Desktop/c-dev/Lock/test.txt<br>lr-x------<span class="hljs-number"> 1 </span>kznleaf kznleaf<span class="hljs-number"> 64 </span> 7月28日 22:45<span class="hljs-number"> 5 </span>-&gt; /home/kznleaf/Desktop/c-dev/Lock/test.txt<br></code></pre></td></tr></table></figure><p>这里有几个有趣的点：</p><ul><li>0~5就是文件描述符，没什么可说的</li><li><code>lr-x------</code>是什么？<ul><li><code>l</code>指的是这是一个符号链接文件</li><li><code>r-x</code>指该文件的所有者（user）有读和执行的权限，这很好理解，毕竟我们调用的open操作不会写入任何信息</li><li><code>------</code>不是连接线，而是指同组用户和其他用户都没有任何权限。<strong>这也印证了文件描述符是进程私有的</strong>。</li></ul></li><li>对于open调用，每个调用产生的文件描述符（<code>/proc/&lt;pid&gt;/fd/文件描述符编号</code>）都是一个符号链接，指向的都是<code>test.txt</code>这个文件。</li></ul><p>总结：系统调用<code>open</code>会被分配文件描述符，同时产生一个进程私有的符号链接文件，这个文件指向的就是要打开的目标文件。</p><h2 id="inode">⭐inode⭐</h2><p>比较重要的内容</p><h3 id="什么是inode">什么是inode</h3><p>inode是 index node 的缩写，也就是“索引节点”。什么的索引？</p><p>文件数据都储存在"块(Block)"中。除此之外，我们还必须储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这些到元信息是由系统创建的，为方便系统使用而生，不属于文件数据的一部分，所以我们得另外再找一个地方储存它们。</p><p>文件系统通常使用<code>inode</code>结构来储存这些数据块的元信息。Linux系统下，保存的元信息包括但不限于：</p><ul><li>文件名</li><li>大小（字节数）</li><li>硬链接数</li><li>权限信息</li><li>访问、修改、变更、创建时间</li><li>inode还保存了指向文件数据块的一个或多个指针，用于访问文件数据</li></ul><h3 id="什么是inode-number">什么是inode number</h3><p>inode number，或者“inode编号”“inode号码”，说的都是一个东西。</p><p>每个文件都与一个 inode 相关联，许多个inode就构成了<strong>inode表</strong>，inode表是系统级别的、<strong>所有进程共享的结构</strong>，位于内存中，由内核统一维护和管理，记录了被使用的inode信息。<strong>为了快速访问inode表中记录的inode信息，就需要为这个表加一个索引，也就是inode编号</strong>。</p><p>既然inode表是由内核维护和管理了，那么有了这个索引，内核的文件系统驱动程序就可以通过inode编号快速访问inode信息。</p><h3 id="inode和数据块的关系">inode和数据块的关系</h3><p>每个文件都有一个对应的inode。</p><p>访问磁盘中的文件之前，必须先找到这个文件的inode，才能访问文件所在数据块的具体信息。</p><p><strong>那么，inode是怎么记录数据块的位置的</strong>？</p><p>一种简单的情形是在 inode中有一个或多个直接指针（代表磁盘地址）。每个指针指向属于该文件的一个磁盘块。所以，拿到inode也就是拿到了文件的磁盘地址。</p><p>然而，这种方法有局限：例如，如果你想要一个非常大的文件（例如，大于块的大小乘以直接指针数），那就不走运了，这时就需要在inode引入新的结构——多级索引。</p><p><strong>多级索引</strong></p><p>inode中不仅由直接指向数据块的<strong>直接指针</strong>，还有指向间接块的<strong>间接指针</strong>。所谓“间接块”，指的就是磁盘中专门存储指针的块，间接块的每个指针指向数据块的地址。</p><p>如果文件的大小超过了直接指针能处理的范畴，那么文件系统就会分配一个间接块，并且设置间接指针指向它。间接指针的访问顺序是：<code>间接指针 -&gt; 间接块 -&gt; 许多数据块</code></p><p>如果想进一步扩容，可以引入<strong>双重间接指针</strong>：<code>双重间接指针 -&gt; 许多间接块 -&gt; 更多的数据块</code>。假如一个数据块是4KB，一个指针占用4个字节，那么一个间接块可以保存1024个指针，<strong>仅仅一个双重间接指针就可以带来额外4GB 的寻址空间</strong>，非常强大。</p><h3 id="inode节点的大小">inode节点的大小</h3><h3 id="inode编号和文件名的关系">inode编号和文件名的关系</h3><p>前面提到过，在目录中的每一个目录项都是<code>文件名 - inode编号</code>的一堆数据，那么文件名和inode的关系是什么？</p><blockquote><p>通常情况下，无法将打开的文件映射到用于打开该文件的文件名。<strong>当程序打开文件时，操作系统会将文件名转换为inode 编号，然后丢弃该文件名</strong>。</p><p>一些操作系统会维护一些额外的信息，以加快此操作的运行速度。例如，在Linux虚拟文件系统(VFS)中，目录项缓存（也称为 dentry 或dcache）是内核用来加速文件系统操作的缓存条目，它们将目录链接的信息存储在RAM中。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Inode">[2]</span></a></sup></p></blockquote><p>inode的这一特性允许我们走到不关闭进程的情况下对进程使用的文件进行更新。更新会创建新的inode，并且把原来的文件名对应的inode重定向到新的inode，此后新的进程会使用新的文件，而运行中的进程使用的仍然是原来的inode，实现对进程透明的替换操作。当旧的inode没有被任何进程使用，并且引用计数降为0时，就会自动被系统回收。这也是Linux系统的一大优势。</p><h2 id="创建文件-link">创建文件-link</h2><p>说完inode旧很好理解链接了。</p><h3 id="硬链接">硬链接</h3><p>创建一个文件时，实际上做了两件事:</p><ul><li>首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。</li><li>其次，将人类可读的文件名链接到该文件，并将该链接放入目录中。</li></ul><p>在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。实际上，<strong>它们都只是指向文件底层元数据的链接</strong>，可以在<strong>同一个inode编号</strong>中找到。</p><p>引用计数（有时称为链接计数，linkcount）允许文件系统跟踪有多少不同的文件名已硬链接到这个inode。如果引用计数为0，文件系统才会释放inode和相关的数据。真正删除该文件。</p><h3 id="软链接">软链接</h3><p>符号链接 symbolic link</p><p>硬链接只适用于文件，不能用于目录。因此人们又发明了软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s &lt;原名称&gt; &lt;符号链接名称&gt;<br></code></pre></td></tr></table></figure><p>符号链接和硬链接完全不同，它是文件系统继文件、目录之后的第三种类型。在<code>ls -l</code>的信息中：</p><ul><li><code>-</code>代表文件</li><li><code>d</code>代表目录</li><li><code>l</code>代表软链接</li></ul><p>软链接指向文件的路径名，路径名越长，链接文件越大。</p><p><strong>悬空引用</strong>：删除原始文件会导致软链接指向不存在的路径名。</p><h2id="文件描述符文件表和inode表的关系">文件描述符、文件表和inode表的关系</h2><p>下面这张图来自wiki，描述了<strong>单个进程</strong>的文件描述符、文件表和inode表的关系</p><p><img src="https://s21.ax1x.com/2025/07/28/pVYdwvD.png" /></p><p>文件描述符 3 没有指向任何条目，表示它已经被关闭了。</p><h2 id="读写磁盘">读写磁盘</h2><h3 id="读取文件无缓存">读取文件（无缓存）</h3><p>有了前面的一大堆铺垫，终于可以把这个问题说清楚了。</p><p>举个例子，加入我们要访问<code>/home/file.txt</code>这个文件。时刻记住：<strong>只有拿到目录的<code>inode</code>节点，才能访问它的目录项</strong>。</p><ol type="1"><li>根目录<code>/</code>的inode编号是实现清楚的，一般固定为2，所以系统可以直接拿到根目录的inode</li><li>读取<code>/</code>的数据块，也就是读取目录项，根据文件名找到<code>home</code>，进而得到inode编号</li><li>读取<code>/home/</code>路径下的目录项，找到<code>file.txt</code>的inode编号，至此终于拿到目标文件的inode！</li><li>inode中记录了<code>file.txt</code>这个文件在磁盘中的地址指针，所以可以定位磁盘的具体位置，开始读取数据块内容了。</li><li>读取操作也会更新inode的信息，比如最后一次访问时间</li></ol><h3 id="写入文件无缓冲">写入文件（无缓冲）</h3><p>创建文件涉及到一起列操作：读取inode的bitmap（bitmap记录了数据块的占用情况），更新bitmap，更新该文件的inode，更新文件所在的目录，更新文件所在的目录的inode。创建和写入文件的时间线：</p><p><img src="https://s21.ax1x.com/2025/07/31/pVtNKSS.png" /></p><h3 id="cahe-and-buffering">cahe and buffering</h3><p><strong>cache：缓存</strong>，这里主要指目录项缓存<code>dentry</code></p><p>如上面的例子所示，读取和写入文件的成本是非常大的，而且路径越长，检索文件的开销就越大。为了提高性能，大部分的文件系统都会使用DRAM，将<code>路径 -&gt; inode</code>的映射缓存在内存中，这样下次访问就不需要从根目录一层一层往下找了。</p><p>目录项缓存对读取操作的提升是非常明显的，甚至shell的自动补全功能也受益于dentry。</p><p><strong>buffering：缓冲</strong>，讨论一下写缓冲</p><p>Write buffering是指写入操作时，数据先写入内存中的缓存区域（而不是直接写入磁盘），延迟执行，以提高性能，减少I/O次数。通过延迟写入，文件系统可以积攒一批写入操作，同时执行，还可以避免无效操作，比如如果一个文件的inode位图被更新了两次，那么只会执行最后那一次。</p><p>当然写入缓冲也会带来一些问题，像数据库这种程序，为了避免数据意外丢失，要求立即写入。用C语言来说，这时可以在<code>write</code>命令后紧跟一条<code>fsync</code>，立即写入磁盘，不经过缓存。</p><h2 id="崩溃一致性">崩溃一致性</h2><h3 id="问题提出">问题提出</h3><p>如果出现断电或者系统崩溃，如何更新磁盘？</p><p>先假定一种简单的文件系统结构：</p><p><img src="https://s21.ax1x.com/2025/07/31/pVtdSJ0.png" /></p><p>然后解释一下位图、inode和数据块各自的作用：</p><table><thead><tr><th>名词</th><th>含义</th></tr></thead><tbody><tr><td><strong>数据块（Data Block）</strong></td><td>用于实际存储文件内容的磁盘块</td></tr><tr><td><strong>数据位图（Block Bitmap，B[v2]）</strong></td><td>一个位图，记录哪些数据块是“被使用”的（即 0 代表空闲，1代表已占用）</td></tr><tr><td><strong>inode（I[v2]）</strong></td><td>包含文件的元信息（文件大小、权限、时间戳）和<strong>指向数据块的地址</strong></td></tr></tbody></table><p>完整的写入数据过程需要把数据块、位图和inode都更新一遍。但是这三步不是原子的，如果更新过程中系统崩溃、断电，会出现故障，举一个例子：</p><p>如果位图和数据块都被写入了，但是inode没被写入，那么相当于某个车位被占用了，但是没有记录谁停了这个车。这种inode没写入但是位图已经写入的块被称为<strong>孤儿块</strong>，会造成磁盘空间的永久浪费。</p><h3 id="解决方法">解决方法</h3><ol type="1"><li><strong>文件系统检查程序</strong></li></ol><p>代表：<code>fsck</code>命令。fsck（file system consistency check）是Unix 和类 Unix系统上用于检查文件系统完整性的工具[1]。它类似于Windows和MS-DOS上的CHKDSK。适用于ext2/3/4文件系统，对于Btrfs这种写时复制系统来说不需要这个命令，因为系统本身已经保证了一致性。</p><p><code>fsck</code>（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。随着磁盘容量的增长和RAID的普及，fsck的性能变得令人望而却步。</p><hr /><ol start="2" type="1"><li><strong>数据日志</strong></li></ol><figure><img src="https://s21.ax1x.com/2025/07/31/pVtwYB4.png"alt="数据日志示意图" /><figcaption aria-hidden="true">数据日志示意图</figcaption></figure><p>在更新磁盘内容之前，把要做的事情写入磁盘，也就是日志。这样系统在崩溃后就能准确知道要修复的信息。先写日志，再覆写磁盘。</p><p>首先应该了解磁盘提供的原子性保证：磁盘保证任何512字节的写入都会发生或不发生。<strong>ext3</strong>文件系统的日志工作流程如下：</p><ol type="1"><li><strong>日志写入</strong>：将事务的内容（开始块、数据块。元数据块（inode，位图））写入日志，<strong>等待</strong>写入完成。其中事务开始（TxB）告诉我们有关此更新的信息，包括对文件系统即将进行的更新的相关信息</li><li><strong>日志提交</strong>：将事务提交块写入日志，<strong>等待</strong>写入完成，完成则被视为事务已经提交</li><li><strong>加检查点</strong>：将数据和元数据写入磁盘。</li></ol><p>在ext4中，整个事务可以一次性写入日志，无需等待，这是因为开始块和结束块中加入了日志内容的校验和，如果校验和不匹配就会丢弃事务。</p><p><strong>日志的空间占用</strong></p><p>日志的大小有限，日志满时，通过重用空间的方式来解决。一旦事务被加检查点，文件系统应释放它在日志中占用的空间，允许重用日志空间。改进后的步骤：</p><ol type="1"><li>日志写入：将事务的内容（包括TxB和更新内容）写入日志，等待这些写入完成。</li><li>日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。</li><li>加检查点：将更新内容写入其最终的磁盘位置。</li><li>释放：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。</li></ol><hr /><ol start="3" type="1"><li><strong>有序日志</strong></li></ol><figure><img src="https://s21.ax1x.com/2025/07/31/pVtwIv8.png" alt="有序日志" /><figcaption aria-hidden="true">有序日志</figcaption></figure><p>上面的日志将数据块也写入日志了，同一个数据块要被写入两次，性能比较差。<strong>有序日志</strong>或者<strong>元数据日志</strong>没有把用户数据也写入日志，而是先把数据块写入最终位置，然后再记录日志。（目录也属于元数据，会被保存到这里）</p><p>Linux ext3的有序日志：</p><ol type="1"><li>数据写入：将数据写入最终位置，等待完成（等待是可选的，详见下文）。</li><li>日志元数据写入：将开始块和元数据写入日志，等待写入完成。</li><li>日志提交：将事务提交块（包括<code>TxE</code>）写入日志，等待写完成，现在认为事务（包括数据）已提交（<code>committed</code>）。</li><li>加检查点元数据：将元数据更新的内容写入文件系统中的最终位置。</li><li>释放：稍后，在日志超级块中将事务标记为空闲。</li></ol><p>（只要保证提交事务之前完成步骤一和步骤二即可，不一定非要等步骤一完成之后才开始写入日志）</p><p>有序日志的核心思想：<strong>先写入被指对象，再写入指针对象</strong></p><p>除了以上几种解决方案之外，现代文件系统还有基于写时复制之类的更高级的思路，这里先不说了。</p><h2 id="参考链接">参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://en.wikipedia.org/wiki/File_descriptor<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://en.wikipedia.org/wiki/Inode<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为二手笔记本重装Arch Linux系统过程记录</title>
    <link href="/2025/07/29/%E4%BA%8C%E6%89%8B%E7%AC%94%E8%AE%B0%E6%9C%ACArch/"/>
    <url>/2025/07/29/%E4%BA%8C%E6%89%8B%E7%AC%94%E8%AE%B0%E6%9C%ACArch/</url>
    
    <content type="html"><![CDATA[<p>I use arch btw</p><span id="more"></span><p>为什么要专门买一个破笔记本安装 GNU/Linux系统？一方面是因为最近在看《操作系统导论》，这本书是基于 UNIX系统讲解的，当然也完全适用于GNU/Linux，但是不知道为什么虚拟机上的linux输入延迟比较大，早就想装到实体机上体验一下了；另一方面，最近几个月没少被win11恶心，包括但不限于：</p><ul><li>强制启用hyper-v</li><li>Alt+Tab打乱输入法</li><li>桌面图标每次开机后都会重新排列</li><li>睡眠模式概率睡死且硬盘通电次数暴增</li><li>越更新bug越多，在7月9日更新之后每次笔记本开机都有很大的概率蓝屏</li></ul><p>所以我考虑转向 GNU/Linux。</p><h2 id="选型">选型</h2><p>预算：1000￥以内，附加要求：能自由更换尽可能多的组件</p><p>去咸鱼上转了一大圈，能把价格压到1000以内的基本都是六七年以前的老笔记本，当然也有全新的但是我没捡到漏。最后盯上了两款：</p><ul><li>一个专门卖 ThinkPad 的贩子的 e470，880￥</li><li>联想小新老型号，这个卖的人一大把，600￥</li></ul><p>最后本着便宜优先的原则拍下了联想小新2019丐款。拆开后盖马上就后悔了...不如换成更方便折腾的thinkpad</p><p>今天看到了一个视频：<ahref="https://www.youtube.com/watch?v=vtkQiLkNgOI">Building the ultimateThinkPad!</a>，视频里给Think PadT440P里里外外都换了一圈，包括键盘、内存、硬盘、BIOS、屏幕、甚至就连 CPU也是可拆卸的（插槽式CPU）😲</p><p>然后去某宝看了一眼，700+就能拿下，早知道买这个了。等找到实习攒够了钱就搞一个回来玩玩</p><h2 id="拆机">拆机</h2><figure><img src="https://s21.ax1x.com/2025/07/28/pVYu5DS.jpg" alt="拆机" /><figcaption aria-hidden="true">拆机</figcaption></figure><p>复古SATA固态，裸露的单热管，还有内存条的屏蔽罩跑哪儿去了😭算了能用就行。后盖上的防拆贴还在，从撬开后盖需要的力度来看这个笔记本不像是被拆过的，莫非是🐕‍🦺想在作妖</p><p>然后把风扇取下来清了清灰，发现基本没什么灰可以清。另外内存和网卡都太烂了，所以马上下单了一根16G内存和AX210网卡，过两天一到货马上开始换。系统信息：</p><figure><img src="https://s21.ax1x.com/2025/07/28/pVYKuUH.jpg"alt="懒得截图了" /><figcaption aria-hidden="true">懒得截图了</figcaption></figure><h2 id="装系统">装系统</h2><p>主要参考<ahref="https://arch.icekylin.online/">archlinux简明指南</a>和<ahref="https://www.bilibili.com/video/BV1L2gxzVEgs/?spm_id_from=333.337.search-card.all.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9">这个视频</a>。说一下分盘思路：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS<br>sda      8:0   <span class="hljs-number"> 0 </span>238.5G <span class="hljs-number"> 0 </span>disk <br>├─sda1   8:1   <span class="hljs-number"> 0 </span>    1G <span class="hljs-number"> 0 </span>part /boot/efi<br>└─sda2   8:2   <span class="hljs-number"> 0 </span>237.5G <span class="hljs-number"> 0 </span>part /swap<br>                                 /home<br>                                 /<br></code></pre></td></tr></table></figure><p>一共256G的硬盘，给 UEFI分了1G，剩下的都用做根目录。没有为swap创建分区，因为用的是swap文件。文件系统使用btrfs，方便快照和回滚。</p><h2 id="升级内存网卡">升级内存&amp;网卡</h2><p>这个笔记本自带的内存是焊死的 4G 和一根可更换的DDR4 4G，一共8G，实际工作频率是2400MHz。不过自带的内存条上写的是2666，估计是被压下去了。</p><p>8G内存感觉还是小了，因为还要给 GPU 分过去 2G。所以去pdd捡了根16G2666MHz：</p><figure><img src="https://s21.ax1x.com/2025/07/28/pVYuJAJ.jpg" alt="内存" /><figcaption aria-hidden="true">内存</figcaption></figure><p>是不是真货不知道，反正用着没毛病</p><hr /><p>自带的网卡是 QCA9377，有点太老了，换成AX210，简单比较一下：</p><table><thead><tr><th>参数</th><th><strong>Intel AX210</strong></th><th><strong>Qualcomm Atheros QCA9377</strong></th></tr></thead><tbody><tr><td>🆔 芯片代号</td><td>Typhoon Peak</td><td>Sparrow</td></tr><tr><td>📶 Wi-Fi标准</td><td>Wi-Fi 6E（802.11ax）</td><td>Wi-Fi 5（802.11ac）</td></tr><tr><td>📡 频段支持</td><td>2.4 GHz + 5 GHz + 6 GHz（三频）</td><td>2.4 GHz + 5 GHz（双频）</td></tr><tr><td>📊 MIMO配置</td><td>2x2 MU-MIMO</td><td>1x1 SU-MIMO</td></tr><tr><td>🚀 理论最大速率</td><td>~2.4 Gbps（802.11ax）</td><td>~433 Mbps（802.11ac）</td></tr><tr><td>📱 蓝牙版本</td><td>蓝牙 5.2</td><td>蓝牙 4.1</td></tr><tr><td>🔧 Linux 支持</td><td>✅ 新内核（5.10+）+ 最新固件</td><td>✅ 老内核（4.x）也支持</td></tr><tr><td>🔋 功耗</td><td>略高，但为高性能设计</td><td>低功耗（适合移动设备）</td></tr><tr><td>🧠 技术支持</td><td>OFDMA, TWT, WPA3 等新特性</td><td>基础 802.11ac 功能</td></tr><tr><td>🧱 应用场景</td><td>高端笔记本、桌面、Wi-Fi 6E路由器</td><td>老旧笔电、Chromebook、便携设备</td></tr></tbody></table><p>Linux内核已经内置了大量主流网卡的驱动，包括 AX210在内，所以换上网卡之后什么也不用干就可以直接开始用了。（蓝牙鼠标要重新配对）</p><p>换完网卡感觉不仅网速变快，而且蓝牙鼠标的连接速度和灵敏度也快多了=w=</p><p>使用下面的命令可以查看当前的网卡信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci | grep -i net<br></code></pre></td></tr></table></figure><ul><li><code>lspci</code>：列出所有 PCI 总线上的设备</li><li><code>| grep -i net</code>对输出结果进行筛选，只保留包含<code>net</code>的行</li></ul><p>输出：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">╭─ <span class="hljs-symbol">~                                                                          10</span>:<span class="hljs-number">45</span><span class="hljs-punctuation">:</span><span class="hljs-number">12</span><br>╰─❯ lspci <span class="hljs-string">| grep -i net</span><br><span class="hljs-number">01</span><span class="hljs-punctuation">:</span><span class="hljs-number">00.0</span> Network controller<span class="hljs-punctuation">:</span> Intel Corporation Wi<span class="hljs-punctuation">-</span>Fi <span class="hljs-number">6</span>E<span class="hljs-punctuation">(</span><span class="hljs-number">802.11</span>ax<span class="hljs-punctuation">)</span> AX210/AX1675* <span class="hljs-number">2</span>x2 [Typhoon Peak] <span class="hljs-punctuation">(</span>rev <span class="hljs-number">1</span>a<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>也可以使用<code>lsmod | grep iwlwifi</code>查看 wifi驱动加载情况。等以后组了台式机可以再把这张网卡换上，想想就爽</p><h2 id="实用工具">实用工具</h2><h3 id="代理">代理</h3><p>目前使用<ahref="https://v2raya.org/">v2raya</a>，速度尚可，使用方法参见<ahref="https://pengtech.net/network/v2rayA_install.html#3-1-%E9%85%8D%E7%BD%AE-v2rayA">这篇博客</a>。</p><h3 id="图像查看">图像查看</h3><p>一开始用的是<code>gwenview</code>，感觉卡卡的，尝试好几种图像查看器之后发现<code>Okular</code>也可以用来看图像，而且流畅得多=w=</p><h3 id="硬盘测速">硬盘测速</h3><p>安装<code>hdparm</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S hdparm<br></code></pre></td></tr></table></figure><p>测试读取速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> hdparm -Tt /dev/sdX<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─❯ <span class="hljs-built_in">sudo</span> hdparm -Tt /dev/sda<br><br>/dev/sda:<br> Timing cached reads:   19300 MB <span class="hljs-keyword">in</span>  1.98 seconds = 9725.01 MB/sec<br> Timing buffered disk reads: 1328 MB <span class="hljs-keyword">in</span>  3.01 seconds = 441.80 MB/sec<br></code></pre></td></tr></table></figure><p>第一行是CPU缓存测试，第二行是顺序读速度。</p><h3 id="文件互传">文件互传</h3><p>LocalSend 是一款跨平台的文件传输工具，可以直接从AUR安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay -S localsend<br></code></pre></td></tr></table></figure><p>windows、安卓、Linux，只要在同一个网络下，都可以非常方便地互传文件，强推</p><h3 id="监视系统信息">监视系统信息</h3><p>btop，<del>装b神器</del></p><p><img src="https://s21.ax1x.com/2025/07/29/pVYTngS.png" /></p><h3 id="截图">截图</h3><p>Windows系统下最好用的截图工具无疑是Snipaste，但是迟迟没有推出Linux版本。</p><p><code>Spectacle</code>可以一用，虽然比不上Snipaste，但也够用了。</p><h2 id="美化">美化</h2><ul><li>主题美化参考<ahref="https://www.bilibili.com/video/BV1WsGmzRECp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9">这个视频</a>，使用Nordic 主题，直接解决了毛玻璃效果无法使用的问题。</li><li>Konsole 使用 zsh + <ahref="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>美化</li></ul><p>效果图：</p><p><img src="https://s21.ax1x.com/2025/07/29/pVYRJVf.png" /></p><h2 id="遇到的问题">遇到的问题</h2><h3 id="锁屏动画失效问题">锁屏动画失效问题</h3><p>和 <ahref="https://bugs.kde.org/show_bug.cgi?id=499377&amp;utm_source=chatgpt.com">Bug499377</a> 反映的问题完全相同，同样的 error 日志也出现在<ahref="https://bugs.kde.org/show_bug.cgi?id=478601">Bug478601</a>，表现为每次切换至锁屏界面的时候显示器都会变成左半边纯绿色、右半边纯黑，动画结束之后又会恢复正常。</p><p>先调用<code>journalctl -r</code>查看最近日志，定位锁屏出错信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7</span>月 <span class="hljs-number">26</span> <span class="hljs-number">12</span>:<span class="hljs-number">10</span>:<span class="hljs-number">03</span> Arch kscreenlocker_greet[<span class="hljs-number">3176</span>]: Fai<br><span class="hljs-attribute">led</span> to write to the pipe: 错误的文件描述符.<br><span class="hljs-attribute">7</span>月 <span class="hljs-number">26</span> <span class="hljs-number">12</span>:<span class="hljs-number">10</span>:<span class="hljs-number">03</span> Arch kscreenlocker_greet[<span class="hljs-number">3176</span>]: qt.<br><span class="hljs-attribute">qpa</span>.wayland: Could not create EGL surface (EGL error <span class="hljs-number">0</span>x3000)<br></code></pre></td></tr></table></figure><p><code>kscreenlocker_greet</code>：负责锁屏界面渲染，说明是锁屏界面在渲染EGL 时失败，临时显示异常。上述日志的解释：</p><blockquote><p>这是 Plasma 6 在 Wayland 锁屏程序 kscreenlocker_greet里留下的已确认 bug（KDE Bug 478601/499377）。日志里 0x3000 实际代表EGL_SUCCESS，但 Qt仍把它当作警告打印出来。目前上游尚未合并修复补丁，很多用户都会在解锁或显示器重新点亮时看到同样的两行信息。</p></blockquote><p>所以说这应该是目前 Wayland 的一个待修复bug。于是我尝试切换为X11，发现<code>/usr/share/xsessions/</code>为空，后来才知道X11会话文件被拆成了独立的包<code>plasma‑x11‑session</code>提供，所以需要先单独安装这个软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -S plasma‑x11‑session<br></code></pre></td></tr></table></figure><p>切换为X11后，需要重新设定屏幕缩放比例和鼠标灵敏度，其中屏幕缩放比例必须注销重新登录后才能生效；而且x11情况下某些应用程序的动效变得十分卡顿？另外，锁屏动画也是不存在的，而是从原本的画面生硬地切换到锁屏画面，跟我预期的不一样。考虑到：</p><p><img src="https://s21.ax1x.com/2025/07/26/pVJ5nzQ.png" /></p><p>所以最后还是换回 Wayland 了QAQ暂时的应对方案就是直接禁用掉自动锁屏（反正我也没什么锁屏的需求）</p><h3 id="minecraft启动失败">Minecraft启动失败</h3><p>见<ahref="/2025/07/25/ArchLinux%E5%90%AF%E5%8A%A8mc%E5%B4%A9%E6%BA%83/">/2025/07/25/ArchLinux%E5%90%AF%E5%8A%A8mc%E5%B4%A9%E6%BA%83/</a></p><h2 id="总结">总结</h2><p>高考完的暑假买了个联想拯救者R7000P，作为一个游戏本对我来说性能有些冗余了，因为平时基本不打游戏，而且四五斤的重量和不存在的续航没少折磨我:(。如果能回到那个暑假，我估计会买一个性能好点的轻薄本和一个thinkpad，一个用来糊弄课内毫无意义的课程，一个装上Arch用来折腾，当然最重要的是劝自己报考软件专业，别踏马盯着你那物理了。</p><p>刚才看到了<ahref="https://www.youtube.com/watch?v=m_QAvGlh-Pg">这个视频</a>，真正的CS 大佬只需要花费300$，包括一个装了 Ubuntu 的ThinkPad，刷了纯净系统的老式索尼收集，和几个电子阅读器(Kindle，NOOK)就足以满足日常学习需求。相比之下那群天天嫌弃自己的设备太垃圾（其实只是游戏打得不够爽罢了）互相攀比的大学生有够可笑的:)</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>折腾记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux运行 1.8.9 Minecraft失败解决方法</title>
    <link href="/2025/07/25/ArchLinux%E5%90%AF%E5%8A%A8mc%E5%B4%A9%E6%BA%83/"/>
    <url>/2025/07/25/ArchLinux%E5%90%AF%E5%8A%A8mc%E5%B4%A9%E6%BA%83/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>用 HTML 启动1.8.9版本，需要下载Java8，使用命令<code>sudo pacman -S jdk8-openjdk</code>成功安装，然后用java8运行游戏，启动失败，<code>./minecraft/crash-resources</code>目录下的崩溃日志完整内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">----</span> <span class="hljs-string">Minecraft</span> <span class="hljs-string">Crash</span> <span class="hljs-string">Report</span> <span class="hljs-string">----</span><br><span class="hljs-string">//</span> <span class="hljs-string">Don&#x27;t</span> <span class="hljs-string">be</span> <span class="hljs-string">sad,</span> <span class="hljs-string">have</span> <span class="hljs-string">a</span> <span class="hljs-string">hug!</span> <span class="hljs-string">&lt;3</span><br><br><span class="hljs-attr">Time:</span> <span class="hljs-number">25</span><span class="hljs-number">-7</span><span class="hljs-number">-25</span> <span class="hljs-string">下午6:03</span><br><span class="hljs-attr">Description:</span> <span class="hljs-string">Initializing</span> <span class="hljs-string">game</span><br><br><span class="hljs-string">java.lang.ExceptionInInitializerError</span><br><span class="hljs-string">at</span> <span class="hljs-string">Config.getDisplayModes(Config.java:1862)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.settings.GameSettings$Options.&lt;clinit&gt;(GameSettings.java:3384)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.settings.GameSettings.&lt;init&gt;(GameSettings.java:313)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.Minecraft.func_71384_a(Minecraft.java:395)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:329)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.main.Main.main(SourceFile:124)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.NativeMethodAccessorImpl.invoke0(Native</span> <span class="hljs-string">Method)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="hljs-string">at</span> <span class="hljs-string">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.launchwrapper.Launch.launch(Launch.java:135)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.launchwrapper.Launch.main(Launch.java:28)</span><br><span class="hljs-attr">Caused by: java.lang.ArrayIndexOutOfBoundsException:</span> <span class="hljs-number">0</span><br><span class="hljs-string">at</span> <span class="hljs-string">org.lwjgl.opengl.LinuxDisplay.getAvailableDisplayModes(LinuxDisplay.java:951)</span><br><span class="hljs-string">at</span> <span class="hljs-string">org.lwjgl.opengl.LinuxDisplay.init(LinuxDisplay.java:738)</span><br><span class="hljs-string">at</span> <span class="hljs-string">org.lwjgl.opengl.Display.&lt;clinit&gt;(Display.java:138)</span><br><span class="hljs-string">...</span> <span class="hljs-number">12</span> <span class="hljs-string">more</span><br><br><br><span class="hljs-string">A</span> <span class="hljs-string">detailed</span> <span class="hljs-string">walkthrough</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">error,</span> <span class="hljs-attr">its code path and all known details is as follows:</span><br><span class="hljs-string">---------------------------------------------------------------------------------------</span><br><br><span class="hljs-string">--</span> <span class="hljs-string">Head</span> <span class="hljs-string">--</span><br><span class="hljs-attr">Stacktrace:</span><br><span class="hljs-string">at</span> <span class="hljs-string">Config.getDisplayModes(Config.java:1862)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.settings.GameSettings$Options.&lt;clinit&gt;(GameSettings.java:3384)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.settings.GameSettings.&lt;init&gt;(GameSettings.java:313)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.Minecraft.func_71384_a(Minecraft.java:395)</span><br><br><span class="hljs-string">--</span> <span class="hljs-string">Initialization</span> <span class="hljs-string">--</span><br><span class="hljs-attr">Details:</span><br><span class="hljs-attr">Stacktrace:</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:329)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.client.main.Main.main(SourceFile:124)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.NativeMethodAccessorImpl.invoke0(Native</span> <span class="hljs-string">Method)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="hljs-string">at</span> <span class="hljs-string">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="hljs-string">at</span> <span class="hljs-string">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.launchwrapper.Launch.launch(Launch.java:135)</span><br><span class="hljs-string">at</span> <span class="hljs-string">net.minecraft.launchwrapper.Launch.main(Launch.java:28)</span><br><br><span class="hljs-string">--</span> <span class="hljs-string">System</span> <span class="hljs-string">Details</span> <span class="hljs-string">--</span><br><span class="hljs-attr">Details:</span><br><span class="hljs-attr">Minecraft Version:</span> <span class="hljs-number">1.8</span><span class="hljs-number">.9</span><br><span class="hljs-attr">Operating System:</span> <span class="hljs-string">Linux</span> <span class="hljs-string">(amd64)</span> <span class="hljs-string">version</span> <span class="hljs-number">6.15</span><span class="hljs-number">.7</span><span class="hljs-string">-arch1-1</span><br><span class="hljs-attr">Java Version:</span> <span class="hljs-number">1.8</span><span class="hljs-string">.0_462,</span> <span class="hljs-string">Arch</span> <span class="hljs-string">Linux</span><br><span class="hljs-attr">Java VM Version:</span> <span class="hljs-string">OpenJDK</span> <span class="hljs-number">64</span><span class="hljs-string">-Bit</span> <span class="hljs-string">Server</span> <span class="hljs-string">VM</span> <span class="hljs-string">(mixed</span> <span class="hljs-string">mode),</span> <span class="hljs-string">Arch</span> <span class="hljs-string">Linux</span><br><span class="hljs-attr">Memory:</span> <span class="hljs-number">130908928</span> <span class="hljs-string">bytes</span> <span class="hljs-string">(124</span> <span class="hljs-string">MB)</span> <span class="hljs-string">/</span> <span class="hljs-number">301989888</span> <span class="hljs-string">bytes</span> <span class="hljs-string">(288</span> <span class="hljs-string">MB)</span> <span class="hljs-string">up</span> <span class="hljs-string">to</span> <span class="hljs-number">7952400384</span> <span class="hljs-string">bytes</span> <span class="hljs-string">(7584</span> <span class="hljs-string">MB)</span><br><span class="hljs-attr">JVM Flags:</span> <span class="hljs-number">17</span> <span class="hljs-string">total;</span> <span class="hljs-string">-Xmx7559m</span> <span class="hljs-string">-XX:+UnlockExperimentalVMOptions</span> <span class="hljs-string">-XX:+UnlockDiagnosticVMOptions</span> <span class="hljs-string">-XX:+UseG1GC</span> <span class="hljs-string">-XX:G1MixedGCCountTarget=5</span> <span class="hljs-string">-XX:G1NewSizePercent=20</span> <span class="hljs-string">-XX:G1ReservePercent=20</span> <span class="hljs-string">-XX:MaxGCPauseMillis=50</span> <span class="hljs-string">-XX:G1HeapRegionSize=32m</span> <span class="hljs-string">-XX:-OmitStackTraceInFastThrow</span> <span class="hljs-string">-XX:MaxInlineLevel=15</span> <span class="hljs-string">-XX:-DontCompileHugeMethods</span> <span class="hljs-string">-XX:MaxNodeLimit=240000</span> <span class="hljs-string">-XX:NodeLimitFudgeFactor=8000</span> <span class="hljs-string">-XX:TieredCompileTaskTimeout=10000</span> <span class="hljs-string">-XX:ReservedCodeCacheSize=400M</span> <span class="hljs-string">-XX:NmethodSweepActivity=1</span><br><span class="hljs-attr">IntCache: cache:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">tcache:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">allocated:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">tallocated:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">FML:</span> <br><span class="hljs-attr">Loaded coremods (and transformers):</span> <br><span class="hljs-attr">Launched Version:</span> <span class="hljs-number">1.8</span><span class="hljs-number">.9</span><span class="hljs-string">-Forge-OptiFine</span><br><span class="hljs-attr">LWJGL:</span> <span class="hljs-number">2.9</span><span class="hljs-number">.4</span><br><span class="hljs-attr">OpenGL:</span> <span class="hljs-string">~~ERROR~~</span> <span class="hljs-attr">RuntimeException:</span> <span class="hljs-literal">No</span> <span class="hljs-string">OpenGL</span> <span class="hljs-string">context</span> <span class="hljs-string">found</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">current</span> <span class="hljs-string">thread.</span><br><span class="hljs-attr">GL Caps:</span> <br><span class="hljs-attr">Using VBOs:</span> <span class="hljs-string">~~ERROR~~</span> <span class="hljs-attr">NullPointerException:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">Is Modded:</span> <span class="hljs-string">Definitely;</span> <span class="hljs-string">Client</span> <span class="hljs-string">brand</span> <span class="hljs-string">changed</span> <span class="hljs-string">to</span> <span class="hljs-string">&#x27;fml,forge&#x27;</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">Client</span> <span class="hljs-string">(map_client.txt)</span><br><span class="hljs-attr">Resource Packs:</span> <span class="hljs-string">~~ERROR~~</span> <span class="hljs-attr">NullPointerException:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">Current Language:</span> <span class="hljs-string">~~ERROR~~</span> <span class="hljs-attr">NullPointerException:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">Profiler Position:</span> <span class="hljs-string">N/A</span> <span class="hljs-string">(disabled)</span><br><span class="hljs-attr">CPU:</span> <span class="hljs-string">&lt;unknown&gt;</span><br><span class="hljs-attr">OptiFine Version:</span> <span class="hljs-string">OptiFine_1.8.9_HD_U_M5</span><br><span class="hljs-attr">OptiFine Build:</span> <span class="hljs-number">20210124</span><span class="hljs-number">-163719</span><br><span class="hljs-attr">Shaders:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">OpenGlVersion:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">OpenGlRenderer:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">OpenGlVendor:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">CpuCount:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>关键在这两行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: <span class="hljs-number">0</span><br>at org<span class="hljs-selector-class">.lwjgl</span><span class="hljs-selector-class">.opengl</span><span class="hljs-selector-class">.LinuxDisplay</span><span class="hljs-selector-class">.getAvailableDisplayModes</span>(LinuxDisplay<span class="hljs-selector-class">.java</span>:<span class="hljs-number">951</span>)<br><br>OpenGL: ~~ERROR~~ RuntimeException: No OpenGL context found <span class="hljs-keyword">in</span> the current thread.<br></code></pre></td></tr></table></figure><p>对应两个问题：</p><ol type="1"><li><strong>lwjgl 获取不到任何显示模式</strong></li><li><strong>找不到 OpenGL</strong></li></ol><p>硬件信息：</p><figure><img src="https://s21.ax1x.com/2025/07/25/pVJ0yPx.png" alt="硬件信息" /><figcaption aria-hidden="true">硬件信息</figcaption></figure><h2 id="问题排查">问题排查</h2><p>先排查openGL相关的问题：</p><ol type="1"><li>查看显卡信息、加载的内核模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci -k | grep -A 3 -E <span class="hljs-string">&quot;(VGA|3D)&quot;</span><br>lsmod | grep amdgpu<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>检查openGL是否工作正常</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">glxgears<br></code></pre></td></tr></table></figure><p>出现一个转动的齿轮窗口，说明 OpenGL渲染正常。前两步的运行结果如下：</p><p><img src="https://s21.ax1x.com/2025/07/25/pVJwZX4.png" /></p><p>都没有问题。</p><p>下面排查LWJGL。在一番查找后我找到了<ahref="https://github.com/PolyMC/PolyMC/issues/1533">这个issue</a>，里面提到：</p><blockquote><p>LWJGL 在底层使用 xrandr，通过解析 xrandr -q命令的输出来获取屏幕分辨率。</p><p>我安装了 xrandr，各个版本加载都没有问题。</p></blockquote><p>Arch Linux安装xrandr的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S xorg-xrandr<br></code></pre></td></tr></table></figure><p>安装后成功启动游戏。游戏截图：</p><figure><img src="https://s21.ax1x.com/2025/07/25/pVJ03an.png" alt="截图" /><figcaption aria-hidden="true">截图</figcaption></figure><p>（六年前的牢核显低端笔记本还能稳定在60Hz，满足了）</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>折腾记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】折腾的重要性</title>
    <link href="/2025/07/19/%E6%8A%98%E8%85%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <url>/2025/07/19/%E6%8A%98%E8%85%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>本文转自编程随想的博客https://program-think.blogspot.com/2017/04/The-Importance-of-Zheteng.html<br />发布时间：2017年4月19日</p><span id="more"></span><h2 id="文章目录">文章目录</h2><p><a href="#引子">引子</a><br /><a href="#名词定义何为折腾">★名词定义：何为“折腾”</a><br /><a href="#折腾与自学能力">★“折腾”与“自学能力”</a><br /><a href="#折腾与解决问题能力">★“折腾”与“解决问题能力”</a><br /><a href="#折腾与知识面知识结构">★“折腾”与“知识面/知识结构”</a><br /><a href="#折腾与动手实践能力">★“折腾”与“动手实践能力”</a><br /><a href="#折腾与心理舒适区">★“折腾”与“心理舒适区”</a><br /><ahref="#聊聊那些不折腾的理由或借口">★聊聊那些“不折腾”的理由或借口</a><br /><a href="#俺写本文的动机">★俺写本文的动机</a></p><h2 id="引子">引子</h2><p>前不久写了篇关于 Linux的博文。看到博客评论区中有一些“关于折腾的抱怨”。之前俺写其它教程（比如：翻墙、操作系统虚拟机），也看到过类似的抱怨。</p><p>关于折腾的抱怨，俺总结下来有两类：</p><ul><li>其一，“从不折腾的人”抱怨折腾太麻烦（这类抱怨往往是泛泛的）</li><li>其二，“有过折腾经历的人”抱怨折腾太麻烦（这类抱怨往往是有具体所指的）</li></ul><p>所以今天就来聊聊“折腾”这个话题。</p><h2 id="名词定义何为折腾">★名词定义：何为“折腾”</h2><p>为了避免某些人抬杠，先界定一下关键术语——“折腾”一词指的是啥？</p><p>在下面的讨论中，“折腾”一词指的是：</p><ul><li>在你【不熟悉】的领域中干某些事情（如果是你【熟悉】的领域，那属于“轻车熟路”，不能算“折腾”）</li><li>这些事情通常带有某种“探索/钻研”的性质（通常颇费周折）</li><li>这些事情通常要耗费一定的时间和精力（能很快搞定的，就不能算“折腾”）</li><li>这些事情通常具有不确定的结果（你不清楚是否能得到期望的结果）。</li></ul><p>举例：</p><ul><li>针对软件的折腾（比如：Linux）</li><li>针对硬件的折腾（比如：树莓派）</li><li>针对网络的折腾（比如：翻墙）</li><li>......</li></ul><h2 id="折腾与自学能力">★“折腾”与“自学能力”</h2><h3 id="自学能力的重要性">◇“自学能力”的重要性</h3><p>博客的读者们应该都明白这玩意儿的重要性吧？俺随便说几点：</p><ul><li>比如：信息时代会有很多新生事物。你以前在学校课堂里学到的知识/技能已经无法应对这些新生事务，你需要通过自学来搞定它们。</li><li>比如：在信息时代，知识的半衰期会变短。你以前在学校课堂里学到的知识/技能，等到你工作时，有些已经过时（失效）了。你需要通过自学来更新这部分过时的知识。</li><li>比如：如今的职场竞争会比以往更激烈（信息流动加快使得人才流动加快）。自学能力强的人无疑会有更大的优势。</li><li>......</li></ul><h3 id="两者的关系">◇两者的关系</h3><p>前面俺强调了：折腾的前提是——在你【不熟悉】的领域。</p><p>在这种领域中，你多半要通过自学，掌握某些知识或技能，让“不熟悉的领域”变为“熟悉的领域”。</p><p>所以，喜欢折腾的人，他/她的自学能力会经常得到锻炼。当然啦，“经常锻炼自学能力”不一定就表示“自学能力很强”，但至少好于那些“从来没有得到锻炼的人”。</p><h2 id="折腾与解决问题能力">★“折腾”与“解决问题能力”</h2><h3 id="解决问题能力的重要性">◇“解决问题能力”的重要性</h3><p>说到这个，俺又要趁机来恶毒攻击一下咱们天朝的教育体制了:)</p><p>如果你回顾一下学校（小学/中学/大学）里面的考试或课后作业，大部分的题目都有标准答案（理工科尤其明显）。</p><p>但是当你进入职场后，很多工作中的问题，其解决方法是多种多样的，【没有标准答案】。</p><p><strong>这两类问题的解题思路是完全不同滴——</strong> -【有】标准答案的问题，解题的思维过程通常是【收敛式】； -【没有】标准答案的问题，解体的思维过程通常是【发散式】。</p><p>有很多学校中的优秀生，他们很擅长于考试，但是在工作中的表现却令人难以恭维。因为他们擅长的【收敛式思维】，在工作中通常用不上。</p><h3 id="两者的关系-1">◇两者的关系</h3><p>“折腾”与“解题能力”有哪些关系捏？</p><p>当你在不熟悉的领域中折腾，通常不会一帆风顺——整个过程必然会碰到各种各样的问题（困难和障碍），这些问题往往是没有标准答案滴。换句话说，折腾中碰到问题，【不同于】你在学校中碰到的考题，而【更接近于】你在实际工作中碰到问题。</p><p>所以，经常折腾的人，会有更多的机会去锻炼他/她的【发散思维能力】。也就可以更多地弥补学校教育在这方面的缺陷。</p><h2 id="折腾与知识面知识结构">★“折腾”与“知识面/知识结构”</h2><h3 id="知识面的重要性">◇知识面的重要性</h3><p>如今这个信息时代，【复合型人才】更有竞争优势。所谓的“复合型”，其主要特征【之一】就是“知识面比较广”。这类人往往兼具多个不同领域的技能。</p><p>就拿自己来现身说法——简述一下：维护目前这个博客，大概需要哪些技能？</p><ul><li>基本的写作能力是必不可少滴——如果写出来的文章狗屁不通，就没人看了；</li><li>翻墙是必不可少滴——俺必须把博客搭建在墙外，才能防止真理部的和谐；</li><li>信息安全也是必不可少滴——否则早就被跨省追捕了；</li><li>懂一些 Web 开发的技能（CSS 和JS）是有好处滴——有助于俺把博客界面搞得好看/好用；</li></ul><p>除了上面这些，因为俺博客聊到了“政治、历史、心理学、管理、编程”这几类话题，所以俺在这几个领域多少还算略懂（不敢妄称精通）。</p><h3id="什么样的知识结构才是合理的有优势的">◇什么样的知识结构才是合理的（有优势的）</h3><p>前面提到了“知识面的广度”。但仅仅有广度是【不够】滴。良好的知识结构，应该兼具【广度】与【深度】。</p><p>至于“深度”与“广度”要如何搭配才比较好，可以看俺多年前的一篇博文《<ahref="https://program-think.blogspot.com/2013/09/knowledge-structure.html">如何完善自己的知识结构</a>》。</p><h3 id="两者的关系-2">◇两者的关系</h3><p>那么，“折腾”与“知识面/知识结构”有啥关系捏？</p><p>比如说：你正在折腾 A领域的某个事物，在折腾的过程中可能会依赖到相关领域的知识（比如说 B领域 和C领域）。而 B领域 和 C领域 可能是你之前所不了解的。为了搞定A领域，你就需要顺便去了解 B领域 和C领域。无形中，你的知识面就拓宽了。</p><p>举个栗子：</p><p>某个技术菜鸟去折腾翻墙，当此人搞定之后，通常也顺便学会了一些网络相关的知识（比如：代理、VPN...）</p><p>如果此人是通过 VPS 来搭建翻墙代理，说不定还顺便学会了一些 Linux系统管理方面的知识。</p><h2 id="折腾与动手实践能力">★“折腾”与“动手实践能力”</h2><h3 id="两种不同的领域">◇两种不同的领域</h3><p>所有的领域可以分为两类——“记忆型”与“实践型”。<br />（注：这两个术语是俺拍脑袋临时起的名儿，如果你有更恰当的叫法，欢迎告知俺）</p><p>所谓的“记忆型”，意思就是说：你只需要依靠记忆力就可以掌握该领域。</p><p>而“实践型”则完全不同——要掌握这种类型的领域，光靠记忆力是肯定不够滴，一定要经过动手实践。</p><p>举例： - “记忆型”的例子比较少：历史、艺术鉴赏... -“实践型”的例子比较多：所有的体育项目、所有的棋牌游戏和电子游戏、烹调、编程、管理、艺术创作......</p><p>对于“实践型”的领域，不管你看了多少相关的书籍，记住了多少相关的知识，最后都要经过实践，才能最终掌握该领域。套用一句古话就是：纸上得来终觉浅，绝知此事要躬行。</p><p>举例：</p><ul><li>比如说下围棋——如果某人从来没有实际下过，即使此人看了 N多的棋谱，看了 N 多的围棋理论书籍，也不能算是“会下棋”。</li><li>学编程也类似——俺一直强调学编程（尤其是新人学编程）要：一边看书一边动手写点小程序练手。</li></ul><h3 id="两者的关系-3">◇两者的关系</h3><p>俺个人认为：凡是需要折腾的领域，都是实践型的领域。<br />而经常折腾的好处在于：每次折腾都是在锻炼你的动手实践能力。</p><h2 id="折腾与心理舒适区">★“折腾”与“心理舒适区”</h2><h3 id="啥是心理舒适区">◇啥是“心理舒适区”？</h3><p>两年前（2015）写过一篇《<ahref="https://program-think.blogspot.com/2015/12/Hobbies-and-Interests.html">什么是【真正的】兴趣爱好？以及它有啥好处？</a>》，其中正好聊过“心理舒适区”这个概念。下面这段直接引自那篇博文的相关段落。</p><p>首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“ComfortZone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。</p><p>如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。</p><p>举例：</p><ul><li>上网闲逛</li><li>看电视剧</li><li>看娱乐节目</li></ul><h3 id="心理舒适区的根源">◇“心理舒适区”的【根源】</h3><p>本文写完两年之后（2019），俺又写了如下这篇。从“心理学 ＆脑神经科学”的角度聊了“心理舒适区”的【部分】成因。《<ahref="https://program-think.blogspot.com/2019/03/Why-Thinking-Hard-So-Hard.html">为什么独立思考这么难？——谈谈心理学的成因，并分享俺的经验</a>》</p><h3 id="走出心理舒适区的重要性">◇“走出心理舒适区”的重要性</h3><p>几乎所有的个人能力，如果要想得到提升，都需要跳出“心理舒适区”。</p><p>比如说那些优秀的体操运动员，他们需要不断练习自己【不熟悉】的动作，这样才能提高；反之，如果某个体操运动员总是练习自己最拿手的动作，那是没有长进的（或者说，长进非常有限）。</p><h3id="为啥大部分人都无法走出心理舒适区">◇为啥大部分人都【无法】走出心理舒适区？</h3><p>首先，人都是惰性的。<br />停留在心理舒适区，极大地满足了人的惰性。<br />要离开心理舒适区，就要克服这种惰性；这通常需要动用意志力，而且需要一定的技巧。</p><p>大多数人的意志力是偏弱的；即使是少数意志力较强的人，其中还有一定比例是缺乏运用技巧的。</p><p>如果你对这个结论有所怀疑，不妨去观察一下：大部分人在闲暇时间都在干嘛。你就会发现：大部分人都在用一些【轻松的/消遣性的/娱乐性的】活动来打发时光。</p><h3 id="两者的关系-4">◇两者的关系</h3><p>前面说过：折腾的往往是自己不熟悉的领域，所以折腾的过程往往会碰到一些障碍和困难。</p><p>而搞定这些障碍和困难，通常需要你跳到“心理舒适区”【之外】。</p><p>所以，经常折腾的人，就经常需要挑战困难和障碍，于是也就有更多机会去练习——如何跳出心理舒适区。</p><h2 id="聊聊那些不折腾的理由或借口">★聊聊那些“不折腾”的理由或借口</h2><p>说完了“心理舒适区”，顺便列几个反面教材——关于“不折腾的理由或借口”。</p><p>常见的理由/借口有如下几种：</p><h3 id="抱怨无用功">◇抱怨“无用功”</h3><p>很多人觉得：如果折腾某个东西，最后没有搞出来（失败了），那就白白浪费了时间，成为“无用功”。</p><p>这个理由非常有迷惑性（尤其是在天朝这个功利主义非常盛行的社会）。</p><p>实际情况是：即使你折腾某个东西最后失败了，也【不会】是无用功。</p><p>因为在这个过程中，你会有很多收获——包括前面提到的几种能力提升和知识面的拓展。</p><h3 id="抱怨时间不够">◇抱怨“时间不够”</h3><p>这可能是最常见的一种抱怨（借口）——说自己工作太忙，没有空闲的时间去折腾其它东西。</p><p>首先，拿网上流传的一句话来反驳此借口——时间就像乳沟，只要你愿意挤，总是有的。</p><p>然后，来分析一下俺博客的读者群，应该大部分是学生或者白领/蓝领。</p><p><strong>对于在校的学生</strong></p><p>（不管是大学生还是中学生）肯定是是有闲暇时间的（比如寒暑假）。<br />即使是高三年很忙，只要等高考结束，之后那个假期总归是空闲的。</p><p><strong>对于工作中的上班族</strong></p><p>很多人抱怨“加班”占用时间。<br />试问：有多少公司是一年365天，天天都加班（完全没有周末和节假日）；而且每天（无一例外）都加班到深夜，一回家就上床睡觉，然后一觉醒来就又去上班。这样的公司，就算有，占总体的比例肯定也是微乎其微的。</p><p>还有一些人抱怨“养小孩”占用时间。<br />这种借口同样是站不住脚滴。“养小孩”确实会占用一些业余时间，但比例肯定达不到100%；而且特别占时间的，通常是小孩刚出生的开头三五年。<br />所以，绝大部分上班族肯定是有闲暇时间的。</p><h3 id="抱怨精力不够">◇抱怨“精力不够”</h3><p>另一种常见的抱怨是：上班已经很累，下班回家哪还有精力去折腾其它东西。<br />首先，很多人发这种抱怨，有夸大其辞的嫌疑。<br />其次，退一步讲，就算有【少数工作】是每天都很累，以至于每天下班回家都精疲力竭。但你至少还有周末的双休日可用啊。每年有52个星期，单算双休日就有一百多天呢！（这还没算上国定假日）</p><h3 id="抱怨技能不够">◇抱怨“技能不够”</h3><p>有这种抱怨的人，要么是找借口，要么是太缺乏自信 。在如今这个互联网很普及的时代（天朝网民据说已经6亿或7亿了），很多需要折腾的事物，都可以在网上找到教程，甚至是手把手的傻瓜教程。有了教程（尤其是傻瓜教程），折腾的门槛已经大大降低了。<br />（至于如何在网上找到教程，可以参考《如何挖掘网络资源》系列博文）<br />当然啦，即使有了再完备的教程，你依然会在折腾的过程中碰到一些困难和障碍。所以“教程的存在”并【不会】影响你锻炼“解决问题的能力”。</p><h3 id="小结">◇小结</h3><p>上述所有这些，如果是【理由】的话，那都是不成立的；如果是【借口】的话，那都可以归咎于——不愿意离开心理舒适区。</p><p>为啥很多人都在找借口捏？因为大部分人【不】愿意承认：自己总是停留在心理舒适区；并且大部分人更【不】愿意承认：自己无法离开心理舒适区。所以，他们需要找各种借口来掩饰。</p><h2 id="俺写本文的动机">★俺写本文的动机</h2><p>在本文最后，稍微透露一下俺写本文的动机。</p><p>可能大多数读者会【误以为】——俺写这篇，是想劝那些不喜欢折腾的人改变习惯，多多折腾。</p><p>NO，NO，NO！这【不是】俺的本意！</p><p>前面说了：那些不喜欢折腾的人，无法（难以）跳出“心理舒适区”。这是由他们的【本性】（意志力、性格、观念、心态...）决定的。而一个人的本性，是【无法】轻易改变滴。所以，俺当然【不指望】：靠这样一篇短短的博文，就能改变他们的本性。</p><p>那俺为啥还要写这篇博文捏？写此文的目的是：鼓励那些已经走上折腾之路的同学们，希望他们能在这条路上走得足够远。【好好折腾，天天向上】</p><hr /><p style="border: 2px solid black; padding: 10px; margin: 20px; background-color: #f9f9f9;"><strong>版权声明</strong><br>本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者编程随想和本文原始地址：https://program-think.blogspot.com/2017/04/The-Importance-of-Zheteng.html</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-线程池部分源码&amp;API总结</title>
    <link href="/2025/07/18/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2025/07/18/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程池简介">线程池简介</h2><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。</p><p>Java线程池按照以下步骤处理任务：</p><ol type="1"><li>优先使用核心线程</li><li>核心线程满了使用工作队列</li><li>工作队列满了使用非核心线程</li><li>都满了执行拒绝策略</li></ol><figure><img src="https://s21.ax1x.com/2025/07/16/pV1bCGD.png"alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption></figure><p><strong>线程池在系统中的应用</strong>：</p><ul><li>Web服务器处理HTTP请求</li><li>数据库连接和IO操作，例如查询和插入数据库、文件读写操作、Netty实用线程池处理网络事件</li><li>异步任务处理，例如 RabbitMQ、Kafka消息队列的消费者使用线程池处理消息</li><li>计算密集场景，例如并行计算：Fork/Join框架、parallelstreams底层使用线程池</li></ul><h2 id="threadpoolexecutor基本源码">ThreadPoolExecutor基本源码</h2><figure><img src="https://s21.ax1x.com/2025/07/16/pV1bixH.png"alt="ThreadPoolExecutor执行示意图" /><figcaption aria-hidden="true">ThreadPoolExecutor执行示意图</figcaption></figure><p>ThreadPoolExecutor执行<code>execute</code>方法分为四种情况，依据当前运行的线程数量：</p><ol type="1"><li>少于<code>corePoolSize</code></li><li>大于等于<code>corePoolSize</code>，且阻塞队列还没满</li><li>阻塞队列已经满了</li><li>线程池能容纳的最大线程数也不够了</li></ol><p>其中1，2步会先获取全局锁，然后创建新线程。这样设计的目的是尽量减少获取锁的次数，提高效率。</p><p><strong>预热</strong>，指的是当前运行的线程数大于等于<code>corePoolSize</code>，此时几乎所有的获取线程操作都会走第二步，排队等着拿到线程。注意核心线程是始终保持活动的，而非核心线程只在任务高峰期创建，空闲一段时间<code>keepAliveTime</code>后就会被销毁。</p><p>不管是核心线程还是非核心线程，一旦被创建并成功加入线程池的<code>workers</code>集合中，它们都会进入一个循环——反复从任务队列中获取任务来执行，直到被终止为止。</p><h3 id="线程池状态">线程池状态</h3><p>这一部分属于<code>ThreadPoolExecutor</code>的基本字段，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>; <span class="hljs-comment">// 也就是29</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>; <br><span class="hljs-comment">// COUNT_MASK 是掩码常量，用于移位</span><br><span class="hljs-comment">// COUNT_MASK 的低29位全是1，其余为0</span><br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><p>用一个原子整数<code>ctl</code>的<code>高3位</code>保存<strong>线程池的状态</strong><code>runState</code>；<code>低29位</code>保存<code>workerCount</code>，表示有效的线程数量，即<strong>已经启动但还没有结束的线程数量</strong>。</p><p><code>runState</code><strong>是线程池生命周期控制的核心，其取值包括</strong>：</p><ul><li><code>RUNNING</code>（<strong>运行中</strong>）：接受新任务，并处理队列中的任务。</li><li><code>SHUTDOWN</code>（<strong>关闭中</strong>）：不接受新任务，但处理队列中已有的任务。</li><li><code>STOP</code>（<strong>停止</strong>）：不接受新任务，不处理队列任务，并中断正在执行的任务。</li><li><code>TIDYING</code>（<strong>整理中</strong>）：所有任务都已终止，workerCount为 0，负责转入该状态的线程将执行<code>terminated()</code>钩子方法。</li><li><code>TERMINATED</code>（<strong>已终止</strong>）：terminated()钩子方法已执行完毕。</li></ul><p>这些状态的数值顺序很重要，用于实现有序比较。runState的值是单调递增的，但不会保证每个状态都会经历一遍。</p><hr /><p><strong>状态转移路径如下：</strong></p><ul><li><code>RUNNING</code> → <code>SHUTDOWN</code>：调用<code>shutdown()</code> 方法。</li><li><code>RUNNING</code> 或 <code>SHUTDOWN</code> →<code>STOP</code>：调用 <code>shutdownNow()</code> 方法。</li><li><code>SHUTDOWN</code> →<code>TIDYING</code>：当任务队列为空且线程池为空时。</li><li><code>STOP</code> → <code>TIDYING</code>：当线程池为空时。</li><li><code>TIDYING</code> →<code>TERMINATED</code>：<code>terminated()</code> 钩子方法执行完毕时。调用 <code>awaitTermination()</code> 等待的线程会在状态变为<code>TERMINATED</code> 时返回。</li></ul><hr /><p><strong>用于装箱/拆箱<code>ctl</code>的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~COUNT_MASK; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; COUNT_MASK; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p><code>COUNT_MASK</code>的低 29 位全是<code>1</code>，逐一来看：</p><ul><li><code>runStateOf(int c)</code>取出整数<code>c</code>的高 3位，即线程池的状态<code>runState</code>；</li><li><code>workerCountOf(int c)</code>取出低 29 位，即有效线程数量；</li><li><code>ctlOf</code>:<code>rs</code>代表线程池状态，<code>wc</code>代表有效线程的数量，按位或即可拼接成<code>int</code>形式的<code>ctl</code>（还没有转化成原子整数）。</li></ul><h3 id="execute">execute()</h3><p><strong>方法概述</strong></p><p><code>execute()</code>方法是线程池执行任务的入口点，它会根据当前线程池状态决定如何处理提交的任务。<strong>按优先级处理任务</strong>：</p><ol type="1"><li>优先使用核心线程</li><li>核心线程满了使用工作队列</li><li>工作队列满了使用非核心线程</li><li>都满了执行拒绝策略</li></ol><figure><img src="https://s21.ax1x.com/2025/07/16/pV1qs1g.png"alt="执行任务示意图" /><figcaption aria-hidden="true">执行任务示意图</figcaption></figure><p>已经在注释中标出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get(); <span class="hljs-comment">// 获取原子整数的int值</span><br><br>    <span class="hljs-comment">// 1. 工作线程数小于核心线程数，则创建线程并执行当前任务：</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// true表示创建核心线程</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 如果创建成功直接返回，失败则重新获取状态继续后续步骤</span><br>        c = ctl.get();<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 线程池处于RUNNING状态，尝试将任务加入队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">// 成功将任务加入队列</span><br>        <span class="hljs-comment">// 双重检查</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get(); <br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3. 队列已满，创建非核心线程处理命令</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    <span class="hljs-comment">// 4. 如果创建失败，说明线程池已饱和或关闭，执行拒绝策略</span><br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步的细节比较多，下面再补充说明几句。</p><p>第二步尝试将任务加入队列，通过判断后，继续采用<strong>双重检查</strong>的方式，目的是防止在多线程条件下的竞态条件：</p><ul><li>任务入队后线程池可能被关闭</li><li>任务入队后所有工作线程可能都终止了</li></ul><p>相应对策：</p><ul><li>重新检查线程池状态(<code>! isRunning(recheck)</code>)，如果已关闭则移除任务(<code>remove(command)</code>)并拒绝(<code>reject(command);</code>)</li><li>如果工作线程数为0，创建一个非核心线程来处理队列中的任务<code>addWorker(null, false);</code></li></ul><p>另外，关于最后当工作线程数为 0时为什么调用<code>addWorker(null, false);</code>：</p><p>因为第二步的判断条件中已经把当前任务加入了队列，所以现在需要的不是再次提交这个任务，而是确保<strong>有工作线程</strong>来处理队列中的任务，所以当最后发现工作线程数为0时，添加命令为<code>null</code>；又因为前面逻辑上我们已经"尝试过"创建核心线程了，现在应该按照正常的扩容逻辑创建非核心线程，所以第二个参数为<code>false</code>。</p><p>回顾一下线程池的设计哲学：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">核心线程 -&gt; 队列 -&gt; 非核心线程 -&gt; 拒绝策略<br></code></pre></td></tr></table></figure><p>判断到这一步发现工作线程为0，只能说明原来的核心线程死亡了，即便如此也不能破坏上边这个顺序，这里只能创建非核心线程。</p><hr /><p>最后补充一下<code>addWorker()</code>方法的简化原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// 简化版本</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>        <br>        <span class="hljs-comment">// 检查线程数限制</span><br>        <span class="hljs-keyword">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <br>        <span class="hljs-comment">// 线程数合法，创建工作线程...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>core = true</code>：检查是否超过<code>corePoolSize</code></li><li><code>core = false</code>：检查是否超过<code>maximumPoolSize</code></li></ul><p>以及<code>Worker</code>的简化工作流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化的Worker工作流程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> firstTask;  <span class="hljs-comment">// 首先执行传入的任务</span><br>        firstTask = <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 然后从队列获取任务来执行</span><br>            task.run();<br>            task = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法">构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                            <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                            TimeUnit unit,</span><br><span class="hljs-params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>    <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>            Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>：最大核心线程数，每提交到一个任务到线程池都会创建一个核心线程，直到满为止。也叫线程池的基本大小。</li><li><code>maximumPoolSize</code>：线程池可容纳的最大线程数，包含核心线程数和非核心线程数。</li><li><code>keepAliveTime</code>：非核心线程空闲后，保持存活的时间，如果空闲超过这个时间就会被销毁。核心线程即使一直空闲也不会被销毁</li><li><code>unit</code>：上面时间的单位</li><li><code>workQueue</code>：工作队列（阻塞队列）</li></ul><p>值得注意的是一共有 4个重载的构造方法，传入的参数也不同。还有两个参数在上面没有展示出来：</p><ul><li><code>RejectedExecutionHandler handler</code>：饱和策略，当队列和线程池都满了的时候，必须采用一种策略去处理提交的任务，默认情况下是抛出异常，也可以自定义。</li><li><code>ThreadFactory threadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li></ul><h2 id="静态工厂方法">静态工厂方法</h2><p>静态工厂方法提供了一些快速使用线程池模板的途径。</p><h3 id="固定大小线程池">固定大小线程池</h3><p><code>newFixedThreadPool</code>创建一个固定大小的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>nThreads</code>指定核心线程的数量</li><li>没有非核心线程，无需超时时间</li><li>阻塞队列是可选无界的，可以放任意数量的任务。链式队列通常比基于数组的队列具有更高的吞吐量，但在大多数并发应用中性能较难预测。</li></ul><p>不推荐使用。</p><h3 id="带缓存的线程池">带缓存的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                    threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无核心线程，只有非核心线程，<strong>按需创建</strong></li><li>最大空闲时间<code>60s</code></li><li><code>SynchronousQueue</code>：一个<strong>不存储元素</strong>的阻塞队列，每一个<code>put()</code>操作，必须等待另一个线程的<code>take()</code>操作配对完成，否则就会阻塞，反之亦然。</li></ul><p>适合任务比较密集，每个任务的执行时间比较短的情况。</p><h3 id="单线程线程池">单线程线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1个核心线程，无非核心线程</li><li><code>LinkedBlockingQueue</code>表现为无界</li></ul><p>适合多个任务排队进行。与自己手动创建一个线程相比，单线程线程池可以保证就算线程因为某些原因挂掉，也能立刻重新重建一个线程，保证始终有可用的线程。</p><h3 id="任务调度线程池">任务调度线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个线程池，可以调度命令在<strong>指定延迟</strong>后运行，或定期执行。</p><ul><li>参数：<code>corePoolSize</code> –保留在池中的线程数，都是核心线程</li><li>返回：新创建的调度线程池</li></ul><p>向线程池提交<strong>一次性</strong>任务的方法（重载了两个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                    <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                        <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br></code></pre></td></tr></table></figure><p>注意：任务中发生的异常会被吞掉，直接终止对应线程而不会抛出异常。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestSchedule&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSchedule</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br><br>        pool.schedule(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;Task1&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br>        pool.schedule(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;Task2&quot;</span>);<br>        &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">10</span>:<span class="hljs-number">20</span>:<span class="hljs-number">13.902</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestSchedule</span> - start<br><span class="hljs-number">10</span>:<span class="hljs-number">20</span>:<span class="hljs-number">14.918</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> c<span class="hljs-selector-class">.TestSchedule</span> - Task2<br><span class="hljs-number">10</span>:<span class="hljs-number">20</span>:<span class="hljs-number">14.918</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.TestSchedule</span> - Task1<br></code></pre></td></tr></table></figure><p>也可以设置<strong>周期任务</strong>：（只能是无返回值的任务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                <span class="hljs-type">long</span> initialDelay,<br>                                                <span class="hljs-type">long</span> period,<br>                                                TimeUnit unit);<br></code></pre></td></tr></table></figure><p>提交一个周期性操作，该操作首先在给定的初始延迟后启用，然后周期性被调用。</p><p><code>period</code>指的是从上一次任务的开始时间到下一次任务的开始时间之间的间隔。如果人物本身的执行时间大于这个间隔，那么会在上一个任务结束后马上执行下一个，不会重叠。</p><p>设置固定延时<code>delay</code>的方法，<code>delay</code>是上一个任务的终止到下一个任务的开始之间的固定时间间隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br></code></pre></td></tr></table></figure><hr /><h2 id="线程池api">线程池API</h2><h3 id="向线程池提交任务">向线程池提交任务</h3><p>从JDK5开始，工作单元与执行机制分离开来。工作单元包括：<code>Runnable</code>和<code>Callable</code>，执行机制由<code>Executor</code>框架提供。</p><p><code>execute()</code>用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功。输入的任务是一个<code>Runnable</code>实例。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 容量为1的队列</span><br>);<br><br><span class="hljs-comment">// 提交第一个任务：创建核心线程</span><br>executor.execute(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Task 1 by core thread&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Core thread dies!&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><hr /><p><code>submit()</code>用于提交需要返回值的任务，线程池返回一个<code>Future</code>类型的对象。<code>get()</code>方法会<strong>阻塞当前线程直到任务完成</strong>，也可以设置超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 容量为1的队列</span><br>        );<br>        Future&lt;String&gt; res = executor.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br><br>        System.out.println(res.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一次性提交多个任务，返回所有结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p><code>invokeAll()</code>方法可以<strong>一次性提交一组任务</strong>（只能是Callable），并等待所有任务执行完成，然后返回包含每个任务执行结果的Future对象集合。适合有一批并发任务需要同时提交，然后在所有任务都完成之后统一处理结果的场合。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 容量为1的队列</span><br>        );<br><br>        List&lt;Future&lt;Object&gt;&gt; futures = executor.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Task 1 by core thread&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK1&quot;</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Task 2 by core thread&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK2&quot;</span>;<br>                &#125;<br>        ));<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        futures.forEach((res) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(res.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一次提交多个任务，返回最快的结果</strong></p><p><code>invokeAny</code>：提交所有任务，返回最快结果。<strong>只有一个返回值</strong>。返回结果后，其他任务立刻取消。</p><h3 id="关闭线程池">关闭线程池</h3><ul><li><code>shutdown()</code>：拒绝新的任务提交，已经提交的任务（包括正在执行的和等待执行的）会继续处理完。线程池会等待所有任务执行完毕后关闭，是一种<strong>温和的关闭方式</strong>。</li><li><code>shutdownNow()</code>：不会等待正在执行的任务完成，强制关闭。</li></ul><p>调用两者任意一个，<code>isShutdown</code>就会返回<code>true</code>。当所有的任务都关闭以后，调用<code>isTerminaed</code>方法会返回<code>true</code>。</p><h2 id="合理配置线程池">合理配置线程池</h2><ul><li><strong>CPU密集型任务</strong>：主要耗费 CPU 资源，几乎不涉及 I/O操作，CPU始终在执行指令，线程基本不会被阻塞。例如：数学计算、图像处理、加解密等。线程数推荐：核数+1</li><li><strong>IO密集型任务</strong>：任务大部分时间在等待外部 I/O设备响应，例如读取大文件、HTTP请求、数据库查询和写入。线程经常阻塞，应当尽量多开线程。</li><li><strong>混合型任务</strong>：将其拆分成CPU密集型任务和IO密集型任务</li><li>建议使用有界队列</li><li>优先级不同的任务可以使用优先级队列处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-synchronized关键字</title>
    <link href="/2025/07/17/JUC-synchronized/"/>
    <url>/2025/07/17/JUC-synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="共享问题">共享问题</h2><ul><li>多个线程访问<strong>共享资源</strong>，进行读写操作时发生指令的交错就会发生问题。</li><li>一段代码块内如果存在对共享资源的读写操作，称这段代码块为<strong>临界区</strong>。</li><li>多个代码在临界区内运行，由于代码的执行序列不同而导致结果无法预测，称之发生了<strong>竞态条件</strong>。</li></ul><p>如何避免临界区的互斥条件的发生？两种方法：</p><ol type="1"><li>阻塞式的解决方法：<code>synchronized</code> <code>Lock</code></li><li>非阻塞式的：原子变量</li></ol><h2 id="synchronized">synchronized</h2><p><code>synchronized</code>：对象锁，同一时刻只能有一个线程持有对象锁，无法获取这个锁的线程就会被阻塞。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br>    临界区<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.SynchronizedTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>        t2.join();<br>        t1.join();<br><br>        log.debug(<span class="hljs-string">&quot;counter = &#123;&#125;&quot;</span>, counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为<code>0</code>。</p><p><strong>为什么锁必须是引用数据类型</strong>：<code>synchronized</code>的底层机制依赖于对象头中的<code>Monitor</code>（监视器）锁结构。每个Java对象（引用类型）都有一个对象头，包含一些元信息，其中一部分用于实现锁（<code>Mark Word</code>）。基本类型没有对象头，无法存储锁的信息，JVM不支持。</p><blockquote><p>MarkWord，在64位虚拟机中占据64个比特，用于存储对象自身的运行时数据，包括堆对象布局、类型、GC状态、同步状态和身份哈希码的基本信息。</p></blockquote><hr /><p><code>synchronized</code>也可以用来修饰<strong>方法</strong>，等价于锁住了<code>this</code>对象，也就是<strong>当前实例</strong>，也就是说，每个对象实例各自有自己的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br>等价于:<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用来修饰<strong>静态方法</strong>，等价于锁住了<strong>类对象</strong>（<code>xxx.class</code>）。</p><h2 id="常见线程安全类">常见线程安全类</h2><p>这里的线程安全指：多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为：</p><ol type="1"><li>他们的每个方法是原子的</li><li>但是注意他们的多个方法的组合不是原子的</li></ol><p>常见的线程安全类如<code>String</code>、包装类都属于不可变类。以<code>String</code>为例，<code>String.substring()</code>方法返回的是一个新的<code>String</code>对象，根本没有改动原对象的值。</p><p><code>String</code>类是被<code>final</code>修饰的，如果<code>String</code>不是<code>final</code>，任何人都可以写一个子类改变<code>String</code>的行为，从而破坏它的不可变性。这样一来，原本安全可预期的<code>String</code>行为就会崩溃。</p><h2 id="复习java对象内存布局">复习：Java对象内存布局</h2><p>Java对象保存在堆中时，由以下三部分组成：</p><figure><img src="https://s21.ax1x.com/2025/05/31/pV9uJ1A.png"alt="对象的内存布局" /><figcaption aria-hidden="true">对象的内存布局</figcaption></figure><h3 id="对象头object-header">对象头（Object Header）</h3><ol type="1"><li><strong>MarkWord</strong>，在64位虚拟机中占据64个比特，用于存储对象自身的运行时数据，包括堆对象布局、类型、GC状态、同步状态和身份哈希码的基本信息</li><li><strong>KlassPointer</strong>，类型指针，指向它的类型元数据，用于确定该对象是哪个类的实例。</li><li><strong>对于数组对象，还有一块用于存储数组长度的区域</strong>。因为以后的JVM需要进行边界检查、GC需要知道对象占多大空间等等，数组长度的值是要被多次使用的，所以数组对象自身必须也保存一个长度。</li></ol><p>64位JVM的Mark Word结构：</p><figure><img src="https://s21.ax1x.com/2025/05/31/pV9Koa8.png"alt="Mark Word" /><figcaption aria-hidden="true">Mark Word</figcaption></figure><h3 id="实例数据instance-data">实例数据（Instance Data）</h3><p>实例数据是对象真正存储的有效信息，包括：</p><ul><li>从父类继承的各种类型的字段</li><li>在子类中定义的各种类型的字段</li></ul><p>如果对象没有属性字段，那么这里不会有信息。</p><h3 id="对齐填充padding">对齐填充（Padding）</h3><p>并非必要信息，起到占位符的作用，原因是Java的自动内存管理系统要求对象的起始地址必须是8 字节的整数倍，而对象的实例数据可能不满足，所以需要对齐填充一下。</p><p>至于为什么起始地址会有这个要求:[^1]</p><div class="note note-success">            <p>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</p>          </div><h2id="synchronized在monitor层面的原理">synchronized在Monitor层面的原理</h2><p>Monitor被翻译为监视器/管程，是操作系统中的一种同步机制，是一个封装了很多东西的抽象结构，可以把它看作是带有<strong>互斥锁</strong>机制和<strong>条件变量</strong>机制的对象。具备三要素：</p><ul><li>互斥锁<code>Mutex Lock</code>：保证同一时间只有一个线程进入 Monitor内执行临界区代码</li><li>等待队列<code>WaitSet</code>：存放已经进入Monitor、但因为条件不满足而等待的线程。</li><li>入口队列<code>EntryList</code>：其他尝试进入Monitor、但发现已经有线程持有锁而被阻塞的线程。</li></ul><p>每个 Java 对象都可以关联一个 Monitor对象，使用<code>synchronized</code>给对象加上互斥锁之后，如果获取锁成功，2bit锁标志位会被置为<code>10</code>，MarkWord的前62位都会被替换为指向互斥锁的指针，这个线程成为<code>Owner</code>。如果获取锁失败，这个线程就进入了Monitor的阻塞队列<code>EntryList</code>，处于<code>BLOCKED</code>阻塞状态。</p><figure><img src="https://s21.ax1x.com/2025/07/12/pVlUib8.png"alt="synchronized机制" /><figcaption aria-hidden="true">synchronized机制</figcaption></figure><p>解锁流程：按照 Monitor 的地址找到 Monitor 对象，设置 Owner 为null，唤醒队列中的 BLOCKED 线程。</p><h2id="synchronized关键字在字节码层面的原理">synchronized关键字在字节码层面的原理</h2><p>对于<strong>同步代码块</strong>，编译器会生成<code>monitorenter</code>和<code>monitorexit</code>指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (MyTest.class) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code>方法的字节码为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>ldc #<span class="hljs-number">2</span> &lt;<span class="hljs-keyword">com</span>/kzn/test/synchronous/MyTest&gt;  // 从常量池加载Class对象到栈顶<br><span class="hljs-symbol">2 </span>dup                                       // 复制栈顶的Class对象引用<br><span class="hljs-symbol">3 </span>astore_1                                  // 将复制的引用存储到局部变量<span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span>monitorenter                              // 获取监视器锁（使用栈顶的Class对象）<br><span class="hljs-symbol">5 </span>aload_1                                   // 加载局部变量<span class="hljs-number">1</span>（为monitorexit准备）<br><span class="hljs-symbol">6 </span>monitorexit                               // 释放监视器锁<br><span class="hljs-symbol">7 </span><span class="hljs-keyword">goto</span> <span class="hljs-number">15</span>                                   // 跳转到<span class="hljs-keyword">return</span>，正常结束<br><span class="hljs-symbol">10 </span>astore_2                                 // 存储异常对象到局部变量<span class="hljs-number">2</span><br><span class="hljs-symbol">11 </span>aload_1                                  // 加载监视器对象引用<br><span class="hljs-symbol">12 </span>monitorexit                              // 释放监视器锁（确保异常时也释放）<br><span class="hljs-symbol">13 </span>aload_2                                  // 重新加载异常对象<br><span class="hljs-symbol">14 </span>athrow                                   // 抛出异常<br></code></pre></td></tr></table></figure><ul><li>类锁机制：<code>ldc</code>加载了类锁对象</li><li>双重释放：<code>monitorexit</code>调用两次，保证在正常情况和异常情况都能释放。</li><li><code>monitorenter</code>消耗栈顶的对象引用</li><li><code>monitorexit</code>也需要相同的对象引用</li><li>两个<code>monitorexit</code>使用的都是同一个对象引用（局部变量1），确保了锁的获取和释放操作的对象一致性。</li></ul><p>总结：</p><ol type="1"><li>先加载锁对象到栈顶，获取到锁对象的引用</li><li>然后将锁对象的引用复制一份储存到局部变量1中</li><li>获取锁，消耗栈顶的锁对象的引用，同时将锁对象的 Mark Word的高62位替换成指向互斥锁的指针</li><li>加载局部变量1，也就是锁对象的引用，准备释放锁</li><li>释放监视器锁</li></ol>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-并发的概念和基础API</title>
    <link href="/2025/07/15/JUC-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80API/"/>
    <url>/2025/07/15/JUC-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80API/</url>
    
    <content type="html"><![CDATA[<h2 id="线程">线程</h2><h3 id="简单使用">简单使用</h3><p>目标：创建线程对象、运行线程</p><p>方式一：只用Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;run&quot;</span>);<br><br>            &#125;<br>        &#125;;<br>        thread.setName(<span class="hljs-string">&quot;ThreadTest&quot;</span>);<br>        thread.start();<br><br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：Runnable + Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadTest2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;ThreadTest2&quot;</span>);<br>        t.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thread和runnable的关系">Thread和Runnable的关系</h3><p>本质上都是重写了了<code>Runnable</code>的<code>run</code>方法。</p><p>推荐使用第二种方式，把<code>Runnable</code>和线程对象分离，因为前者更容易和线程池等API结合，而且更灵活。</p><h3 id="futuretaskthread">FutureTask+Thread</h3><p>FutureTask 间接实现了 Runnable 和 Future接口，后者可以返回执行的结果（run 方法是没有返回值的）</p><p>FutureTask 可以传入 Callable 类型的参数。Callable 的 call可以有返回值，也可以抛出异常，但是 Runnable 的 run无返回值，也不会抛出异常。。</p><p><code>FutureTask</code>的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure><p>其中泛型<code>V</code>指定将来返回值的类型。</p><p><code>FutureTask</code>的构造方法既可以只传入一个<code>Callable</code>类型（自带返回值），也可以传入一个<code>Runnable</code>和一个<code>result</code>（用来指定返回值）。前者的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span><br><span class="hljs-comment"> * given &#123;<span class="hljs-doctag">@code</span> Callable&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  callable the callable task</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the callable is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br></code></pre></td></tr></table></figure><p>传入的参数类型<code>Callable</code>是一个<strong>函数式接口</strong>，内部提供了带返回值的抽象方法<code>call</code>需要自己实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> computed result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception if unable to compute a result</span><br><span class="hljs-comment">     */</span><br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>因为 FutureTask 实现了 Runnable 接口，所以Thread的这个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable task)</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>也可以传入 FutureTask 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadTest2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;run!&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, futureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">09</span>:<span class="hljs-number">17</span>:<span class="hljs-number">22</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.ThreadTest2</span> - run!<br><span class="hljs-number">09</span>:<span class="hljs-number">17</span>:<span class="hljs-number">23</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest2</span> - <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="线程运行的原理">线程运行的原理</h2><p>每个线程由多个栈帧构成，对应当前方法。每个线程只能有一个活动栈帧。</p><p>线程的上下文切换：</p><ul><li>线程的cpu时间片用完</li><li>垃圾回收</li><li>更高优先级的线程需要运行</li><li>线程自己调用了<code>sleep</code>等方法</li></ul><p>发生线程的上下文切换时，需要cpu保存当前线程的状态，恢复另一个线程的状态。这一点要通过程序计数器来实现。程序计数器可以保存下一条jvm指令的执行地址，是线程私有的。</p><h2 id="方法">方法</h2><ul><li><code>start()</code> 让线程就绪，每个线程对象只能调用一次</li><li><code>run()</code>线程启动后会调用<code>Runnable</code>的<code>run()</code>方法</li><li><code>join()</code> 等待线程运行结束</li><li><code>yield()</code> 线程主动放弃</li></ul><h3 id="startrun">start&amp;run</h3><ul><li>假设有一个线程<code>t1</code>，如果执行命令<code>t1.run()</code>，那么实际上是由<code>main</code>主线程调用了<code>run()</code>重写的方法，而不是<code>t1</code>线程。</li><li>必须用<code>t1.start()</code>启动<code>t1</code>线程，由这个新线程调用<code>run()</code>方法。</li></ul><h3 id="sleepyield">sleep&amp;yield</h3><p><strong>sleep</strong></p><ul><li>使当前线程进入<code>TIMED_WAITING</code>状态</li><li>可以使用<code>interrupt</code>打断睡眠，强制退出睡眠模式，并且抛出异常<code>java.lang.InterruptedException: sleep interrupted</code></li><li>睡眠时间结束以后的线程未必会立刻执行，分到时间片才可以。</li><li>推荐使用<code>TimeUnit.SECONDS.sleep(1);</code>代替<code>Thread.sleep(1000)</code>，可读性更强。</li></ul><p><strong>yield</strong></p><ul><li>使当前线程进入<code>RUNNABLE</code>就绪状态，仍然可以被分配时间片。无参数。如果没有其他线程，这个线程仍然可以继续运行。</li><li>具体的实现依赖于操作系统的任务调度器</li></ul><p><strong>线程优先级</strong></p><ul><li>优先级的数字越大，表示优先级越高。优先级可以<strong>提示</strong>调度器优先执行这个线程。（不一定真的优先使用）。</li></ul><p><strong>应用</strong>：在无需锁同步的场景，使用<code>sleep</code>或者<code>yield</code>可以防止cpu 过度空转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="join">join</h3><h4 id="基本用法">基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">th.join()<br></code></pre></td></tr></table></figure><p>作用是当前线程等待线程<code>th</code>运行结束后才会继续执行后面的代码。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.JoinTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                r = <span class="hljs-number">10</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t1.join();<br>        log.debug(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">19</span>:<span class="hljs-number">34</span>:<span class="hljs-number">06</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.JoinTest</span> - <span class="hljs-attribute">r</span>: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><code>t1.join();</code>迫使主线程等待<code>t1</code>结束，赋值完成后才打印日志，因此打印结果为<code>10</code>。</p><h4 id="同步和异步">同步和异步</h4><p>上面代码的时序如下：</p><figure><img src="https://s21.ax1x.com/2025/07/07/pVMrXhF.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>何为同步？在本例中，<code>main</code>线程等待<code>t1</code>线程执行完毕返回结果之后才会继续运行，这就属于同步。反之，如果<code>main</code>不等另一个线程执行完就继续执行后面的命令，那就属于异步。</p><h4 id="最大等待时间">最大等待时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread.join(<span class="hljs-type">long</span> n)<br></code></pre></td></tr></table></figure><p>设置<strong>最大等待时间</strong>为<code>n</code>毫秒</p><h3 id="interrupt">interrupt</h3><ul><li><code>sleep</code> <code>wait</code><code>join</code>被打断时，抛出异常，打断标志位是<code>false</code>。</li><li>正常运行的线程被打断时不会停止运行，但是会置标志位<code>isInterrupted</code>为<code>true</code>。</li><li><code>isInterrupted()</code>获取标志位，并且不会清除标志位；<code>Interrupted()</code>获取标志位同时清除标志位，置为<code>false</code></li></ul><h2 id="守护线程">守护线程</h2><p>默认情况下，Java线程需要等待所有的线程都运行结束后才会结束。但是，守护线程除外，不管守护线程的代码执行完没有，只要非守护线程走完了，程序就会结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t1.setDaemon(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>垃圾回收器线程就是一种守护线程。如果程序停止了，垃圾回收线程也会被停止。</p><h2 id="线程的状态">线程的状态</h2><p>五种状态的说法：</p><figure><img src="https://s21.ax1x.com/2025/07/08/pVMO534.png" alt="五种状态" /><figcaption aria-hidden="true">五种状态</figcaption></figure><p>六种状态的说法：</p><p><img src="https://s21.ax1x.com/2025/07/08/pVMXY24.png" /></p><p>操作系统层面的阻塞属于<code>RUNNABLE</code>的类别。</p><h2 id="wait-notify">wait notify</h2><h3 id="原理">原理</h3><p><img src="https://s21.ax1x.com/2025/07/12/pVlUib8.png" /></p><ul><li>如果某个线程拿到了某个对象的 Monitor 锁，就会成为Owner。</li><li>如果线程获取了锁，但发现<strong>程序逻辑上无法继续执行，必须等待某个条件的变化</strong>，需要我们主动调用<code>wait()</code>进入<code>WaitSet</code>，当逻辑满足时调用<code>notify()</code>唤醒。</li><li><code>BLOCKED</code> <code>WAITING</code>都处于阻塞状态，不占用 CPU时间片。</li><li><code>BLOCKED</code>在锁释放的时候<strong>被唤醒</strong>；<code>WAITING</code>在执行<code>notify()</code>或者<code>notifyAll()</code>时被唤醒，唤醒后的线程会进入<code>EntryList</code>阻塞队列重新竞争。</li></ul><h3 id="api">API</h3><ul><li><code>obj.wait()</code>让已经获取锁的线程进入<code>WaitSet</code>等待</li><li><code>obj.wait(long n)</code>设置一个超时时间<code>n</code>毫秒，超时强制唤醒</li><li><code>obj.notify()</code>从正在等待的线程中挑一个唤醒，不保证唤醒顺序</li><li><code>obj.norifyAll()</code>唤醒所有正在等待的线程</li></ul><p>必须获得锁对象之后，才能调用这几个方法。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestWait&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWait</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;第一个线程&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t1被唤醒&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;第二个线程&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t2被唤醒&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;唤醒其他线程&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            lock.notify(); <span class="hljs-comment">// 唤醒一个线程</span><br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">39.383</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestWait</span> - 第一个线程<br><span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">39.385</span> <span class="hljs-selector-attr">[t2]</span> c<span class="hljs-selector-class">.TestWait</span> - 第二个线程<br><span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40.387</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestWait</span> - 唤醒其他线程<br><span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40.387</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestWait</span> - t1被唤醒<br></code></pre></td></tr></table></figure><p>这时程序还没有推出，因为<code>t2</code>没有被唤醒。如果执行的是<code>lock.notifyAll();</code>程序可以正常结束。</p><p><code>wait</code>和<code>sleep</code>的重要区别是前者会释放当前的锁，而后者不会。</p><h3 id="sleep和wait的区别">sleep和wait的区别</h3><ul><li>sleep 是 Thread 方法，wait 是 Object 方法</li><li>sleep 不需要和<code>synchronized</code>配合使用，但是 wait需要和它配合使用</li><li><code>wait</code>会释放对象锁</li><li>它们的状态都是<code>TIMED_WAITING</code></li></ul><h3 id="虚假唤醒">虚假唤醒</h3><p>在 Java 多线程编程中，虚假唤醒（Spurious Wakeup）是一个非常重要但容易被忽视的概念。</p><p>虚假唤醒指的是：线程在没有被<code>notify()</code>或<code>notifyAll()</code>显式唤醒的情况下，突然从<code>wait()</code>返回了。</p><p>换句话说，线程明明没有被人叫醒，也没有超时，却自己醒来了。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">if</span> (!condition) &#123;<br>        lock.wait();  <span class="hljs-comment">// ❌ 只判断一次</span><br>    &#125;<br>    <span class="hljs-comment">// 条件成立，开始执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为值判断了一次条件，所以被错误唤醒之后，不管条件是否成立都会继续执行。解决方法是把<code>if</code>换成<code>while</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!condition) &#123;<br>        lock.wait();  <span class="hljs-comment">// 被挂起等待唤醒</span><br>    &#125;<br>    <span class="hljs-comment">// 条件成立，开始执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="park-unpark">park unpark</h2><p>都是<code>LockSupport.java</code>提供的两个底层线程阻塞/唤醒方法，它们是构建高级并发工具（如AQS、ReentrantLock、CountDownLatch等）的基础。相比<code>wait()</code>/<code>notify()</code>，它们更灵活、低级且<strong>不需要同步块</strong>。</p><p><code>unpark</code>既可以在<code>park</code>之前调用，也可以之后。如果先调用<code>unpark(t)</code>，再<code>park()</code>，这个线程<strong>不会被挂起</strong>。</p><h3 id="用法">用法</h3><ul><li><code>LockSupport.park()</code>挂起<strong>当前</strong>线程</li><li><code>LockSupport.unpark(thread)</code>恢复<strong>指定</strong>线程</li></ul><p>用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Park&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;Child thread parking...&quot;</span>);<br>            LockSupport.park();  <span class="hljs-comment">// 阻塞在这里</span><br>            log.debug(<span class="hljs-string">&quot;Child thread resumed!&quot;</span>);<br>        &#125;);<br><br>        t.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 主线程睡 1 秒</span><br><br>        log.debug(<span class="hljs-string">&quot;Main thread unparking child...&quot;</span>);<br>        LockSupport.unpark(t); <span class="hljs-comment">// 唤醒子线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">12.106</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.Park</span> - Child thread parking...<br><span class="hljs-number">20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">13.119</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.Park</span> - Main thread unparking child...<br><span class="hljs-number">20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">13.119</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.Park</span> - Child thread resumed!<br></code></pre></td></tr></table></figure><h3 id="原理-1">原理</h3><p>每个线程内部都有一个“许可标志”：</p><ul><li>初始为<code>false</code></li><li><code>park()</code>调用时检查许可：</li><li>为<code>false</code>→ 阻塞</li><li>为<code>true</code>→ 消耗许可，继续执行</li><li><code>unpark(thread)</code>：设置该线程的许可为<code>true</code></li></ul><p>所以如果先调用<code>unpark</code>，该线程的许可已经为<code>true</code>，调用<code>park</code>不会再阻塞线程。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战篇-探店</title>
    <link href="/2025/07/02/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E6%8E%A2%E5%BA%97/"/>
    <url>/2025/07/02/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E6%8E%A2%E5%BA%97/</url>
    
    <content type="html"><![CDATA[<h2 id="查询blog内容">查询blog内容</h2><ul><li>tb_blog: 文字部分</li><li>tb_blog_comments: 评论部分</li></ul><p>easy！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userServiceImpl;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span>(blog == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;博客不存在&quot;</span>);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userServiceImpl.getById(userId);<br>        blog.setName(user.getNickName());<br>        blog.setIcon(user.getIcon());<br>        <span class="hljs-keyword">return</span> Result.ok(blog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="点赞功能">点赞功能</h2><p>目标：</p><ul><li>实现一人<strong>最多点一个赞</strong>，再次点击<strong>取消点赞</strong></li><li>如果已经点赞，则点赞按钮高亮显示，前端已经实现</li></ul><p>实现步骤：</p><ol type="1"><li>给 Blog类添加一个<code>isLike</code>字段用于记录当前访问的用户是否已经点过赞，利用Redis 的 SET 集合判断是否点赞过。</li><li>分页查询时，查询set集合有没有用户id，代表了用户是否已经点过赞，把结果赋值给<code>isLike</code>字段</li><li>点击某一篇笔记的详情时，查询 set集合有没有用户id，代表了用户是否已经点过赞，把结果赋值给<code>isLike</code>字段</li><li>由<code>isLike</code>决定每次点击是增加点赞数还是取消点赞。增加点赞数：先修改数据库存储的<code>liked</code>列的数值减一，然后加入Redis 的set 集合。取消点赞：同样先修改数据库，再动缓存。</li></ol><p>用户点击点赞按钮时，调用下面的控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">// 修改点赞数量</span><br>    <span class="hljs-keyword">return</span> blogService.likeBlog(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个控制器会调用下面实现类中的<code>likeBlog</code>修改点赞数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userServiceImpl;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 修改点赞数</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">LikeId</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(LikeId, userId.toString());<span class="hljs-comment">// 把用户 id 存入对应的集合</span><br>        <span class="hljs-comment">// 判断有没有点赞过</span><br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isMember)) &#123;<br>            <span class="hljs-comment">// 更新数据库的点赞数</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>            <span class="hljs-comment">// 如果数据库更新成功，就把用户 id 记录到 Redis里面</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                stringRedisTemplate.opsForSet().add(BLOG_LIKED_KEY + id, userId.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 用户已经点过赞了</span><br>            <span class="hljs-comment">// 修改数据库</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                stringRedisTemplate.opsForSet().remove(BLOG_LIKED_KEY + id, userId.toString());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="显示点赞用户列表">显示点赞用户列表</h2><h3 id="基本实现">基本实现</h3><p>按照点赞时间显示最先5个点赞的用户。为了按照时间排序，需要用到<strong>有序列表</strong>(SortedSet)，根据<code>score</code>的值排序。</p><p>把<strong>时间戳</strong>作为<code>score</code>，把用户 id作为<code>member</code>保存到 Redis 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringRedisTemplate.opsForZSet().add(LikeId, userId.toString(), System.currentTimeMillis());<br></code></pre></td></tr></table></figure><p>判断用户是否点过赞的思路是先尝试获取用户的<code>score</code>，如果获取不到说明用户没有点过赞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(LikeId, userId.toString());<span class="hljs-comment">// 通过 key 和 member 尝试获取 score</span><br></code></pre></td></tr></table></figure><p>然后判断<code>score</code>是否为<code>null</code>即可。</p><p>从有序列表查询前五名的思路的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().rangeByScore(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>注意，这里查询到返回的<strong>具体实现类</strong>是<code>java.util.LinkedHashSet</code>，是<strong>有序</strong>的。在Redis 查询时，Spring 会把从 Redis查询出来的顺序按顺序加入到<code>LinkedHashSet</code>中，它是一种有序的SET集合，<strong>保留了元素的插入顺序</strong>（所以说Set 集合不一定是无序的）。</p><p>这里泛型是<strong>字符串</strong>类型，需要再解析成<code>Long</code>类型。目前为止的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br><span class="hljs-comment">// 查询用户 id</span><br>Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().rangeByScore(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>List&lt;Long&gt; LikeList = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br><span class="hljs-comment">// 根据 id 列表获取用户列表</span><br>List&lt;User&gt; users = userServiceImpl.listByIds(LikeList);<br><span class="hljs-comment">// 3. 返回 UserDTO 列表</span><br></code></pre></td></tr></table></figure><p>还差最后一步：<strong>把<code>User</code>列表转换成<code>UserDTO</code>列表</strong>。可以考虑使用<strong>流式编程</strong>。如果是处理单个用户，方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>BeanUtils.copyProperties(user, userDTO);<br></code></pre></td></tr></table></figure><p>现在处理多个用户，只需要让<code>map</code>返回每一个用户的<code>UserDTO</code>对象。使用<code>Stream</code>的<code>map()</code>操作可以对每个元素进行转换，最后用<code>collect()</code>收集结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = userServiceImpl.listByIds(LikeList);<br><span class="hljs-comment">// 3. 返回 UserDTO</span><br>List&lt;UserDTO&gt; userDTOs = users.stream()<br>        .map(user -&gt; &#123;<br>            <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>            BeanUtils.copyProperties(user, userDTO);<br>            <span class="hljs-keyword">return</span> userDTO;<br>        &#125;)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>这一部分的完整代码如下：</p><p><code>BlogController.java</code>控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询文章的点赞用户top5集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 文章 ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含点赞集合的 Result 结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>queryBlogLikes</code>的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询指定文章的点赞集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 文章 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含点赞用户的前五名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 查询用户 id</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 避免 top5 空指针导致的异常，提高健壮性</span><br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br><br>    List&lt;Long&gt; LikeList = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 根据 id 列表获取用户列表</span><br>    List&lt;User&gt; users = userServiceImpl.listByIds(LikeList);<br>    <span class="hljs-comment">// 3. 返回 UserDTO</span><br>    List&lt;UserDTO&gt; userDTOs = users.stream()<br>            .map(user -&gt; &#123;<br>                <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>                BeanUtils.copyProperties(user, userDTO);<br>                <span class="hljs-keyword">return</span> userDTO;<br>            &#125;)<br>            .collect(Collectors.toList());<br><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOs);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="改进-mysql查询结果顺序问题">改进-MySQL查询结果顺序问题</h3><p>举个例子，执行下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_seckill_voucher <span class="hljs-keyword">where</span> voucher_id <span class="hljs-keyword">in</span> (<span class="hljs-number">13</span>, <span class="hljs-number">12</span>) <br></code></pre></td></tr></table></figure><p>查询顺序是<code>13</code>或<code>12</code>，但是返回顺序可能是先<code>13</code>后<code>12</code>，这是因为默认情况下<strong>数据库查询不保证返回顺序</strong>。</p><p>一种解决方法是添加子句<code>ORDER BY FIELD(voucher_id, 5, 1)</code>，意思是按照指定的<code>voucher_id</code>顺序排序：先显示<code>voucher_id = 5</code>的记录，再显示<code>voucher_id = 1</code>的记录。</p><hr /><p>如果不想修改数据库的查询操作的话，也可以通过手动修改查询结果来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Long&gt; LikeList = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br><span class="hljs-comment">// 根据 id 列表获取用户列表</span><br>List&lt;User&gt; users = userServiceImpl.listByIds(LikeList);<br><span class="hljs-comment">// 按照 LikeList 里用户 id 的顺序对查询得到的结果进行排序，防止乱序</span><br>Map&lt;Long, User&gt; userMap = users.stream()<br>        .collect(Collectors.toMap(User::getId, Function.identity()));<br><br><span class="hljs-comment">// 返回 UserDTO</span><br>List&lt;UserDTO&gt; userDTOs = LikeList.stream()<br>        .map(userMap::get)<br>        .filter(Objects::nonNull)           <span class="hljs-comment">// 过滤可能的空值</span><br>        .map(user -&gt; &#123;<br>            <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>            BeanUtils.copyProperties(user, userDTO);<br>            <span class="hljs-keyword">return</span> userDTO;<br>        &#125;)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>逐行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Long, User&gt; userMap = users.stream()<br>        .collect(Collectors.toMap(User::getId, Function.identity()));<br></code></pre></td></tr></table></figure><p>创建一个映射关系<code>userMap</code>，用来把用户 id构成列表映射成用户实体类构成的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;UserDTO&gt; userDTOs = LikeList.stream()<br>        .map(userMap::get)<br>        .filter(Objects::nonNull)           <span class="hljs-comment">// 过滤可能的空值</span><br>        .map(user -&gt; &#123;<br>            <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>            BeanUtils.copyProperties(user, userDTO);<br>            <span class="hljs-keyword">return</span> userDTO;<br>        &#125;)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>分为5步：</p><ol type="1"><li>把<code>LikeList</code>作为<strong>源</strong>，<code>Stream</code>会按照<strong>源集合的顺序</strong>逐个处理元素</li><li>对于每个用户 id，通过<code>userMap.get(id)</code>把 id映射成用户实体类的列表</li><li>过滤不存在的<code>null</code>用户</li><li>把用户类组成的列表中的每一个<code>User</code>对象转换成<code>UserDTO</code>对象</li><li>收集结果，构成符合要求的列表返回</li></ol><p>修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询指定文章的点赞集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 文章 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含点赞用户的前五名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id; <span class="hljs-comment">// blog:liked:23</span><br>    <span class="hljs-comment">// 查询用户 id</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 避免 top5 空指针导致的异常，提高健壮性</span><br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br><br>    List&lt;Long&gt; LikeList = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 根据 id 列表获取用户列表</span><br>    List&lt;User&gt; users = userServiceImpl.listByIds(LikeList);<br>    <span class="hljs-comment">// 按照 LikeList 里用户 id 的顺序对查询得到的结果进行排序，防止乱序</span><br>    Map&lt;Long, User&gt; userMap = users.stream()<br>            .collect(Collectors.toMap(User::getId, Function.identity()));<br><br>    <span class="hljs-comment">// 返回 UserDTO</span><br>    List&lt;UserDTO&gt; userDTOs = LikeList.stream()<br>            .map(userMap::get)<br>            .filter(Objects::nonNull)           <span class="hljs-comment">// 过滤可能的空值</span><br>            .map(user -&gt; &#123;<br>                <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>                BeanUtils.copyProperties(user, userDTO);<br>                <span class="hljs-keyword">return</span> userDTO;<br>            &#125;)<br>            .collect(Collectors.toList());<br><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOs);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关注功能">关注功能</h2><h3 id="关注和取关">关注和取关</h3><p>借助数据库里的一个中间表：<code>tb_follow</code>,一共四个字段：</p><ul><li><code>id</code>自增主键</li><li><code>user_id</code>用户id</li><li><code>follow_user_id</code>关注的用户的id</li><li><code>create_time</code>创建时间</li></ul><p><strong>关注、取关</strong>，就是对这张表的<strong>插入</strong>和<strong>删除</strong>。</p><p>完整的控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/follow&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IFollowService followService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关注/取关功能</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId 对方的用户 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isFollow 当前的状态，如果是关注则下一步取关，如果是没关注则下一步关注</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;<br>        <span class="hljs-keyword">return</span> followService.follow(followUserId, isFollow);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>        <span class="hljs-keyword">return</span> followService.isFollow(followUserId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    FollowMapper followMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关注/取关功能</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId 对方的用户 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isFollow     当前的状态，如果是 true 则下一步关注，如果是 false 则下一步取关</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-keyword">if</span> (isFollow) &#123;<br>            <span class="hljs-comment">// 关注 insert tb_follow</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 取关 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>            remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否已经关注</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId(); <span class="hljs-comment">// 获取登录用户</span><br><br>        <span class="hljs-comment">// SELECT EXISTS(SELECT 1 FROM tb_follow WHERE user_id = #&#123;userId&#125; AND follow_user_id = #&#123;followUserId&#125;)</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isFollow</span> <span class="hljs-operator">=</span> followMapper.isFollow(userId, followUserId);<br><br>        <span class="hljs-keyword">return</span> Result.ok(isFollow);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个技巧：“判断是否已经关注”，用的是SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">EXISTS</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">FROM</span> tb_follow <br><span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> #&#123;userId&#125; <br><span class="hljs-keyword">AND</span> follow_user_id <span class="hljs-operator">=</span> #&#123;followUserId&#125; <br>)<br></code></pre></td></tr></table></figure><p>这样做效率最高. 用 Mapper 来完成这个语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FollowMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Follow&gt; &#123;<br>    <span class="hljs-meta">@Select(&quot;SELECT EXISTS(SELECT 1 FROM tb_follow WHERE user_id = #&#123;userId&#125; AND follow_user_id = #&#123;followUserId&#125;)&quot;)</span><br>    Boolean <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@Param(&quot;followUserId&quot;)</span> Long followUserId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后向<code>FollowServiceImpl</code>注入<code>FollowMapper</code>。</p><h3 id="共同关注">共同关注</h3><p>类似的功能有主页上显示“你关注的某某人也关注了他/她”，实现方法有两种：</p><ol type="1"><li>数据库多表查询，主要利用<code>JOIN...ON...</code>联结查询，适用于小规模</li><li>在 Twitter 等高性能场景中，通常使用<strong>Redis 的 Set类型</strong>维护关注关系。</li></ol><p>求<strong>我关注的人</strong>和<strong>目标用户粉丝的交集</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SINTER follow:me fans:targetUser<br></code></pre></td></tr></table></figure><p>另一个功能是查看目标用户和当前用户<strong>共同关注</strong>的人，这也是这次要实现的功能。</p><p>Redis 的 Set 数据结构能够求<strong>交集</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">SINTER key [key ...]<br>summary: Intersect multiple sets<br>since: 1.0.0<br>group: <span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><p>用户<code>A</code>的关注列表本质上就是<code>tb_follow</code>表中<code>user_id</code>为该用户的id的所有记录中<code>follow_user_id</code>的集合。为了利用Redis 求交集的特性，需要把关注用户的 id 加载到 Redis中。</p><p>进一步地，既然迟早要把用户的关注 id 加载到Redis，那干脆从用户点击关注的时候就把它加载进去。下面修改一下用户关注接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FOLLOW</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follow:&quot;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关注/取关功能</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> followUserId 对方的用户 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isFollow     当前的状态，如果是 true 则下一步关注，如果是 false 则下一步取关</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Result</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId(); <span class="hljs-comment">// 我的 id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">currentKey</span> <span class="hljs-operator">=</span> FOLLOW + userId;<br><br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 关注 insert tb_follow</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setUserId(userId);<br>        follow.setFollowUserId(followUserId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 存入Redis   我的userId - 关注的人的 id</span><br>            stringRedisTemplate.opsForSet().add(currentKey, String.valueOf(followUserId));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 取关 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            stringRedisTemplate.opsForSet().remove(currentKey, String.valueOf(followUserId));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-comment">// 判断是否已经关注</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId(); <span class="hljs-comment">// 获取登录用户</span><br><br>    <span class="hljs-comment">// SELECT EXISTS(SELECT 1 FROM tb_follow WHERE user_id = #&#123;userId&#125; AND follow_user_id = #&#123;followUserId&#125;)</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isFollow</span> <span class="hljs-operator">=</span> followMapper.isFollow(userId, followUserId);<br><br>    <span class="hljs-keyword">return</span> Result.ok(isFollow);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是查询目标用户和自己的共同关注对象，以<code>Result.ok(UserDTO列表)</code>的形式返回，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询目标用户和自己的共同关注对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> followUserId 关注用户的ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含共同关注用户的 UserDTO 列表的 Result 结果（如果有）或者空集合（没有）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    <span class="hljs-comment">// 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">currentUserId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">currentKEY</span> <span class="hljs-operator">=</span> FOLLOW + currentUserId;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">followKey</span> <span class="hljs-operator">=</span> FOLLOW + followUserId;<br>    <span class="hljs-comment">// 求交集</span><br>    Set&lt;String&gt; commonFollow = stringRedisTemplate.opsForSet().intersect(currentKEY, followKey);<br>    <span class="hljs-keyword">if</span> (commonFollow == <span class="hljs-literal">null</span> || commonFollow.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 解析</span><br>    List&lt;Long&gt; commonIds = commonFollow.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 查询</span><br>    List&lt;User&gt; users = userServiceImpl.listByIds(commonIds);<br>    List&lt;UserDTO&gt; userDTOs = users.stream()<br>            .map(user -&gt; &#123;<br>                <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>                BeanUtils.copyProperties(user, userDTO);<br>                <span class="hljs-keyword">return</span> userDTO;<br>            &#125;)<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(userDTOs);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="feed流的模式">Feed流的模式</h3><p>关注推送也叫<strong>Feed流</strong>，通过无限下拉刷新获取新的信息。</p><p>Feed 流的常见模式：</p><ol type="1"><li>Timeline：不做筛选，根据内容发布时间排序</li><li>智能排序：通过推荐算法</li></ol><p>Timeline模式的实现方式有三种：拉，推，推拉结合。下面分别介绍。</p><h4 id="拉模式">拉模式</h4><ul><li>含义：每个博主拥有一个发件箱，发送的信息包含时间戳。粉丝拥有收件箱，平时是空的，只有当用户查看收件箱内的内容的时候才会一个一个拉取博主发出的信息的副本，并按照时间戳排序。</li><li>优点：节省内存</li><li>缺点：每次读消息的时候都要拉取消息，延迟大，关注的人越多延迟越大。</li></ul><figure><img src="https://s21.ax1x.com/2025/07/02/pVu2YOs.png" alt="拉模式" /><figcaption aria-hidden="true">拉模式</figcaption></figure><h4 id="推模式">推模式</h4><ul><li>含义：不设置发件箱，只设置收件箱，每当博主发送信息的时候都会直接推送到粉丝的收件箱。</li><li>优点：延迟低。</li><li>缺点：内存占用高，对于大v来说粉丝量特别大，每次要发送非常多的数据。</li></ul><figure><img src="https://s21.ax1x.com/2025/07/02/pVu2wkV.png"alt="推模式，用户量少，低延迟" /><figcaption aria-hidden="true">推模式，用户量少，低延迟</figcaption></figure><h4 id="推拉结合读写混合模式">推拉结合（读写混合）模式</h4><ul><li>含义：普通小博主采用推模式，大v区别对待：活跃粉丝推模式，普通粉丝拉模式。</li></ul><p><img src="https://s21.ax1x.com/2025/07/02/pVu26X9.png" /></p><p>后面采用的都是推模式。</p><p>需求：</p><ol type="1"><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱可以满足按照时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱的数据的时候，可以实现分页查询</li></ol><h4 id="新增笔记推送到粉丝收件箱">新增笔记推送到粉丝收件箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(Blog blog)</span> &#123;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    blog.setUserId(user.getId());<br>    <span class="hljs-comment">// 保存探店博文</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> save(blog);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;新增笔记失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 查询所有粉丝 select user_id from tb_follow follow_user_id = ?</span><br>    List&lt;Follow&gt; followers = followService.query().eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, user.getId()).list();<br>    <span class="hljs-comment">// 推送</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">BlogId</span> <span class="hljs-operator">=</span> blog.getId().toString();<br>    <span class="hljs-keyword">for</span> (Follow follow : followers) &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">followerId</span> <span class="hljs-operator">=</span> follow.getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + followerId;<br>        stringRedisTemplate.opsForZSet().add(key, BlogId, System.currentTimeMillis());<br>    &#125;<br><br>    <span class="hljs-comment">// 返回id</span><br>    <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-分布式锁</title>
    <link href="/2025/07/01/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2025/07/01/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁">分布式锁</h1><p>通过分布式锁，让多个jvm可以共享一个锁监视器。</p><p><strong>分布式锁是满足分布式系统下或集群模式下多进程可见并且互斥的锁</strong>。</p><p>目的：在 Tomcat服务器集群的条件下，保证秒杀服务的一人一单。适用于高并发缓存/数据库保护/多服务部署任务控制/多线程并发。</p><p><img src="https://s21.ax1x.com/2025/06/29/pVn6Ggs.png" /></p><h2 id="简单实现">简单实现</h2><ul><li>获取锁：<code>SETNX</code>添加锁，<code>EXPIRE</code>添加锁的过期时间，可以合并为<code>SET lock thread NX EX 时间</code></li><li>释放锁：可手动释放，也可超时释放（利用锁的超时时间）</li></ul><p>业务流程：</p><p><img src="https://s21.ax1x.com/2025/06/29/pVn605F.png" /></p><p>在判断<code>Boolean</code>类型变量是否为真时，推荐使用<code>Boolean.TRUE.equals(xxx)</code>，可以有效避免空指针异常，且语义清晰。</p><p>工具类：基于<code>SET NX</code>实现了获取锁和释放锁两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;Project: hm-dianping&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;Date: 2025/6/29 19:54&lt;/p&gt;</span><br><span class="hljs-comment"> * Description: 用于分布式锁的获取和释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpledRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpledRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取锁（即设置key）</span><br>    <span class="hljs-comment">// key: 前缀+业务名</span><br>    <span class="hljs-comment">// value：当前线程ID</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ThreadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, ThreadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unclock</span><span class="hljs-params">()</span> &#123;<br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于分布式锁重写一人一单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpledRedisLock</span> <span class="hljs-variable">simpledRedisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpledRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br><span class="hljs-comment">//获取锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> simpledRedisLock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-keyword">if</span> (!isLocked) &#123;<br>    <span class="hljs-comment">// 获取失败，返回错误或重试</span><br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 获取成功，手动释放锁</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    simpledRedisLock.unclock();<br>&#125;<br></code></pre></td></tr></table></figure><p>与<code>synchronized</code>块相比，这次需要手动创建和释放锁。更复杂，但是适用性更好，能够处理多台Tomcat 集群的情形，因为 Redis 服务器是由多台 Tomcat共享的，把锁的数据存储在 Redis 即可实现分布式锁。</p><h2 id="分布式锁的误删问题">分布式锁的误删问题</h2><p>上面释放锁的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unclock</span><span class="hljs-params">()</span> &#123;<br>    stringRedisTemplate.delete(KEY_PREFIX + name);<br>&#125;<br></code></pre></td></tr></table></figure><p>并没有检查<strong>当前线程是否是锁的持有者</strong>，如果线程 A获取锁之后，由于业务阻塞，直到锁超时这个业务也没有完成，那么锁会被强制释放。这时如果有另一个线程B 就可以顺利拿到锁，此时实际上<strong>同时运行了多个线程</strong>。</p><p>如果 B 还没有释放锁的时候，线程 A的业务突然完成了，那么它会不加思考直接删掉线程 B的锁，导致锁失效。这个过程可能会不断重复，最终多个线程并发执行下单逻辑，<strong>不能保证一人一单</strong>。</p><h2 id="解决分布式锁的误删问题一">解决分布式锁的误删问题（一）</h2><h3 id="思路">思路</h3><p><strong>解决方法</strong>：为锁设置一个标识，被不同线程拿到的时候标识也不同，线程在释放锁之前检查一下当前锁的标识跟自己是否一致，不一致的话就停手</p><figure><img src="https://s21.ax1x.com/2025/06/29/pVngk6A.png"alt="解决误删问题" /><figcaption aria-hidden="true">解决误删问题</figcaption></figure><p>流程图：</p><figure><img src="https://s21.ax1x.com/2025/06/29/pVngZ0P.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p><strong>线程标识怎么选</strong>？</p><p>一种想法是像刚才一样直接将当前线程的 ID作为标识，这不太好，因为多台服务器上对应多个JVM，每个JVM上又有很多线程，完全有可能出现两台 JVM上的线程标识冲突的情况。</p><p>更好的选择是结合 UUID使用。核心是保证<strong>全局唯一</strong>，而线程 ID已经保证了<strong>单 JVM 唯一</strong>，只需要区分不同的 JVM即可，而这可以通过在线程 ID 前拼接一个 UUID 实现，每一个 JVM对应一个独一无二的 UUID。</p><h3 id="生成不带横线的uuid">生成不带横线的UUID</h3><p><code>java.util.UUID</code>的<code>randomUUID</code>方法获得的 UUID是带分隔线的，在Redis 锁、数据库主键的情形下常常把分隔线去掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUUID</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;Project: hm-dianping&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;Date: 2025/6/29 19:54&lt;/p&gt;</span><br><span class="hljs-comment"> * Description: 用于分布式锁的获取和释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpledRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> getUUID(); <span class="hljs-comment">// 每一个 JVM 只加载一次 SimpledRedisLock 类，只拥有一个 UUID 前缀</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpledRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁的方法。</span><br><span class="hljs-comment">     * key：KEY_PREFIX + 业务名</span><br><span class="hljs-comment">     * value：UUID + 线程 ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutSec Redis 中该锁的 TTL</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否成功获取锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ThreadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, ThreadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unclock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前锁的标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">LockID</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-comment">// 获取当前线程的标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentThreadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 判断是否一致</span><br>        <span class="hljs-keyword">if</span> (currentThreadId.equals(LockID)) &#123;<br>            stringRedisTemplate.delete(KEY_PREFIX + name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回不带横线的 UUID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> UUID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getUUID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解决分布式锁的误删问题二">解决分布式锁的误删问题（二）</h2><p>上面的思路还有一个问题：线程【判断锁的ID和自己是否一致】与【释放锁】是两个分开的操作，如果不能保证这两个操作的原子性，比如判断无误之后经历了较长的阻塞过程，以至于锁自身被超时强制释放，那么其他线程可以趁虚而入拿到锁。如果在这之后原来的线程突然脱离了阻塞状态，这时仍然会把别人的锁给释放掉。</p><p>破局的关键是：确保<code>unlock</code>方法的【判断】和【释放】这两个步骤是原子性的。</p><figure><img src="https://s21.ax1x.com/2025/06/30/pVnIITs.png"alt="误删的另一种情况" /><figcaption aria-hidden="true">误删的另一种情况</figcaption></figure><h3 id="redis的lua脚本">Redis的Lua脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;其他参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure><p>用 Redis 命令执行脚本：</p><p><img src="https://s21.ax1x.com/2025/06/30/pVnok6O.png" /></p><p>完成的 lua 脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取锁的线程标识</span><br><span class="hljs-keyword">local</span> id = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-comment">-- 比较</span><br><span class="hljs-keyword">if</span>(id == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 释放锁</span><br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="java执行lua脚本">Java执行lua脚本</h3><p><code>RedisTemplate.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * (non-Javadoc)</span><br><span class="hljs-comment">    * @see org.springframework.data.redis.core.RedisOperations#execute(org.springframework.data.redis.core.script.RedisScript, java.util.List, java.lang.Object[])</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args)</span> &#123;<br>    <span class="hljs-keyword">return</span> scriptExecutor.execute(script, keys, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的<code>unlock</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br><br><span class="hljs-keyword">static</span> &#123;<br>    UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>    UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>    UNLOCK_SCRIPT.setResultType(Long.class);<br>&#125;<br><br><span class="hljs-comment">// 调用 lua 脚本释放锁</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unclock</span><span class="hljs-params">()</span> &#123;<br>    stringRedisTemplate.execute(<br>            UNLOCK_SCRIPT,<br>            Collections.singletonList(KEY_PREFIX + name),<br>            ID_PREFIX + Thread.currentThread().getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>在脚本中一次完成判断和释放这两个操作，在java中只需要一行代码调用脚本，保证了操作的原子性。现在就得到了一个相对完善的分布式锁。</p><h2 id="误删问题总结">误删问题总结</h2><p>解决思路：</p><ul><li>利用<code>SET NX EX</code>设置带超时时间的<code>key</code>，即为获取锁</li><li>获取锁时先原子性地判断锁标识和当前线程标识是否一致，如果一致就删除，为了保证原子性调用了<code>lua</code>脚本</li></ul><p>特性：</p><ol type="1"><li>利用<code>SET NX</code>满足互斥性</li><li>利用<code>EX</code>设置超时时间，避免业务阻塞的时候无法释放锁，提高安全性</li><li>利用 Redis 集群保证高可用和高并发</li></ol><h2 id="现成的分布式锁">现成的分布式锁</h2><p>答案是 Redission。</p><p>添加配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissionConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">redission</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        redission.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.199.129:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;23525943&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(redission);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建锁对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId); <span class="hljs-comment">// 使用现成的 Redission</span><br></code></pre></td></tr></table></figure><p>然后就可以<code>lock.tryLock();</code>获取锁，<code>lock.unlock();</code>释放锁了。</p><h2 id="秒杀业务总结">秒杀业务总结</h2><p>其实秒杀业务就做了两件事：</p><ol type="1"><li>扣减数据库中保存的优惠券的剩余数量</li><li>将用户抢到的优惠券的订单信息写入数据库</li></ol><p>但是，因为秒杀业务存在两个限制：</p><ul><li>库存绝不能超卖</li><li>一个用户只能下一单，不能重复下单</li></ul><p>所以实现逻辑变得复杂了。</p><h2 id="异步优化">异步优化</h2><p><img src="https://s21.ax1x.com/2025/06/30/pVnzQCF.png" /></p><figure><img src="https://s21.ax1x.com/2025/06/30/pVnzYHx.png"alt="右侧是Tomcat负责的部分" /><figcaption aria-hidden="true">右侧是Tomcat负责的部分</figcaption></figure><p>同样，判断和扣减库存的操作要确保月自行，所以还是写到一个lua脚本里面。</p><h3 id="把优惠券信息也保存到redis">把优惠券信息也保存到Redis</h3><p>添加一行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherMapper, Voucher&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryVoucherOfShop</span><span class="hljs-params">(Long shopId)</span> &#123;<br>        <span class="hljs-comment">// 查询优惠券信息</span><br>        List&lt;Voucher&gt; vouchers = getBaseMapper().queryVoucherOfShop(shopId);<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(vouchers);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>        <span class="hljs-comment">// 保存优惠券</span><br>        save(voucher);<br>        <span class="hljs-comment">// 保存秒杀信息</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>        seckillVoucher.setVoucherId(voucher.getId());<br>        seckillVoucher.setStock(voucher.getStock());<br>        seckillVoucher.setBeginTime(voucher.getBeginTime());<br>        seckillVoucher.setEndTime(voucher.getEndTime());<br>        seckillVoucherService.save(seckillVoucher);<br><br>        <span class="hljs-comment">// 保存到 Redis</span><br>        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), String.valueOf(voucher.getStock()));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于lua脚本判断库存一人一单">基于Lua脚本判断库存、一人一单</h3><p>判断库存是否充足、用户是否重复下单，仅当用户没有下单且库存充足的时候返回数字<code>0</code>同时把用户ID 放入当前优惠券的<code>SET</code>集合。</p><p>相关的 Redis 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">SADD key member<br>SISMEMBER key member<br></code></pre></td></tr></table></figure><p>如果<code>key</code>集合中存在指定的<code>member</code>，则返回<code>1</code>，否则返回<code>0</code>。根据流程图容易写出脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 用户ID</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order&#x27;</span> .. voucherId<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--  判断用户是否下单</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 扣库存</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 下单</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后重新实现秒杀部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secKillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 获取用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 1. 运行脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), String.valueOf(voucherId), String.valueOf(userId));<br>    <span class="hljs-comment">// 判断脚本返回的结果</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-keyword">if</span>(r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 下单逻辑：</span><br>    <span class="hljs-comment">// TODO 保存到队列</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>截至目前完成了红框区域的代码（包括lua脚本）：</p><p><img src="https://s21.ax1x.com/2025/06/30/pVuCEGT.png" /></p><p>消息队列可以使用 RabbitMQ 或者 Kafka 来实现，此处不赘述。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战篇-秒杀</title>
    <link href="/2025/06/30/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%A7%92%E6%9D%80/"/>
    <url>/2025/06/30/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="雪花算法全局id生成器">雪花算法&amp;全局ID生成器</h2><p>雪花算法（Snowflake） 是一种由 Twitter 提出的<strong>分布式唯一 ID生成算法</strong>，用来在<strong>高并发、分布式</strong>系统中快速生成<strong>全局唯一、趋势递增的64 位整数 ID</strong>。</p><p>雪花算法的结构：<code>long</code>类型，64位</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>| <span class="hljs-number">41</span>位时间戳 | <span class="hljs-number">10</span>位机器信息 | <span class="hljs-number">12</span>位序列号<br></code></pre></td></tr></table></figure><ul><li>序列号：同一毫秒内的自增序列号，比如同一毫秒内的第<code>12</code>个请求的序列号就是<code>12</code>，最多4096个序列号</li></ul><p>用途：</p><ul><li>分布式订单号，用户ID，消息ID</li><li>数据库主键ID</li><li>替代UUID</li></ul><p>本项目用到的算法和雪花算法类似，如下：</p><figure><img src="https://s21.ax1x.com/2025/06/28/pVnnElt.png"alt="全局ID生成器" /><figcaption aria-hidden="true">全局ID生成器</figcaption></figure><p>完成的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">// 形参用于区分不同的业务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 生成序列号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 每次调用都会让 icr:keyPrefix:date 这个键的值加一，然后利用获取到的数字作为唯一 ID 的一部分</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 移位 + 拼接</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; <span class="hljs-number">32</span> | count;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的算法还有一个好处：全局 ID 的<code>key</code>是包含日期的，根据key 就能统计每一天的总订单量。</p><h2 id="优惠券秒杀下单">优惠券秒杀下单</h2><h3 id="初步思路">初步思路</h3><p>优惠券分为两类：</p><ul><li>平价券：可以任意抢购</li><li>特价券：限时秒杀</li></ul><p>添加秒杀券的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增秒杀券</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> voucher 优惠券信息，包含秒杀信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 优惠券id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;seckill&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Voucher voucher)</span> &#123;<br>    voucherService.addSeckillVoucher(voucher);<br>    <span class="hljs-keyword">return</span> Result.ok(voucher.getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意两点：</p><ul><li>秒杀是否开始或者结束</li><li>剩余库存是否充足</li></ul><figure><img src="https://s21.ax1x.com/2025/06/29/pVn0iN9.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p><strong>几个技巧</strong>：</p><ol type="1"><li>扣减库存：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扣减库存</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> seckill_voucher<br><span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">WHERE</span> voucher_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>这样写常常用于高并发库存的场景，直接在数据库层面<code>stock = stock - 1</code><strong>一次性</strong>完成读取旧值、计算新值、写入新值的操作，没有读取、修改、写入的空隙。</p><p>完整的查询秒杀券信息、更新秒杀券库存、创建订单并将订单写入库存的操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secKillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 查询基本信息</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucherSeckill</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>        <span class="hljs-comment">// 检查开始时间</span><br>        <span class="hljs-keyword">if</span> (voucherSeckill.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还没开始&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 检查结束时间</span><br>        <span class="hljs-keyword">if</span> (voucherSeckill.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span>(voucherSeckill.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不够&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>        <span class="hljs-keyword">if</span>(!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存又不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">OrderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucher.setId(OrderId);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        voucher.setUserId(userId);<br>        voucher.setVoucherId(voucherId);<br>        <span class="hljs-comment">// 写入数据库</span><br>        save(voucher);<br>        <span class="hljs-comment">// 返回订单 ID</span><br>        <span class="hljs-keyword">return</span> Result.ok(OrderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这里涉及两个对数据库的直接改动操作（修改库存、增加订单），所以加上一个事务注解。</p><h3 id="解决高并发问题">解决高并发问题</h3><p>以上代码存在<strong>超卖</strong>现象，原理如下：</p><figure><img src="https://s21.ax1x.com/2025/06/29/pVnByid.png" alt="超卖" /><figcaption aria-hidden="true">超卖</figcaption></figure><p>某一时刻只剩下了一张券，此时并发的三个线程1、2、3同时查询库存，都发现仍有剩余，于是三个线程都去做减库存的操作，导致超卖。这属于并发安全问题。</p><p>解决方案：<strong>加锁</strong>。</p><p>锁分为两种：</p><ul><li><strong>悲观锁</strong>：认为<strong>并发冲突一定会发生</strong>，所以每次访问数据时都先加锁，防止别人同时操作。保证绝对安全，适用于并发很高、冲突频繁的场景。代表：<code>Synchronized</code></li><li><strong>乐观锁</strong>：认为<strong>并发冲突是极少数的</strong>，所以操作时不加锁，而是在提交时检测数据有没有被别人改动。先干后验证，如果发现有冲突就重新再来，性能更好。</li></ul><p>乐观锁的关键是<strong>判断有没有冲突发生</strong>，常见的判断方式——</p><p><strong>版本号法</strong>，思路是定义一个版本号，每当发生修改操作的时候就把版本号加一。在查询的时候不但查库存量还要查出来版本号，紧接着修改操作前再检查一下版本号和先前查出来的是否一致，不一致则说明有人趁这个空隙把数据库修改了，重新再来。更进一步的，我们其实连版本号都不需要，直接把库存量当成版本号来用，前后查两次库存用于比较就行了，如果一致就说明可以放心修改。</p><p>对应到代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扣减库存</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 再次检查，只要满足剩余的数量大于零即可</span><br>        .update();<br></code></pre></td></tr></table></figure><h2 id="一人一单">一人一单</h2><p>需求：修改秒杀业务，要求每个人对于同一种券只能下一单</p><h3 id="检测是否重复下单">检测是否重复下单</h3><p>思路：查询<code>voucher_order</code>表中是否存在当前用户<code>user_id</code>当前券对应的<code>voucher_id</code>（即：<code>user_id</code>代表的用户是不是已经下单过了<code>voucher_id</code>代表的产品），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一人一单功能</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 查询订单</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>等价的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <br><span class="hljs-keyword">FROM</span> voucher_order <br><span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> voucher_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><h3 id="按用户id加锁">按用户ID加锁</h3><ol type="1"><li><strong>按用户ID为用户加锁</strong>（考虑到网络延迟，如果第一次请求还没返回就发出第二个请求，在不加锁的情况下会导致重复下单），<strong>同一个用户的请求串行执行，不同的用户请求并发执行</strong>，这样就提升了性能。</li><li>把同步锁放到整个函数的外面，确保事务提交之后再释放锁，这是为了<strong>防止Spring 事务失效</strong>（这里使用的处理思路不是特拨号，因此存在 Spring事务失效的问题）</li></ol><p>Spring 事务失效的原因如下。</p><h3 id="spring事务失效">Spring事务失效</h3><p>Spring的<code>@Transactional</code>是通过<strong>代理</strong>实现的: Spring通过代理拦截方法调用，在方法执行前开启事务，执行后根据结果提交或回滚。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">调用业务方法<br>    │<br>    ▼<br>是否有 <span class="hljs-meta">@Transactional</span> 注解？<br>    │是<br>    ▼<br>代理对象开始事务（获取连接、设置隔离级别等）<br>    │<br>执行目标方法<br>    │<br>是否抛出异常？<br> ┌──────────┬────────────┐<br> │ 否       │ 是         │<br> ▼         ▼<br>提交事务   回滚事务<br>    │<br>方法返回或抛出异常<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Spring 会为你的 Service 创建一个代理对象</span><br><span class="hljs-type">VoucherOrderServiceImpl</span> <span class="hljs-variable">originalObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span>();<br><span class="hljs-type">VoucherOrderServiceImpl</span> <span class="hljs-variable">proxyObject</span> <span class="hljs-operator">=</span> createProxy(originalObject); <span class="hljs-comment">// 代理对象</span><br><br><span class="hljs-comment">// 代理对象的方法调用流程：</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1. 开启事务</span><br>    TransactionManager.begin();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2. 调用原始对象的方法</span><br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> originalObject.createVoucherOrder(voucherId);<br>        <span class="hljs-comment">// 3. 提交事务</span><br>        TransactionManager.commit();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 4. 回滚事务</span><br>        TransactionManager.rollback();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更一般地说，对于如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">()</span> &#123;<br>    updateA();  <span class="hljs-comment">// 扣钱</span><br>    updateB();  <span class="hljs-comment">// 加钱</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用时 Spring 实际做了这些事：</p><ol type="1"><li>生成代理对象，调用该方法时进入拦截器</li><li>拦截器通过事务管理器开启事务</li><li>依次执行内部的方法A和方法B</li><li>如果正常结束没有抛出异常，则提交事务</li><li>如果抛出异常，则回滚事务</li></ol><hr /><p>下面是一个事务失效的例子：在一个类里面定义两个方法A和B，方法A直接调用方法B，则方法B的事务不生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        methodB(); <span class="hljs-comment">// 调用自己类的另一个事务方法</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 不生效 ❌（没有代理）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为自调用时不会经过代理对象，导致事务注解失效。</p><p>解决方法有两种：</p><ol type="1"><li>把方法B拆分到另一个<code>@Service</code>标识的类中</li><li>如果不拆分，可以使用<code>AopContext.currentProxy()</code>强行调用代理（不推荐用于复杂逻辑）</li></ol><p>第一种解决方案示例：创建一个新的类<code>SubUserService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubUserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入数据库、更新、回滚等</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>向原来的类注入<code>SubUserService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SubUserService subUserService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ✅ 通过代理调用 methodB，事务才会生效</span><br>        subUserService.methodB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种解决方案示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">((UserService) AopContext.currentProxy()).methodB();<br></code></pre></td></tr></table></figure><p>如果条件允许的话。第一种方案应该会比较好。第二种方案的代码有点复杂了。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-实现缓存机制</title>
    <link href="/2025/06/29/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%BC%93%E5%AD%98/"/>
    <url>/2025/06/29/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存">缓存</h2><p>缓存是数据交换的缓冲区，是存储临时数据的地方，读写性能较高。</p><p>目标：为下面这个控制器添加 Redis 缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id查询商铺信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 商铺id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 商铺详情数据</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> Result.ok(shopService.getById(id));<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端发来的请求先发给Redis，如果命中缓存则直接返回，如果没有命中才继续查询数据库，将查询到的数据写入Redis。</p><figure><img src="https://s21.ax1x.com/2025/06/25/pVeRVaT.png"alt="缓存作用模型" /><figcaption aria-hidden="true">缓存作用模型</figcaption></figure><p>根据id查询商铺信息时：</p><ol type="1"><li>用户提交商铺id，</li><li>从Redis查询店铺缓存，判断缓存是否命中，<ol type="1"><li>如果命中就直接返回</li><li>没有命中则继续根据id查询数据库<ol type="1"><li>该店铺存在，将店铺数据写入Redis，返回商铺信息</li><li>该店铺不存在，返回404</li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IShopService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">// 根据店铺id从predis查询</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>        <span class="hljs-comment">// 1. 从 Redis 查询商铺缓存，key是店铺的 id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><br>        <span class="hljs-comment">// 2. 判断是否存在</span><br><br>        <span class="hljs-comment">// 3. 存在，返回</span><br>        <span class="hljs-keyword">if</span>(StringUtils.hasLength(shopJson))&#123;<br>            <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>            <span class="hljs-keyword">return</span> Result.ok(shop);<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 不存在，根据 id 查询数据库</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 5. 不存在，返回error</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 6. 存在，把数据写入 Redis 然后返回</span><br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存更新">缓存更新</h2><ul><li>Redis内存淘汰机制，内存不足的时候自动淘汰部分数据，一致性较差</li><li>超时删除：为缓存的数据添加TTL时间，到期后自动删除缓存，每次查询都更新缓存。一致性一般，如果缓存时间到期前数据库的数据又发生了变化还会造成脏读。</li><li>主动更新：在业务逻辑上，每次修改数据库的时候都更新缓存，一致性好</li></ul><p>最常用的方案：</p><ol type="1"><li>由缓存的调用者，在更新数据库的同时更新缓存：<strong>更新数据库的时候让缓存失效，查询时再更新缓存</strong>。</li><li>如何保证缓存与数据库操作的同时成功或失败：<ol type="1"><li>单体系统，把缓存和数据库操作放到同一个事务里</li><li>分布式系统，利用TCC等分布式事务方案。</li></ol></li><li>操作数据库和删除缓存的顺序：更推荐先操作数据库，再删除缓存</li></ol><p>对于低一致性需求，使用Redis自带的内存淘汰机制即可；对于高一致性需求，用主动更新，并以超时剔除作为兜底方案。</p><p>原版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 更新商铺信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> shop 商铺数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 无</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Shop shop)</span> &#123;<br>    <span class="hljs-comment">// 写入数据库</span><br>    shopService.updateById(shop);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span> <br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;update店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 更新数据库；删除缓存</span><br>    updateById(shop);<br>    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存穿透">缓存穿透</h2><p><strong>含义</strong>：客户端请求的数据在缓存中和数据库中都不存在，这些请求都会传给数据库，这些请求都会打到数据库，最后数据库返回一个null</p><p>解决方案：</p><ol type="1"><li><strong>缓存空对象</strong><ul><li>思路主动在数据库里缓存一个null</li><li>缺点：额外的内存消耗；可能造成短期的不一致</li></ul></li><li><strong>布隆过滤器</strong><ul><li>在客户端和Redis之间再加一个过滤器</li><li>缺点：实现复杂，可能误判</li></ul></li></ol><figure><img src="https://s21.ax1x.com/2025/06/25/pVe5SjH.png"alt="布隆过滤器" /><figcaption aria-hidden="true">布隆过滤器</figcaption></figure><h3 id="基于缓存空对象防止缓存穿透">基于缓存空对象防止缓存穿透</h3><figure><img src="https://s21.ax1x.com/2025/06/25/pVe5uuj.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>两处改动：</p><ol type="1"><li>如果数据库查询的结果为空，则将空值写入Redis；</li><li>如果Redis里没有查询到需要的店铺，则直接结束整个流程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据店铺id从predis查询</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1. 从 Redis 查询商铺缓存，key是店铺的 id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><br>    <span class="hljs-comment">// 2. 判断是否存在</span><br><br>    <span class="hljs-comment">// 3. 存在，返回</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(shopJson)) &#123;<br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果获取到的值是手动设置的空字符串：</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span> &amp;&amp; shopJson.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;是空值&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 不存在，根据 id 查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 5. 不存在，将空值写入 Redis</span><br>        stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6. 存在，把数据写入 Redis 然后返回</span><br>    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存雪崩">缓存雪崩</h2><p><strong>含义</strong>：再同一时段大量的缓存key同时失效，或者Redis服务器宕机，导致大量的请求到达数据库，带来巨大压力。</p><figure><img src="https://s21.ax1x.com/2025/06/25/pVe5Rrd.png" alt="缓存雪崩" /><figcaption aria-hidden="true">缓存雪崩</figcaption></figure><ol type="1"><li>给不同的 Key 的 TTL 增加随机值</li><li>利用 Redis 集群提高服务的可用性</li><li>给缓存业务增加降级限流策略</li><li>给业务添加多级缓存</li></ol><h2 id="缓存击穿">缓存击穿</h2><p>缓存击穿(Cache Breakdown)也叫热点key问题，指的是：</p><div class="note note-info">            <p>某个<strong>热点key</strong>在缓存中突然失效（过期或被删除），而此时大量请求同时访问这个key，导致这些请求直接打到数据库，造成数据库压力激增，甚至被击垮。</p>          </div><p>举个例子：假设系统中有一个商品详情页，每秒有成千上万的人访问<code>商品ID = 123</code>。开始为这个商品设置了Redis 缓存，缓存时间是 5 分钟。正常情况，请求都从 Redis获取数据，数据库很轻松。但是第五分零一秒时，这个缓存刚好过期，大量的请求<strong>同时</strong>到达，发现Redis没有缓存，于是所有的请求同时到达数据库。数据库一下子收到这么多的请求，响应会变慢或者直接宕机。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>缓存击穿</strong></td><td><strong>热点数据</strong>在某一时刻失效，导致大量请求同时打到数据库</td></tr><tr><td><strong>缓存穿透</strong></td><td>请求的是<strong>不存在的数据</strong>，缓存和数据库都没有，导致每次都打数据库</td></tr><tr><td><strong>缓存雪崩</strong></td><td>大量缓存同一时间<strong>集体过期</strong>，导致大量请求打到数据库（击穿的扩大版）</td></tr></tbody></table><p>结果都是一样的：大量请求达到数据库，到数据库造成冲击。</p><hr /><p><strong>解决方案</strong>：</p><ol type="1"><li>加互斥锁，最常用，只允许一个线程去数据库加载数据，其它线程等待或稍后重试。伪代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (redis.get(key) == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (tryLock(key)) &#123;<br>        <span class="hljs-comment">// 查询数据库</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> db.query(key);<br>        redis.set(key, data, <span class="hljs-number">5</span>分钟);<br>        unlock(key);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其它线程等待或稍后重试</span><br>        sleep(50ms);<br>        <span class="hljs-keyword">return</span> redis.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>逻辑过期，为存储的数据增加一个过期时间字段，形如</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expireTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2025-06-25 16:00:00&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>如果当前时间 &lt; expireTime，直接返回；</li><li>否则异步更新，并返回旧值，具体来说就是创建一个新的线程，由它专门负责查询数据库、更新缓存。</li></ul><p>两种解决方案的示意如下</p><p><img src="https://s21.ax1x.com/2025/06/25/pVeokp8.png" alt="2" /><img src="https://s21.ax1x.com/2025/06/25/pVeo31U.png" alt="对比" /></p><h2id="基于互斥锁方式解决缓存击穿问题">基于互斥锁方式解决缓存击穿问题</h2><h3 id="思路">思路</h3><p>需求：修改根据 id 查询商铺业务，基于互斥锁的方式解决缓存击穿问题</p><figure><img src="https://s21.ax1x.com/2025/06/28/pVnPpCT.png" alt="互斥锁" /><figcaption aria-hidden="true">互斥锁</figcaption></figure><p>互斥锁用的是 Redis 中的<code>SETNX</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>SETNX key value<br>summary: Set the value of a key, only <span class="hljs-keyword">if</span> the key does not exist<br>since: 1.0.0<br>group: string<br><br></code></pre></td></tr></table></figure><ul><li>获取锁：调用<code>SETNX</code>设置一个key，之后如果有别的线程尝试获取锁，<code>SETNX</code>返回的结果是0，即获取失败</li><li>释放锁：删除该key</li></ul><p>核心思想：使用Redis分布式锁确保同一时间只有一个线程能够重建缓存，其他线程等待并重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 尝试获取锁的方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否获取成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;&quot;</span>, LOCK_SHOP_TTL, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> flag != <span class="hljs-literal">null</span> &amp;&amp; flag;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除锁的方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 待删除的锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br><br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1. 从 Redis 查询商铺缓存，key是店铺的 id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><br>    <span class="hljs-comment">// 2. 判断是否存在</span><br>    <span class="hljs-comment">// 3. 存在，返回</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(shopJson)) &#123;<br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 实现缓存重建</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取互斥锁，带超时机制</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>; <span class="hljs-comment">// 重试获取锁最多5秒超时</span><br><br>        <span class="hljs-keyword">while</span> (!tryLock(lockKey)) &#123;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() - startTime &gt; timeout) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;获取锁超时，key: &quot;</span> + lockKey);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 成功获取锁后，再次检查缓存（双重检查）</span><br>        shopJson = stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(shopJson)) &#123;<br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>        &#125;<br><br>        <span class="hljs-comment">// 查询数据库</span><br>        shop = getById(id);<br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 5. 查询到的店铺不存在，将空值写入 Redis</span><br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 6. 存在，把数据写入 Redis 然后返回</span><br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt(); <span class="hljs-comment">// 恢复中断状态</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;线程被中断&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 确保释放锁</span><br>        unlock(lockKey);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么要做双重检查">为什么要做双重检查</h3><ul><li>第一重检查：获取锁之前检查 Redis 缓存</li><li>第二重检查：获取锁之后再次检查 Redis 缓存</li></ul><p>假设有100个并发线程同时访问同一个过期的缓存key：</p><ul><li>第一个线程获取到锁，开始查询数据库并重建缓存</li><li>其余99个线程在while循环中等待锁释放</li><li>第一个线程完成缓存重建后释放锁</li><li>其余99个线程依次获取到锁后，如果没有双重检查，都会再次查询数据库，产生大量并发查询</li></ul><p>时序图如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">时间线：缓存过期 → 并发访问<br>        ↓<br>线程1:  获取锁 → 二次检查<span class="hljs-params">(空)</span> → 查DB → 写缓存 → 释放锁<br>线程2:  等待<span class="hljs-string">...</span> → 获取锁 → 二次检查<span class="hljs-params">(有值)</span> → 直接返回<br>线程3:  等待<span class="hljs-string">...</span> → 获取锁 → 二次检查<span class="hljs-params">(有值)</span> → 直接返回<br><span class="hljs-string">...</span><br>线程N:  等待<span class="hljs-string">...</span> → 获取锁 → 二次检查<span class="hljs-params">(有值)</span> → 直接返回<br></code></pre></td></tr></table></figure><p>其实也好理解：如果某个线程发现缓存已经过期了，就会尝试获取锁，如果没有拿到锁，那只能说明某个线程已经在执行查询数据库、更新Redis 缓存的操作了。所以拿到锁之后要再检查一下。</p><p>具体来说，在第二次检查中：</p><ul><li>如果拿到锁的线程会发现缓存是空的，这就让它意识到自己的职责正是查询和重建；</li><li>如果拿到锁的线程发现缓存已经被更新过了，这就告诉它有人已经把该做的事做完了，所以它直接拿来用就行。</li></ul><p>这就是二重检查的意义，这是分布式锁场景下的重要优化。</p><h3 id="jmeter测试">JMeter测试</h3><p>测试参数：</p><figure><img src="https://s21.ax1x.com/2025/06/28/pVnFDNq.png" alt="测试参数" /><figcaption aria-hidden="true">测试参数</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/06/28/pVnFr40.png"alt="测试结果汇总" /><figcaption aria-hidden="true">测试结果汇总</figcaption></figure><p>误码率为0，吞吐量 208.6/sec，符合预期。</p><p>回到 IDEA 的控制台，可以看到全程只做了一次查询：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-meta">: ==&gt;  Preparing:</span> SELECT id,name,type_id,images,area,address,x,y,avg_price,sold,comments,score,open_hours,create_time,update_time FROM tb_shop WHERE id=?<br><span class="hljs-meta">: ==&gt; Parameters:</span> 1(Long)<br><span class="hljs-meta">: &lt;==      Total:</span> 1<br></code></pre></td></tr></table></figure><p>说明缓存起作用了。</p><h2id="基于逻辑过期方式解决缓存击穿问题">基于逻辑过期方式解决缓存击穿问题</h2><h3 id="思路-1">思路</h3><p>与上一种方法的共同点是，这里也需要一个互斥锁。</p><p>不同点是，这次不为 Redis 里的 key 设置TTL，而是手动清除过期的key，具体而言每个key存储的都是一个带有<code>Data</code>和<code>ExpireTime</code>字段的对象，从Redis获取到key之后在Java 代码中比较<code>ExpireTime</code>和当前时间，判断是否过期。</p><p><strong>热点key是人为提前添加好的</strong>，如果从 Redis 中没有查到key，只能说明这个商品不属于我们关注的热点key，直接返回null。正常情况下都会命中的。</p><p>在上一种方法里，如果一个线程获取不到锁，就一直阻塞式地等待直到拿到锁；在基于逻辑过期的思路中，如果某个线程发现自己获取不到互斥锁，那就不等了，直接返回过期数据。成功获取锁、并且通过双重检查的人会开启一个新线程去查询数据和更新缓存，自己继续返回旧数据，也不会等待，避免像上一种方法一样卡在这里。</p><figure><img src="https://s21.ax1x.com/2025/06/28/pVnVC26.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><h3 id="细节">细节</h3><p>为了实现<strong>无侵入</strong>地引入 Redis 数据格式（过期时间 +携带的数据），需要单独定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后考虑怎么存储和读取<code>RedisData</code>对象。</p><ol type="1"><li>将<code>RedisData</code>对象存入Redis的方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置逻辑过期时间的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLogic</span><span class="hljs-params">(String key, Object value, Long expireTimeLogic, TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>    redisData.setData(value);<br>    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(expireTimeLogic)));<br><br>    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>&#125;<br></code></pre></td></tr></table></figure><p>需要把<code>RedisData</code>对象先转换为 JSON 格式，再存进去。</p><ol start="2" type="1"><li>从 Redis 中获取并解析 JSON 对象的思路：先获取JSON，再解析成指定类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 JSON 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">latestShopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><span class="hljs-comment">// 将 JSON解析成指定的数据类型</span><br><span class="hljs-type">RedisData</span> <span class="hljs-variable">latestRedisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(latestShopJson, RedisData.class);<br></code></pre></td></tr></table></figure><p>注意，这里只是转化成<code>RedisData</code>类型了，如果想从<code>RedisData</code>获取<code>Data</code>，类型为<code>JSONObject</code>，还需要再转化一次才行。假设<code>Data</code>字段的最终类型是<code>type</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JSONUtil.toBean((JSONObject) latestRedisData.getData(), type);<br></code></pre></td></tr></table></figure><hr /><p>基于逻辑过期的方式需要<strong>创建新线程</strong>，这里推荐使用<strong>线程池</strong>，效率更高。</p><p>下面的代码创建一个固定大小为 10的线程池，用于执行缓存重建任务，并将其保存在一个<code>static final</code>变量中，表示这是一个全局共享且不可更改的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四次博客折腾记录</title>
    <link href="/2025/06/27/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/06/27/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>最近又折腾了一下博客，主要改善了一些细节，记录一下。</p><span id="more"></span><h2id="hexo注入器单独修改首页副标题字体">Hexo注入器单独修改首页副标题字体</h2><p>首页副标题首先要的是<strong>美观</strong>，要契合首页壁纸的风格。我早就想把首页的日语字体修改成游明朝，或者A1明朝体之类的有衬线字体，但是遇到了比较尴尬的地方：文章页副标题和首页副标题公用同一个<code>id</code>和<code>class</code>，像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subtitle&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;visible&quot;</span>&gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>直接修改<code>id</code>或者<code>class</code>的 CSS样式的话会殃及文章页，这是我不想看到的。</p><p>解决方案是使用 Hexo 注入器，实现无侵入地注入 HTML片段。具体用法参见<ahref="https://hexo.fluid-dev.com/docs/advance/#hexo-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">Hexo注入代码</a>，我采用的注入方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 为首页的副标题插入class */</span><br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;body_begin&#x27;</span>, <br>     <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;style&gt;</span><br><span class="hljs-string">        .banner-text .h2 &gt; #subtitle.visible &#123;</span><br><span class="hljs-string">          font-family: &quot;Yu Mincho&quot;, &quot;游明朝&quot;, serif !important;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      &lt;/style&gt;</span><br><span class="hljs-string">    `</span>,<br>     <span class="hljs-string">&#x27;home&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在<code>home</code>（首页）的<code>&lt;head&gt;</code>标签之后，注入内部CSS用于修改字体，非常简单。（不过这个效果在移动端不起作用，仍然是默认字体）</p><h2 id="借助-inkscape-完善艺术字签名">借助 Inkscape 完善艺术字签名</h2><p>看了一些大网站的页面设计，每一个页面的左上角往往都是网站的图标，比如：</p><figure><img src="https://s21.ax1x.com/2025/06/27/pVmLdij.png" alt="Youtube" /><figcaption aria-hidden="true">Youtube</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/06/27/pVmLwJs.png" alt="Github" /><figcaption aria-hidden="true">Github</figcaption></figure><p>共同特征：</p><ol type="1"><li>都是<strong>图标+文字</strong>的形式，</li><li>点击图标就会<strong>跳转到首页</strong>。</li></ol><p>下面实现第一项：<em>把图标添加到页面左上角</em></p><p>以前采用的方案是直接在 <ahref="https://danmarshall.github.io/google-font-to-svg-path/">GoogleFont to Svg Path</a> 生成需要的字体 svg文件，所以下一步只需要把图标的图像文件跟这个 svg合并在一起，生成一个大小合适的新的 svg 文件即可。</p><p>目标很明确，但是关键是选择合适的<strong>用于编辑 svg图像的工具</strong>。我最开始是尝试了好几个在线编辑 svg的网站，要么是乱收费，要么是功能欠佳。花了不少时间，最后终于让我找到了<strong>Inkscape</strong>，一个<strong>免费开源</strong>的矢量图形编辑软件，功能相当强大，只需要把已有的图标<code>img2</code>和艺术字<code>path2</code>导入即可开始编辑：</p><figure><img src="https://s21.ax1x.com/2025/06/27/pVmqvrT.png" alt="编辑页面" /><figcaption aria-hidden="true">编辑页面</figcaption></figure><p>把图标和文字放到合适的位置，调整一下大小，最后点击界面右下角的<code>文档属性</code>修改图形大小就可以裁剪掉多余的部分了，非常的傻瓜😂当然这只是最基础的操作，这个软件的功能远比它多得多，留到以后俺再慢慢研究。</p><p>最终效果如下（左上角）：</p><figure><img src="https://s21.ax1x.com/2025/06/27/pVmOnXV.jpg" alt="满昏" /><figcaption aria-hidden="true">满昏</figcaption></figure><h2 id="点击签名跳转到首页">点击签名跳转到首页</h2><p>下面解释第二个功能。</p><p>这里的图标和艺术字是由一个 svg文件呈现的，只要点击这一块区域就会跳转。</p><p>其实 Hexo Fluid主题<strong>默认配置</strong>下，点击左上角的文字是可以跳转首页的，但是替换成艺术字就不奏效了，为什么？不妨看看以前是怎么把文字替换成svg 艺术字的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  navbarBrand  =  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container a&#x27;</span>);<br><br>navbarBrand.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;object type=&quot;image/svg+xml&quot; data=&quot;/img/banyee&#x27;s Blog.svg&quot;&gt;&lt;/object&gt;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>注意：<code>&lt;object&gt;</code>标签会<strong>阻止点击事件传递到父元素</strong>。这是因为<code>&lt;object&gt;</code>内部的内容会被当成一个<strong>独立的文档</strong>加载进来，它和父页面是<strong>隔离</strong>的，自然不会继承点击跳转的功能，简单来说就是鼠标被这个svg 图像挡住了。</p><p><strong>解决方案</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  navbarBrand  =  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container a&#x27;</span>);<br><br><span class="hljs-comment">/* &lt;object&gt; 标签会阻止点击事件传递到父元素。这是因为 &lt;object&gt; 内部的内容（SVG）会&quot;吸收&quot;点击事件。</span><br><span class="hljs-comment">使用 pointer-events: none 可以解决这个问题 */</span><br><br>navbarBrand.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;object type=&quot;image/svg+xml&quot; data=&quot;/img/banyee&#x27;s Blog.svg&quot; style=&quot;pointer-events: none;&quot;&gt;&lt;/object&gt;</span><br><span class="hljs-string">`</span>;<br><br>navbarBrand.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;https://kznleaf.top&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>只添加了一点点代码：<code>style="pointer-events: none</code>，原理是规定我们插入的元素不会响应任何鼠标交互事件，也就是说插入的svg对于鼠标来说是<strong>透明</strong>的，你对它的点击都会穿透到下面去，这样一来就能正常跳转了。</p><h2 id="加快国内访问速度">加快国内访问速度</h2><p>Cloudflare被称为赛博活佛，向用户提供<strong>不需要实名认证的、免费的</strong> CDN加速服务。但是呢，由于天朝奇葩的网络环境，使用 Cloudflare提供的服务反而会<strong>拖慢</strong>国内的加载速度，近年来不少Cloudflare 为用户分配的节点都已经被 GFW屏蔽（包括俺使用的节点）。为了规避 GFW，有人想出了使用优选域名/ IP的解决方案，但是现在很多优选域名也被 GFW 屏蔽了😂这也符合 GFW的一贯原则：宁可滥杀错杀，也绝不漏掉任何一个【<strong>可能</strong>】包含政治敏感信息的网站。</p><p>嘛，要想享受国内的加速服务，最符合【国家意志】的做法就是域名备案:</p><blockquote><p>根据国务院令第292号《互联网信息服务管理办法》和《非经营性互联网信息服务备案管理办法》规定，国家对经营性互联网信息服务实行许可制度，对非经营性互联网信息服务实行备案制度。未获取许可或者未履行备案手续的，不得从事互联网信息服务，否则属于违法行为。</p></blockquote><p>优点：运营商大发慈悲为你提供大陆加速服务</p><p>缺点：</p><ol type="1"><li>备案流程<strong>又臭又长</strong>，以腾讯云为例：<ul><li>验证备案类型</li><li>填写主体信息</li><li>填写网站/域名或 APP 信息</li><li>上传补充材料（比如身份证）</li><li>提交备案</li><li>短信核验</li><li>管局审核</li></ul></li><li>备案就意味着把网站的所有内容【主动】提交给天朝审查，这俺可没法接受。</li></ol><hr /><p>在不备案的情况下，稍稍提高国内访问速度的一个方法是使用 Cloudflare的<strong>自定义主机名</strong>服务。</p><p><img src="https://s21.ax1x.com/2025/06/27/pVmh91g.png" /></p><p>在源站的 Cloudflare页面添加自定义主机名，两边的验证都通过之后，自定义主机名对应的网站的流量都会被引向源站。</p><p>这种方法需要准备两个域名：一个作为<strong>回退源</strong>，托管到Cloudflare；另一个作为<strong>实际访问的域名</strong><code>kznleaf.top</code>，托管到非Cloudflare的DNS解析服务器。作为回退源的域名添加<code>A</code>记录指向网站服务器的地址，然后在SaaS里把<code>kznleaf.top</code>作为自定义主机名添加进来，根据提示进行<code>TXT</code>记录验证。最后为<code>kznleaf.top</code>添加一条<code>CNAME</code>记录指向回退源的域名即可。</p><p>通过 CNAME 的方式指向 Cloudflare 而非固定 IP，这样可以利用 Cloudflare的泛播自动找到最快的边缘服务器，加快了访问速度。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Cloudflare</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装ArchLinux虚拟机过程记录</title>
    <link href="/2025/06/25/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/06/25/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://s21.ax1x.com/2025/06/25/pVeqEee.jpg"alt="Arch Linux" /><figcaption aria-hidden="true">Arch Linux</figcaption></figure><h2 id="前言">前言</h2><p>最近给手上的两个笔记本都装上了 Arch Linux虚拟机，来来回回重装了大概四五次，这里把比较重要的地方记录一下。主要参考：<ahref="https://arch.icekylin.online/guide/">archlinux简明指南</a>、<ahref="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/">Arch Linux安装使用教程 - ArchTutorial - Arch Linux Studio</a></p><h2 id="屏幕分辨率">屏幕分辨率</h2><p>第一次我是在外界24寸2k显示屏的游戏本上安装的 Arch Linux，在装好 KDE桌面环境和虚拟机增强功能之后，虚拟机的界面分辨率跟宿主机差不多，算是清晰。但是在另一个14寸2880x1880 分辨率的轻薄本上安装之后，界面看起来有点糊，像这样：</p><figure><img src="https://s21.ax1x.com/2025/06/25/pVe2GCQ.jpg" alt="糊" /><figcaption aria-hidden="true">糊</figcaption></figure><p>应该属于正常现象，玩虚拟机的话还是推荐用大屏</p><h2 id="无法连接校园网">无法连接校园网</h2><p>桥接方式中虚拟机是一个独立的机器，相当于一个真实机器，而此机器在校园网中并未注册，在校园网中是<strong>需要验证</strong>的，导致无法联网。</p><p>使用 NAT 方式可以联网，因为 NAT 模式下虚拟机通过宿主机来联网。</p><figure><img src="https://s21.ax1x.com/2025/06/24/pVeecCt.png"alt="NAT模式和桥接模式" /><figcaption aria-hidden="true">NAT模式和桥接模式</figcaption></figure><h2 id="linux磁盘分区">Linux磁盘分区</h2><p>前置知识：Linux是通过目录树的方式来管理文件的，形如</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">/<br>├── bin<br>├── <span class="hljs-keyword">boot</span><br>├── etc<br>├── home<br>│   ├── user1<br>│   └── user2<br>├── <span class="hljs-keyword">var</span><br>└── usr<br>    └── <span class="hljs-keyword">local</span><br></code></pre></td></tr></table></figure><p>对于 Linux 的分区和目录来说，需要理解两个概念：</p><ol type="1"><li>目录是树状层级结构的。</li><li>分区可以通过挂载的方式指定为任何层级下的目录。</li></ol><p>举个例子，假如现在我们手上有两块硬盘：</p><ul><li><code>/dev/sda1</code> 主分区，作为根目录</li><li><code>/dev/sdb1</code>第二块磁盘</li></ul><p>我们可以把第二块盘挂载到<code>/home</code>目录，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/sdb1 /home<br></code></pre></td></tr></table></figure><p>这样<code>/home</code>的文件就全部来自<code>/dev/sdb1</code>磁盘分区了。理论上来说，安装Linux系统，只需要给硬盘分一个区，然后挂载<code>/</code>根分区目录即可正常安装和使用。</p><p><strong>fdisk命令</strong>：</p><p>作用：格式化磁盘，用于分区操作。纯命令行交互。一般不用它来分区，而是用<code>fdisk -l</code>来查看当前分区状态。</p><p><strong>cfdisk命令</strong></p><p>相当于图形化版本的fdisk，用方向键选择分区，Tab键切换操作按钮，然后选<code>[New]</code>、<code>[Delete]</code>、<code>[Write]</code>等进行操作。一般用这个来分区。</p><h2 id="分区">分区</h2><p>先设定分区方案，对于虚拟机来说可以设置三个分区：</p><ul><li><strong>EFI 分区</strong>：512M</li><li>Swap 分区：4G</li><li>文件系统分区：剩余全部</li></ul><p>然后通过<code>fdisk -l</code>命令，确定需要分区的磁盘是<code>/dev/sda</code>。</p><p>在分区之前，<strong>首先将磁盘转换为 gpt 类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l                    <span class="hljs-comment">#显示分区情况 找到你想安装的磁盘名称</span><br>parted /dev/sda             <span class="hljs-comment">#执行parted，进入交互式命令行，进行磁盘类型变更</span><br>(parted)mktable             <span class="hljs-comment">#输入mktable</span><br>New disk label <span class="hljs-built_in">type</span>? gpt    <span class="hljs-comment">#输入gpt 将磁盘类型转换为gpt 如磁盘有数据会警告，输入yes即可</span><br>(parted)quit                        <span class="hljs-comment">#最后quit退出parted命令行交互</span><br></code></pre></td></tr></table></figure><p>然后调用<code>cfdisk</code>命令对磁盘分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cfdisk /dev/sda<br></code></pre></td></tr></table></figure><p>具体的的分区如下：</p><ul><li><code>/dev/sda1</code>：<strong>EFI 分区</strong>，512M</li><li><code>/dev/sda2</code>：Swap 分区，4G</li><li><code>/dev/sda3</code>：文件系统分区。其余全部</li></ul><p><code>[write]</code>后，退出，使用<code>fdisk -l</code>再次检查分区情况。</p><figure><img src="https://s21.ax1x.com/2025/06/24/pVemSa9.png" alt="分区" /><figcaption aria-hidden="true">分区</figcaption></figure><p><strong>注意</strong>：这一步不要忘记配置 EFI分区！在简明指南中，直到【安装详解】一文才描述了怎么配置 EFI分区，实际上 EFI 分区在这里就创建好了，应该放到前边就讲才对。</p><h2 id="格式化分区">格式化分区</h2><p>划定分区后就是格式化分区，分三步：</p><ul><li>将 EFI分区格式化为<code>FAT32</code>格式：<code>mkfs.vfat /dev/sda1</code></li><li>格式化 Swap 分区：<code>mkswap /dev/sdxn</code></li><li>将文件系统分区格式化为<code>Btrfs</code>文件系统：<code>mkfs.btrfs -L myArch /dev/sda3</code>，其中<code>-L</code>后的标签名可以随意起。</li></ul><h3 id="关于挂载">关于挂载</h3><p>挂载可分为<strong>永久性挂载</strong>和<strong>临时性挂载</strong>两种方式。<code>mount</code>命令为临时性挂载，在操作系统重启时就会失效。而永久性挂载则需要修改配置文件<code>/etc/fstab</code>，将需要挂载的文件系统写入这个配置文件中，再使用命令<code>mount -a</code>让配置信息生效，挂载的文件即可使用，重启后挂载仍然有效。</p><p>在 Btrfs 文件系统上为 Linux安装准备分区，并使用子卷（subvolume）来组织根目录（/）和用户目录（/home）。这是Arch Linux 和其他一些 Linux 发行版中常用的分区方式，特别需要 Btrfs的高级功能（如快照、压缩、复制）时。本次分区就采用了子卷的方式。</p><h3 id="引导程序的位置">引导程序的位置</h3><p><a href="https://arch.icekylin.online/guide/">archlinux简明指南</a>将GRUB引导程序安装在<code>/boot</code>目录下，不过经过查找资料发现并不推荐这样做，应该把EFI 分区挂载到<code>/boot/efi</code>分区下，然后把 GRUB引导程序安装到<code>/boot/efi</code>。</p><p>实际执行的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载根目录子卷（@）</span><br>mount -t btrfs -o compress=zstd,subvol=/@ /dev/sda3 /mnt<br><br><span class="hljs-comment"># 创建 home 和 boot 目录</span><br><span class="hljs-built_in">mkdir</span> /mnt/home<br><span class="hljs-built_in">mkdir</span> -p /mnt/boot/efi<br><br><span class="hljs-comment"># 挂载 home 子卷</span><br>mount -t btrfs -o compress=zstd,subvol=/@home /dev/sda3 /mnt/home<br><br><span class="hljs-comment"># 挂载 EFI 分区</span><br>mount /dev/sda1 /mnt/boot/efi<br><br><span class="hljs-comment"># 启用 swap 分区</span><br>swapon /dev/sda2<br></code></pre></td></tr></table></figure><p>挂载后的结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span>mnt<br>├── home<span class="hljs-operator">/</span>        ← 挂载了 <span class="hljs-variable">@home</span> 子卷<br>├── boot<span class="hljs-operator">/</span><br>│   └── efi<span class="hljs-operator">/</span>     ← 挂载了 <span class="hljs-operator">/</span>dev<span class="hljs-operator">/</span>sda1（EFI <span class="hljs-keyword">System</span> <span class="hljs-keyword">Partition</span>）<br></code></pre></td></tr></table></figure><p>传统的 BIOS 启动方式是习惯将引导程序放到<code>/boot</code>，但是 UEFI启动方式一般放到<code>/boot/efi</code>（也有直接放到<code>/efi</code>的）。关于BIOS 和 UEFI 这两种启动方式的区别，参见：<ahref="https://www.partitionwizard.com/partitionmagic/uefi-vs-bios.html">https://www.partitionwizard.com/partitionmagic/uefi-vs-bios.html</a></p><h2 id="安装引导程序">安装引导程序</h2><h3 id="安装grub软件包">安装grub软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S grub efibootmgr os-prober<br></code></pre></td></tr></table></figure><p><code>os-prober</code>主要是为引导双系统中的 windows系统使用的，如果只安装一个Linux虚拟机系统，那就可以省略，直接写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S grub efibootmgr<br></code></pre></td></tr></table></figure><p>同样，后面编辑<code>/etc/default/grub</code>文件的时候也不用添加新的一行<code>GRUB_DISABLE_OS_PROBER=false</code>了。</p><h3 id="将grub安装到efi分区">将grub安装到EFI分区</h3><p>之前我已经把RFI分区挂载到了<code>/boot/efi</code>目录下，所以这里也把grub安装到这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=ARCH<br></code></pre></td></tr></table></figure><h2 id="安装完毕">安装完毕</h2><figure><img src="https://s21.ax1x.com/2025/06/24/pVeA3WT.png" alt="123" /><figcaption aria-hidden="true">123</figcaption></figure><p>装完桌面环境以后最好先把虚拟机增强功能加上，这样以后可以直接从宿主机复制命令了，省下不少时间。</p><p>安装输入法的话先执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fcitx5-im <span class="hljs-comment">#基础包组</span><br><span class="hljs-built_in">sudo</span> pacman -S fcitx5-chinese-addons <span class="hljs-comment">#官方中文输入引擎</span><br><span class="hljs-built_in">sudo</span> pacman -S fcitx5-anthy <span class="hljs-comment">#日文输入引擎</span><br>yay -S fcitx5-pinyin-moegirl <span class="hljs-comment">#萌娘百科词库 由于中国大陆政府对github封锁，你可能在此卡住。如卡住，可根据后文设置好代理后再安装</span><br><span class="hljs-built_in">sudo</span> pacman -S fcitx5-pinyin-zhwiki <span class="hljs-comment">#中文维基百科词库</span><br><span class="hljs-built_in">sudo</span> pacman -S fcitx5-material-color <span class="hljs-comment">#主题</span><br></code></pre></td></tr></table></figure><p>然后需要配置环境变量。经过我的测试，<ahref="https://arch.icekylin.online/guide/">archlinux简明指南</a>中为输入法配置环境变量的方法已经失效。正确的操作是：</p><p>在终端输入命令<code>EDITOR=vim sudoedit /etc/environment</code>，加入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>SDL_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>目的是为 konsole 以及 dolphin 提供中文输入支持。</p><p>然后，打开<code>系统设置 &gt; 区域设置 &gt; 输入法</code>，先点击运行<code>Fcitx</code>即可，拼音为默认添加项，也可以添加双拼输入法，包含多种可选的双拼方案，比如我用的小鹤。</p><p>接下来点击拼音右侧的配置按钮，点选云拼音和在程序中显示预编辑文本，最后应用。</p><p>回到输入法设置，点击配置附加组件，找到经典用户界面，在主题里选择一个你喜欢的颜色，最后应用。</p><p>最后重启就可以正常使用输入法了。</p><h3 id="从github下载文件">从github下载文件</h3><p>有时候需要直接从 github仓库拉取所需的安装脚本，比如<code>zim</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh<br></code></pre></td></tr></table></figure><p>github.io 与 raw.githubusercontent.com已经被天朝政府盯上了，虽然封锁力度暂时还没有很大，但是运行上述命令的时候多半会连接失败。最根本的方法当然是配置全局代理，不过如果还没配置全局代理的话，可以考虑暂时借助<a href="https://ghproxy.link/">Github Proxy</a> 下载。</p><h3 id="保持系统为最新">保持系统为最新</h3><p>Arch Linux采用滚动式更新，最新版本一经发布马上会推送给用户。应当经常更新系统，防止系统滚挂。</p><p>使用<code>pacman</code>更新系统，用到的选项：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>-S</code></td><td>安装软件包（sync）</td></tr><tr><td><code>-y</code></td><td><strong>同步软件包数据库</strong>（从服务器更新本地的包列表）</td></tr><tr><td><code>-yy</code></td><td><strong>强制重新下载</strong>软件包数据库（即使系统认为是最新的也强制）</td></tr><tr><td><code>-u</code></td><td>升级所有可升级的软件包（update）</td></tr></tbody></table><ul><li><code>pacman -Syu</code>用于正常更新，如果本地的数据库和远程一致的话就不再重复下载数据库。</li><li><code>pacman -Syyu</code>强制更新，当数据库损坏或同步出错、更新镜像源（<code>/etc/pacman.d/mirrorlist</code>）之后的第一次强制同步应执行。不要经常用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>折腾记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名的基础知识、域名劫持和域名污染</title>
    <link href="/2025/06/22/%E5%9F%9F%E5%90%8D%E6%89%AB%E7%9B%B2/"/>
    <url>/2025/06/22/%E5%9F%9F%E5%90%8D%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<p>本文是对<ahref="https://program-think.blogspot.com/2014/01/dns.html">扫盲 DNS原理，兼谈“域名劫持”和“域名欺骗/域名污染”</a>的整理，在原文的基础上加上一些注解。感谢编程随想。</p><p>HTTPS SSL/TLS 扫盲见链接：https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html</p><h2 id="域名解析的实现过程">域名解析的实现过程</h2><p>如果你曾经配置过电脑的网卡，应该记得上面除了有 IP地址、掩码等设置，还有一项设置是“DNS服务器/域名服务器”。这项设置就是用来帮助你的电脑进行域名解析的。你可以把这个“DNS服务器”想象成114查号台。每当电脑需要翻译某个域名，就找这个域名服务器查询，然后域名服务器会告诉你的电脑，要查询的域名对应的IP地址是啥。</p><p>下面简单说一下，你的电脑进行域名解析的过程。为了叙述方便，以俺博客为例。当你在浏览器的地址栏中输入https://program-think.blogspot.com/然后敲回车，这时候电脑软件会进行如下一系列事情。</p><ol type="1"><li>首先根据输入的网址，提取出域名（在本例中，也就是program-think.blogspot.com）</li><li>如果你在系统中配置了 <strong>Hosts</strong> 文件，那么电脑会先查询Hosts 文件，看这个 program-think.blogspot.com 是否已经在 Hosts里面有了对应的记录。如果有，直接就可以拿到该记录中的 IP地址，过程就结束了。</li><li>如果 Hosts里面没有这个别名，那么电脑会看你有没有设置<strong>域名服务器</strong>（DNS服务器）。如果你的系统没有设置域名服务器，那电脑就没辙了，浏览器直接会报错，说网站的域名无法解析。过程就结束了。</li><li>如果你设置过“域名服务器”，那么电脑会向这个域名服务器发送一个<strong>域名查询</strong>（DNSquery）的请求，然后等候域名服务器的回应。</li><li>如果域名服务器始终没有回应（比如域名服务器挂了，或域名服务器的 IP填错了，或请求被 GFW 拦截了），那么电脑还是没辙（浏览器会报错）。</li><li>如果域名服务器回应了，那么你的电脑就可以根据域名服务器的应答信息，得到该域名的IP 地址。之后浏览器就会向这个 IP 地址对应的 Web 端口发送 HTTP请求。</li></ol><p>通常情况下，电脑拿到的（DNS服务器）应答信息是正确的——也就是说，应答中的 IP地址确实对应那个域名——这种情况下，你的网络软件就可以正常工作了。</p><p>但是在天朝这个奇葩的国家，电脑拿到的 DNS应答有可能是【错的】。为啥会这样捏，本文的后半部，俺会介绍一下“<strong>域名劫持</strong>”和“<strong>域名污染</strong>”。</p><h2 id="递归服务器">递归服务器</h2><p>刚才提到的“域名服务器”其实是“递归服务器”（Recursive DNSServer）。递归服务器，就是你本地电脑或路由器在访问网站（如www.baidu.com）时，第一时间请求的 DNS 服务器。它的作用是：<strong>帮你一步一步地找到最终的 IP地址</strong>，就像跑腿员一样去问别人。</p><ul><li>用户：请问<code>www.example.com</code>的 IP 地址是多少？<ul><li>递归服务器：不知道，我帮你去打听打听</li></ul></li><li>递归服务器问根服务器<ul><li>根服务器：这个域名位于<code>.com</code>顶级域服务器，它的 IP地址是。。</li></ul></li><li>递归服务器继续问<code>.com</code>顶级域服务器<ul><li>回答：你应该去找<code>example.com</code>的权威服务器，它的 IP地址是。。</li></ul></li><li>递归服务器问权威服务器<ul><li>回答：<code>www.example.com</code>的 IP 地址是。。。</li></ul></li></ul><blockquote><p>上面提到了权威服务器。所谓权威服务器，其实就是直接掌管域名与 IP的映射信息（A记录、MX记录、CNAME等）的服务器，也就是域名解析服务提供分配给你、用于添加各种记录的的服务器。</p></blockquote><h2 id="域名的缓存">域名的缓存</h2><p>因为递归服务器的查询效率很低，所以递归服务器必须有一个缓存。当某台电脑向递归服务器发起域名查询时，递归服务器首先看自己的缓存中有没有该域名的记录，如果有，直接就回复该记录给查询的电脑。如果没有，再执行上面的查询过程。</p><p>因为互联网上的域名信息是有可能发生变化的，比如增加了某个新域名，注销了某个旧域名，或者某个域名对应的IP地址变了。所以，“<strong>递归服务器</strong>”上保留的<strong>缓存</strong>中，每一条域名记录都有一个生命周期（可能是几分钟，也可能是几小时）。如果某条记录的生命周期过了，就会被删除，然后重新同步。</p><blockquote><p>补充：DNS缓存的位置有很多，例如：本地操作系统缓存表、浏览器缓存、家用路由器缓存、以及递归DNS 服务器缓存。</p></blockquote><h2 id="域名劫持">域名劫持</h2><h3 id="什么是域名劫持">什么是域名劫持</h3><p>刚才说了，域名服务器上都会保存一大堆的域名记录（每条记录包含“域名”和“IP地址”）。当收到域名查询的时候，域名服务器会从这堆记录中找到对方想要的，然后回应给对方。</p><p>如果域名服务器上的某条记录被【<strong>人为修改</strong>】了（改成错的），那么一旦要查询这条记录，得到的就是错误的结果。这种情况称之为“<strong>域名劫持</strong>”（DNShijacking）。</p><blockquote><p>域名劫持（DNShijacking）通常是指攻击者篡改了DNS解析链条中某个关键环节的记录，导致用户访问某个域名时被导向了错误甚至恶意的IP地址。具体来说，劫持可能发生在以下几类域名服务器上的记录被篡改：</p><ul><li>权威服务器。攻击者入侵权威服务器并修改某个域名的 A 记录、CNAME等，从根源上篡改，这时最严重的劫持，影响所有查询该域名的用户。</li><li>递归 DNS 服务器的缓存被篡改，也叫<strong>DNS缓存污染</strong>。攻击者可以通过“<strong>缓存投毒</strong>”（DNS cachepoisoning）攻击，向递归服务器注入伪造的 DNS记录。这样，当用户通过该递归服务器查询域名时，得到的是伪造的错误IP。影响使用该递归服务器的用户。</li><li>本地 hosts 文件或本地 DNS 解析配置被篡改。恶意软件可以篡改用户本地的hosts 文件。只影响用户本机。</li><li>中间代理被篡改。代理 DNS服务器的记录被篡改，影响使用该代理服务器的所有用户。</li></ul></blockquote><h3 id="谁干的">谁干的</h3><p>　“域名劫持”通常是<strong>电信运营商</strong>（ISP）干的好事儿。很多宽带用户用的域名服务器就是ISP 提供给你的。而天朝的 ISP 也是很奇葩的——经常耍流氓。</p><p>举例： 前几年曾经出现过：某个 ISP跟百度勾结，把谷歌的流量重定向到百度。具体搞法是：该 ISP篡改自己的域名服务器的记录，把里面跟 google.com 相关的域名记录的 IP地址修改为百度服务器的 IP 地址。如此一来，假设你用的是这个 ISP的域名服务器，当你在浏览器输入 www.google.com 的时候，你的电脑查询到的IP 地址其实是百度的 IP地址，所以浏览器打开的是“百度”的主页。（这就属于权威服务器的域名劫持，最严重的一种情况）</p><h3 id="如何应对">如何应对</h3><p>刚才说了，“域名劫持”的根源在于：域名服务器上的记录被人给改了。要对付这种耍流氓，最直接的办法就是不要使用这种流氓ISP 提供的域名服务器，改用国外那些比较靠谱的。目前口碑最好的，大概是Google 提供的两个域名服务器，IP 地址分别是 8.8.8.8 和 8.8.4.4——这俩不光是地址好记，更重要的是，不会耍流氓搞劫持。</p><h2 id="域名污染">域名污染</h2><p>定义：<strong>专指攻击者通过向递归DNS服务器注入伪造的错误DNS记录，使该递归服务器缓存了错误的解析结果</strong>。是一种域名劫持的具体手段。</p><blockquote><p>WIKI:</p><p>网域服务器缓存污染（英语：<strong>DNS cachepollution</strong>）、<strong>DNS污染或DNS劫持</strong>，是一种破坏域名系统查询解析的行为，通常由计算机程序自动执行，从而导致DNS 服务器缓存错误记录，又称域名服务器缓存投毒（DNS cache poisoning）和DNS缓存投毒。污染一词可能取自域名系统域名解析之特性，若递归DNS解析器查询上游时收到错误回复，所有下游也会受影响。</p><p>这些篡改可能是出于恶意目的，例如网络钓鱼；也可能是出于<strong>互联网服务提供商</strong>（ISP）的自身目的，例如<strong>防火长城</strong>以及公共或路由器提供的DNS 服务提供商将用户的网络流量引导至 ISP 自己的 web服务器，以便投放广告、收集统计数据或实现ISP的其他目的（<strong>引流</strong>）；还可能是DNS服务提供商为了阻止对特定域名的访问而采取的一种<strong>审查</strong>形式。</p></blockquote><hr /><p>“域名污染”的原理，简单说来是这样滴：当你的电脑向域名服务器发送了“域名查询”的请求，然后域名服务器把回应发送给你的电脑，这里存在一个【<strong>时间差</strong>】。如果某个攻击者能够在域名服务器的“DNS 应答”还没有到达你的电脑之前，先伪造一个错误的“DNS应答”发给你电脑。那么你的电脑收到的就是错误的信息，并得到一个错误的 IP地址。</p><h2 id="gfw-的域名污染">GFW 的域名污染</h2><p>GFW部署在天朝互联网的国际出口，三板斧：</p><ol type="1"><li><strong>DNS 污染</strong></li><li><strong>IP 封锁</strong>，采用黑名单机制</li><li><strong>敏感词过滤</strong>，GFW维护一个很长的敏感词列表，如果你的网站中包含<strong>任何一个</strong>敏感词，GFW会通过技术手段屏蔽该页面</li></ol><p>GFW有两种污染方式：直接污染，间接污染。使用国外的域名服务器会受到直接污染，使用国内的域名服务器会受到间接污染。</p><h3 id="gfw-的部署位置">GFW 的部署位置</h3><p>天朝的互联网只有少数几个<strong>国际出口</strong>（名气较大的是：北京出口、上海出口、广州出口）。如果你要访问天朝之外的网站，你的网络数据流就必定会经过其中的某个“国际出口”。而天朝的【<strong>每一个</strong>】国际出口都部署了GFW 的设备。</p><h3 id="gfw-直接污染">GFW 直接污染</h3><p>因为 GFW部署在天朝的【国际出口】。如果你用的是<strong>国外的域名服务器</strong>，你的“DNS 请求”必定会经过国际出口；同样，域名服务器的“ DNS应答”必定也会经过国际出口才能到你的电脑。这一来一回就给 GFW提供了耍流氓的机会。</p><h3 id="gfw-间接污染">GFW 间接污染</h3><ol type="1"><li>你用的是国内的域名服务器，想访问某个被大陆封杀的网站。</li><li>被封杀的网站，它的权威服务器肯定在国外</li><li>当你向国内的DNS服务器查询的时候，这个DNS服务器需要从国外进行域名查询</li><li><strong>正是因为从国外进行域名查询，所以相关的数据流必定会经过国际出口，一旦经过国际出口，必定会被GFW 污染</strong></li><li>所以 DNS服务器返回的是被污染的域名记录，而且，<strong>国内的DNS服务器会把这条错误的记录缓存下来</strong>。</li><li>于是乎~如果以后还有人查询这个域名，也会得到错误的结果</li></ol><p>上述过程不断重复，最终会导致：全国所有的域名服务器，它们的缓存中只要是包含了那个反共网站的记录，记录中的“IP地址”必定是错的（这个错误的“IP 地址”也就是 GFW伪造的那个）。所以说“间接污染”是很牛逼滴——可以把错误的域名记录扩散到全国。</p><p>刚才俺说了，“域名污染”也叫“域名缓存投毒”。<strong>“投毒”一词真的非常形象——就好象在某条河流的【源头】下毒，从而把整条河流的水都污染</strong>。在互联网时代搞“域名污染”是非常卑鄙下流的做法。因为DNS是互联网的基础设施，<strong>而“域名污染”直接破坏了互联网的基础设施</strong>。</p><h3 id="如何应对域名污染域名欺骗">如何应对域名污染/域名欺骗</h3><p>下面这篇教程介绍了四种新的域名协议，有效对抗GFW。</p><p>https://program-think.blogspot.com/2018/10/Comparison-of-DNS-Protocols.html</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-短信登录功能</title>
    <link href="/2025/06/17/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/"/>
    <url>/2025/06/17/Redis%E5%AE%9E%E6%88%98%E7%AF%87-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://s21.ax1x.com/2025/06/15/pVAvgPI.png" alt="总览" /><figcaption aria-hidden="true">总览</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/06/15/pVAxkz6.png" alt="项目架构" /><figcaption aria-hidden="true">项目架构</figcaption></figure><h1 id="短信登录">短信登录</h1><h2 id="回顾cookiesession基础">回顾：cookie&amp;session基础</h2><p><code>cookie</code>是一种客户端会话技术, cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。</p><ul><li><strong>服务端</strong>创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li><li><strong>客户端</strong>在收到服务端发来的cookie的响应头后,在以后每次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种<strong>键值对</strong>格式的数据,从 tomcat8.5开始可以保存中文,但是不推荐</li><li>由于cookie是存储于客户端的数据,比较容易暴露,<strong>一般不存储一些敏感或者影响安全的数据</strong></li></ul><figure><img src="https://s21.ax1x.com/2025/05/13/pEX78OA.png" alt="原理图" /><figcaption aria-hidden="true">原理图</figcaption></figure><p><code>HttpSession</code>是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象.客户端在发送请求时,都可以使用自己的session.这样服务端就可以通过session来记录某个客户端的状态了。</p><ul><li>Session 依赖 Cookie 来实现识别用户身份。</li><li>通常，服务器在创建一个 Session 时，会生成一个唯一的 SessionID。</li><li>这个 Session ID 会通过 Set-Cookie响应头被发送到客户端，客户端会把这个 ID 保存在 Cookie 中。</li><li>后续客户端的请求会自动携带这个 Session ID 的Cookie，服务器就可以用这个 ID 找回之前保存的 Session数据，从而识别用户状态。</li></ul><figure><img src="https://s21.ax1x.com/2025/05/14/pEjl0Cn.png"alt="Session的原理图" /><figcaption aria-hidden="true">Session的原理图</figcaption></figure><p><strong>示例</strong>：假如有一个表单name属性为<code>username</code>，现在使用ServeletA 将表单提交的用户名存入Session：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletA&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取请求中的参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">// 获取session对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>         <span class="hljs-comment">// 获取Session的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jSessionId</span> <span class="hljs-operator">=</span> session.getId();<br>        System.out.println(jSessionId);<br>        <span class="hljs-comment">// 判断session是不是新创建的session</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNew</span> <span class="hljs-operator">=</span> session.isNew();<br>        System.out.println(isNew);<br>        <span class="hljs-comment">// 向session对象中存入数据</span><br>        session.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码调用了<code>getSession()</code>方法，使用<code>getSession()</code>方法可以<strong>获取当前会话的实例</strong>，同时为会话创建一个新的<code>cookie</code>，获取的逻辑如下：</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEjluAH.png"alt="getSession方法的操作逻辑" /><figcaption aria-hidden="true">getSession方法的操作逻辑</figcaption></figure><p>于是， ServletA执行以后，返回给客户端的响应中会包含一个键为<code>JSESSIONID</code>的cookie。以后客户端向服务器发出的请求头都会包含该cookie。</p><p>然后在另一个ServletB中就可以取出用户名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletB&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取session对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>         <span class="hljs-comment">// 获取Session的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jSessionId</span> <span class="hljs-operator">=</span> session.getId();<br>        System.out.println(jSessionId);<br>        <span class="hljs-comment">// 判断session是不是新创建的session</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNew</span> <span class="hljs-operator">=</span> session.isNew();<br>        System.out.println(isNew);<br>        <span class="hljs-comment">// 从session中取出数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String)session.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br>        System.out.println(username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="系统框图">系统框图</h2><figure><img src="https://s21.ax1x.com/2025/06/16/pVEAkAf.png" alt="系统框图" /><figcaption aria-hidden="true">系统框图</figcaption></figure><h2 id="发送短信验证码">发送短信验证码</h2><p>业务逻辑：</p><ol type="1"><li>用户提交手机号，后端的<code>UserController</code>接收该手机号和用户所在的会话</li><li>在服务层中做出如下判断：<ol type="1"><li>校验手机号是否合法</li><li>如果手机号不存在，返回错误信息</li><li>如果手机号存在，生成验证码</li><li>保存验证码到当前会话</li><li>向用户发送验证码</li></ol></li></ol><p>控制层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送手机验证码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;code&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// TODO 发送短信验证码并保存验证码</span><br>    <span class="hljs-keyword">return</span> userService.sendCode(phone, session);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了服务层的<code>sendCode</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">// 校验手机号</span><br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-comment">// 如果手机号不合法，返回错误信息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 手机号合法，生成验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<span class="hljs-comment">// 生成6位随机数</span><br><br>        <span class="hljs-comment">// 保存验证码到 session</span><br>        session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>, code);<br><br>        <span class="hljs-comment">// 发送验证码</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>log.debug</code>代替实际的发送验证码功能（因为要花钱）</p><h2 id="基于session实现登录">基于Session实现登录</h2><p>这一块将登录和注册合二为一。</p><p>控制层：接收登录参数，包含手机号、验证码；或者手机号、密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;<br>    <span class="hljs-comment">// TODO 实现登录功能</span><br>    <span class="hljs-keyword">return</span> userService.login(loginForm, session);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务层的代码使用<strong>反向嵌套</strong>，防止嵌套越嵌越深。具体如下：（UserServiceImpl）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 如果手机号不合法，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 校验验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">correctCode</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>); <span class="hljs-comment">// 会话保存的验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">userCode</span> <span class="hljs-operator">=</span> loginForm.getCode(); <span class="hljs-comment">// 用户提交的验证码</span><br>    <span class="hljs-keyword">if</span> (correctCode == <span class="hljs-literal">null</span> || !correctCode.equals(userCode)) &#123;<br>        <span class="hljs-comment">// 验证码不一致</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通过验证，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">// 用户不存在，创建新用户</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        user = createUserWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">// 这样确保user一定有值</span><br><br>    <span class="hljs-comment">// 保存用户信息到session</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-comment">// 创建用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    save(user); <span class="hljs-comment">// mybatisPlus 提供的save方法</span><br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p>如前所述，访问服务器的时候，服务器返回给客户端的响应头中包含键为Session ID 的cookie 字段，后续客户端的请求会自动携带这个 Session ID 的Cookie，服务器就可以用这个 ID 找回之前保存的 Session数据，从而识别用户状态。所以这里<strong>不需要</strong>JWT令牌。</p><ul><li>在服务层，仍然要先校验手机号是否合法，然后再校验验证码。</li><li>手机号+验证码校验通过之后：<ul><li>如果数据库中能查到这个手机号用户，就赋值给<code>user</code>对象</li><li>如果没有，就INSERT新用户，然后赋值给<code>user</code>对象</li></ul></li><li>到这里<code>user</code>对象必定不为空，保存到会话中。</li></ul><hr /><p>发送验证码——填写验证码——按下登录按钮后，后台打印部分日志：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">HikariPool-1 - Starting...<br>HikariPool-1 - Start completed.<br>=<span class="language-ruby">=&gt;  <span class="hljs-title class_">Preparing</span>: <span class="hljs-variable constant_">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time <span class="hljs-variable constant_">FROM</span> tb_user <span class="hljs-variable constant_">WHERE</span> (phone = <span class="hljs-string">?)</span></span><br>=<span class="language-ruby">=&gt; <span class="hljs-title class_">Parameters</span>: xxxxxxxxx(<span class="hljs-title class_">String</span>)</span><br>&lt;==      Total: 0<br>=<span class="language-ruby">=&gt;  <span class="hljs-title class_">Preparing</span>: <span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> tb_user ( phone, nick_name, icon ) <span class="hljs-variable constant_">VALUES</span> ( <span class="hljs-string">?,</span> <span class="hljs-string">?,</span> ? )</span><br>=<span class="language-ruby">=&gt; <span class="hljs-title class_">Parameters</span>: xxxxxxxxx(<span class="hljs-title class_">String</span>), user_dvz2bph7ax(<span class="hljs-title class_">String</span>), (<span class="hljs-title class_">String</span>)</span><br>&lt;==    Updates: 1<br></code></pre></td></tr></table></figure><p>一共对数据库进行两次操作：<code>SELECT</code>查询用户是否存在，和<code>INSERT</code>添加新用户。</p><p>这里用到了<code>HikariCP</code>连接池，这是 Java中速度最快的连接池的实现，是 SpringBoot的默认连接池。连接池是用来复用数据库连接的一种机制，创建和关闭数据库连接是很昂贵的操作，连接池提前维护好一组可用连接，供应用程序重复使用。</p><h2id="基于sessionthreadlocal的登录验证">基于Session+ThreadLocal的登录验证</h2><h3 id="处理思路">处理思路</h3><p>登录成功后，用户的每一次请求都会带上包含 session id的cookie，服务端从这里识别用户状态。考虑到后续每个功能都需要识别用户状态之后才能执行，所以这里要配置一个拦截器，通过验证才放行。</p><blockquote><p>过滤器是tomcat实现的，拦截器是springmvc实现的，过滤器的功能拦截器也能做到，且拦截器的功能更全，一般都是用拦截器。</p></blockquote><figure><img src="https://s21.ax1x.com/2025/06/16/pVEV3pF.png" alt="拦截器" /><figcaption aria-hidden="true">拦截器</figcaption></figure><p>还有一个问题：拦截器是能完成用户校验不假，但是在后续的业务中其他的模块也需要用到用户信息，所以需要把拦截得到的用户信息向后传递，同时保证线程安全，使用<code>ThreadLocal</code>可以做到这一点。</p><p><code>ThreadLocal</code>具体介绍详见<ahref="https://kznleaf.top/2025/06/07/ThreadLocal%E5%89%96%E6%9E%90/">https://kznleaf.top/2025/06/07/ThreadLocal%E5%89%96%E6%9E%90/</a></p><p>有了 ThreadLocal ，校验登录状态的流程图如下：</p><figure><img src="https://s21.ax1x.com/2025/06/16/pVEVs6H.png"alt="校验登录状态" /><figcaption aria-hidden="true">校验登录状态</figcaption></figure><h3 id="threadlocal工具类">ThreadLocal工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-comment">// ThreadLocal&lt;T&gt; 此处 T 即 UserDTO 实体类，</span><br>    <span class="hljs-comment">// 即 ThreadLocalMap 的键值对的 value 的类型为 UserDTO</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tl</code>全局唯一，并且随类对象的加载一起被加载。</p><h3 id="entity与dto">Entity与DTO</h3><p>Entity，<strong>实体类</strong>，它的字段与数据库中的列一一对应，用于数据库操作；</p><p>DTO，Data Transfer Object，即<strong>数据传输对象</strong>，是 Java编程中很常见的设计模式。</p><p>DTO 用来在不同系统或模块之间传递数据的对象。在实际开发中，尤其是 Web项目里，我们常常要在控制器、服务层、数据库层之间传递数据。为了避免直接暴露数据库实体（如UserEntity），我们会用 DTO 来进行封装。</p><p>总之，之所以专门再封装一遍，有两个主要原因：</p><ol type="1"><li>数据库实体可能包含像用户密码这样的敏感信息，这类信息应当被隐藏</li><li>很多情况下我们只需要用到一部分实体类的信息，那么就只把有用的信息记录下来，只传输封装后的对象，这样可以减轻数据传输的压力</li></ol><p><strong>实体类用于与数据库交互，与数据库结构强绑定；DTO用于数据传输，可以根据业务场景灵活配置</strong>。</p><p>以本项目为例，在验证用户登录状态的过程中，需要传输字段其实只有三个：</p><ul><li>id</li><li>nickName</li><li>icon</li></ul><p><code>User</code>实体类的其他字段在这里都不重要。所以不妨再定义一个专门用于数据传输的实体类<code>UserDTO</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmdp.dto;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDTO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">private</span> String icon;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实上面的<code>ThreadLocal</code>保存的也是这里的<code>UserDTO</code>对象。</p><p>在服务层或控制器层，需要把实体类对象转化为对应的 DTO 对象，幸运的是Spring已经准备好了对应的工具类：<code>BeanUtils</code>，它包含以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyProperties</span><span class="hljs-params">(Object source, Object target)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    copyProperties(source, target, (Class)<span class="hljs-literal">null</span>, (String[])<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数是实体类，第二个参数是DTO。这样就可以把实体类中的字段复制到 DTO 对象的相应字段上。</p><h3 id="登录验证实现">登录验证实现</h3><p>手续需要修改登录的服务层方法，将<code>UserDTO</code>对象存入 session而不是 User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>BeanUtils.copyProperties(user, userDTO);<br><span class="hljs-comment">// 保存用户信息到session</span><br>session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, userDTO);<br><br><span class="hljs-keyword">return</span> Result.ok(); <span class="hljs-comment">// 别返回null！</span><br></code></pre></td></tr></table></figure><p>然后配置拦截器，尝试获取当前会话中的用户，如果获取失败就拦截并返回401，获取成功就把DTO对象放入ThreadLocal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-comment">// 前置拦截</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">// 2. 获取用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> (UserDTO) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// 3. 不存在，拦截</span><br>        <span class="hljs-keyword">if</span> (userDTO == <span class="hljs-literal">null</span>) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <span class="hljs-comment">// 401</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4. 保存到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO); <span class="hljs-comment">// 保存用户信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放行</span><br>    &#125;<br><br>    <span class="hljs-comment">// Spring DispatcherServlet 在完成一次 HTTP 请求的整个处理流程后，</span><br>    <span class="hljs-comment">// 自动调用 afterCompletion</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用自动装配的方式注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCconfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>, <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/*&quot;</span><br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集群的session共享问题">集群的session共享问题</h2><p>前面提到过，<code>HttpSession</code>是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象。客户端在发送请求时,都可以使用自己的session.这样服务端就可以通过session来记录某个客户端的状态了。</p><p>但是，多台Tomcat服务器并不共享session存储空间，当用户请求切换到不同服务器的时候会导致数据丢失。</p><figure><img src="https://s21.ax1x.com/2025/06/16/pVEn68f.png" alt="集群" /><figcaption aria-hidden="true">集群</figcaption></figure><p>解决方案：<strong>Redis</strong></p><p>Redis是如何解决这三个问题的？</p><ol type="1"><li>数据共享：所有的tomcat都可以访问Redis，所以Redis的数据是被共享的；</li><li>内存存储：Redis就是在内存中运行的；</li><li>key-value结构：天然符合。</li></ol><figure><img src="https://s21.ax1x.com/2025/06/16/pVEnfbj.png" alt="Redis" /><figcaption aria-hidden="true">Redis</figcaption></figure><h2 id="基于redis实现共享session登录">基于Redis实现共享session登录</h2><h3 id="方案">方案</h3><p>Redis代替SESSION要考虑的问题：</p><ol type="1"><li>选择合适的数据结构<ol type="1"><li><code>key-String</code>，后者是用户对象的 JSON 字符串</li><li><code>key-&#123;field=value&#125;</code>，Hash结构，一个<code>key</code>可以有多个<code>field=value</code>键值对；内存占用更少</li></ol></li><li>选择合适的key：唯一性，以及需要用的时候能不能快速找到</li><li>选择合适的存储粒度，很多时候没必要存储完整的用户信息</li></ol><p>采用 Hash 的方案：</p><p><img src="https://s21.ax1x.com/2025/06/16/pVEnzI1.png" /></p><ul><li>发送验证码之前，把验证码以<strong>特定前缀+手机号</strong>为key存储到Redis（防止与其他业务冲突）；</li><li>用户使用验证码登录注册，根据用户输入的手机号为key从Redis读取验证码，比较读取的验证码和输入的验证码是否匹配；</li><li>如果匹配成功，把用户DTO对象以<strong>随机token</strong>为key存储到Redis</li></ul><p>还有一个问题：如何确保前端能拿到登录凭证？解决方法是每次把用户DTO对象存储到Redis后，把存储用的token<strong>返回给前端</strong>，这样前端每次发来请求的时候都可以拿着这个token进行登录校验。流程如下图：</p><p><img src="https://s21.ax1x.com/2025/06/16/pVEuCRK.png" /></p><p>前端收到token以后会直接把它保存到浏览器，所以这里的 token不能用手机号，会有泄露的风险。校验工作还是后端做的，，以 HTTP请求中保存的 token 为 key 从 Redis 获取用户 DTO对象，找到对应用户的话就保存一份到 ThreadLocal，然后放行。</p><p>下面基于以上方案重写功能。</p><h3 id="发送短信">发送短信</h3><p>以前把验证码保存在session中，现在把验证码保存到Redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 如果手机号不合法，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 手机号合法，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<span class="hljs-comment">// 生成6位随机数</span><br><br>    <span class="hljs-comment">// 保存验证码到 Redis  |  SET key value ex</span><br>    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br><br>    <span class="hljs-comment">// 发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>核心是这一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 保存验证码到 Redis  |  SET key value ex</span><br>stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p>保存到Redis，key的格式类似于<code>login:code:手机号</code>，值就是验证码，有效时间为2min。</p><p>发送短信的过程不需要查询Redis，只检查手机号是否合法，然后把验证码存起来用于登录。</p><h3 id="登录">登录</h3><p>业务逻辑：</p><ul><li>用户发来登录用的手机号和验证码，服务器从 Redis获取正确的验证码和用户提交的<code>loginForm</code>里的验证码比较，匹配则进行下一步</li><li>查询数据库是否存在这个手机号，如果存在就直接把用户 DTO 对象存到Redis，不存在则向数据库插入数据之后再把 DTO 存到 Redis，存储的 key的格式类似<code>login:token:e64c7c4b-af46-428b-896b-26d0d18e6d6c</code>，value为field value 键值对。</li><li>初次登陆会为 Redis 里的 token设置一个有效期30分钟，如果三十分钟内用户没有进行操作则登录过期。在拦截器里更新过期时间，每当用户操作就刷新有效期。</li><li>login 控制器结束的时候为前端返回token，以后前端每次发请求都会包含这个 token。</li></ul><p>具体代码就不贴了，这里比较重要的有：</p><p>生成随机token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br></code></pre></td></tr></table></figure><p>把一个DTO对象以Hash类型存储到Redis里面：<code>StringRedisTemplate</code>包含下面的方法，可以一次插入包含多个键值对的Hash类型数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(H key, Map&lt;? extends HK, ? extends HV&gt; m)</span>;<br></code></pre></td></tr></table></figure><p>key不必多说，Map的话可以单独定义一个方法，将UserDTO的字段放入一个哈希表中，再调用putAll。</p><p>先自动装配StringRedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br></code></pre></td></tr></table></figure><p>考虑到放入、取出 UserDTO对象的方法都会被用到，所以写两个工具方法：</p><ul><li><code>saveUserToRedis</code>：将<code>userDTO</code>对象的所有字段格式化为哈希表，然后以Hash类型存入Redis</li><li><code>getUserFromRedis</code>：根据请求头中的<code>token</code>从Redis中尝试获取对应的用户，如果获取到了就返回用户的DTO对象，如果没有获取到就返回<code>null</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存储用户信息到Redis</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUserToRedis</span><span class="hljs-params">(String token, UserDTO userDTO)</span> &#123;<br>    Map&lt;String, String&gt; userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    userMap.put(<span class="hljs-string">&quot;id&quot;</span>, userDTO.getId().toString());<br>    userMap.put(<span class="hljs-string">&quot;nickName&quot;</span>, userDTO.getNickName());<br>    userMap.put(<span class="hljs-string">&quot;icon&quot;</span>, userDTO.getIcon());<br>    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br>    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>&#125;<br><br><span class="hljs-comment">// 从Redis读取用户信息</span><br><span class="hljs-keyword">private</span> UserDTO <span class="hljs-title function_">getUserFromRedis</span><span class="hljs-params">(String token)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);<br>    <br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>    userDTO.setId(Long.parseLong((String) userMap.get(<span class="hljs-string">&quot;id&quot;</span>)));<br>    userDTO.setNickName((String) userMap.get(<span class="hljs-string">&quot;nickName&quot;</span>));<br>    userDTO.setIcon((String) userMap.get(<span class="hljs-string">&quot;icon&quot;</span>));<br>    <br>    <span class="hljs-keyword">return</span> userDTO;<br>&#125;<br></code></pre></td></tr></table></figure><p>登录用的是<code>saveUserToRedis</code>。</p><h3 id="拦截器">拦截器</h3><p>这个拦截器只拦截需要登录的路径。</p><p><code>preHandle</code>里一共做四件事：</p><ol type="1"><li>获取请求头中的token，获取失败则拦截，可以使用<code>StringUtils.hasLength(token)</code>判断</li><li>调用<code>getUserFromRedis</code>查询Redis保存的用户信息</li><li>如果获取为null则继续拦截，不为null就保存到ThreadLocal</li><li>刷新token的有效期</li><li>放行</li></ol><p><code>afterCompletion</code>只做一件事：清除ThraedLocal绑定的局部变量，防止内存泄漏。</p><h3 id="登录状态刷新-双拦截器">登录状态刷新-双拦截器</h3><p>之前的拦截器只拦截了需要登录的路径，只有用户访问了这些页面才会刷新token有效时间。如果用户在登录后一直在不被它拦截的页面停留，token还会过期，不合理。</p><p>所以在原来的拦截器的前面再加上一个拦截器，拦截一切路径。</p><p>用户请求先经过第一个拦截器，拦截所有路径，但是全部放行；第二个拦截器只拦截登录后才能查看的页面，然后查询ThreadLocal的用户，查不到就拦截。</p><p><img src="https://s21.ax1x.com/2025/06/17/pVEGm2n.png" /></p><p><code>order</code>设置拦截器的执行顺序，越小先执行，默认都是0.按照添加顺序执行。</p><p>第一个拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">preInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">// 前置拦截</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// TODO 1. 获取请求头中的 token(uuid)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasLength(token)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 没有获取到 token ，放行</span><br>        &#125;<br>        <span class="hljs-comment">// TODO 2. 从 Redis 利用 token 获取用户信息</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> getUserFromRedis(token);<br><br>        <span class="hljs-comment">// 3. 用户不存在，放行</span><br>        <span class="hljs-keyword">if</span> (userDTO == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 保存到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO); <span class="hljs-comment">// 保存用户信息</span><br><br>        <span class="hljs-comment">// TODO 刷新 token 的有效期</span><br>        stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放行</span><br>    &#125;<br><br>    <span class="hljs-comment">// Spring DispatcherServlet 在完成一次 HTTP 请求的整个处理流程后，</span><br>    <span class="hljs-comment">// 自动调用 afterCompletion</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br><br>    <span class="hljs-comment">// TODO 从Redis读取用户信息</span><br>    <span class="hljs-keyword">private</span> UserDTO <span class="hljs-title function_">getUserFromRedis</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);<br><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 获取失败</span><br>        &#125;<br><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(); <span class="hljs-comment">// 创建 UserDTO 对象</span><br>        userDTO.setId(Long.parseLong((String) userMap.get(<span class="hljs-string">&quot;id&quot;</span>)));<br>        userDTO.setNickName((String) userMap.get(<span class="hljs-string">&quot;nickName&quot;</span>));<br>        userDTO.setIcon((String) userMap.get(<span class="hljs-string">&quot;icon&quot;</span>));<br><br>        <span class="hljs-keyword">return</span> userDTO; <span class="hljs-comment">// 返回获取的 UserDTO对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册两个拦截器，设置<code>order</code>分别为0和1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCconfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> preInterceptor preInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>, <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/*&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br>        registry.addInterceptor(preInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-经典垃圾收集器</title>
    <link href="/2025/06/14/JVM-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2025/06/14/JVM-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》读书笔记(4)</p><span id="more"></span><h1 id="经典垃圾收集器">经典垃圾收集器</h1><p>各款经典收集器之间的关系如下图：</p><figure><img src="https://s21.ax1x.com/2025/06/04/pVPDtRH.png"alt="HotSpot虚拟机的垃圾收集器" /><figcaption aria-hidden="true">HotSpot虚拟机的垃圾收集器</figcaption></figure><ul><li>不同的垃圾收集器适用的分代也不同，收集器之间的连线表示它们可以搭配使用（但是这种关系不固定）；</li><li>图的上半部分为新生代收集器，下半部分为老年代收集器。</li></ul><blockquote><p>虽然垃圾收集器的技术在不断进步，但直到现在还没有最好的收集器出现，更加不存在“万能”的收集器，所以我们选择的只是对具体应用最合适的收集器。</p></blockquote><h2 id="serial">Serial</h2><p>Serial收集器是最基础、历史最悠久的收集器。特点；</p><ul><li><strong>单线程</strong>，但是特殊的单线程，<strong>它进行垃圾收集时必须暂停其他所有工作线程，直到它收集结束</strong>。</li></ul><figure><img src="https://s21.ax1x.com/2025/06/04/pVPDBeP.png" alt="工作流程" /><figcaption aria-hidden="true">工作流程</figcaption></figure><p>如图，每次 GC之前都要确保所有的线程都已经到达安全点，然后所有的线程被暂停，等待 GC执行完毕。</p><p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。</p><p>优点：</p><ul><li>简单高效，它是所有收集器中额外内存占用最小的一个。</li><li>对于单核处理器，或者本来核心就比较少的处理器，Serial因为专注于单线程，所以效率反而会高。</li></ul><p>如果分配给虚拟机管理的内存本来就不是特别大（比如一些微服务应用），那么每次需要收集的垃圾也并不多，停顿时间不会很长，是足够使用的。</p><h2 id="parnew">ParNew</h2><figure><img src="https://s21.ax1x.com/2025/06/06/pViJeLF.png" alt="ParNew" /><figcaption aria-hidden="true">ParNew</figcaption></figure><p><strong>ParNew 收集器实质上是 Serial收集器的多线程并行版本</strong>，最大的区别是存在多个GC线程，但是GC的过程一样需要暂停所有用户线程。</p><p>ParNew收集器是新生代收集器，也是JDK7之前的老系统的首选处理器，因为只有它能和CMS收集器配合工作，但是后来ParNew和CMS也就只能互相搭配使用，相当于被合并了。</p><div class="note note-success">            <p>补充：关于并发和并行</p><p>并发(Parallel)：在同一个时间段内，有多个任务在交替执行（宏观上同时，微观上轮流），强调的是人物的交替和切换。即使只有一个CPU核，也能做到几乎同时运行多个任务的效果，只要速度足够快。</p><p>并行(Concurrent)：在同一时刻，有多个任务真正同时运行（物理上同时），需要多个CPU核心才能实现，这时真正的同时执行。</p><p>放到这里的语境中，并行指的是多条 GC线程并行执行，即有多个GC线程在同时工作，但是用户线程处于阻塞状态；并发指的是垃圾收集器线程与用户线程并发执行，用户线程和GC 线程之间在快速切换，所以宏观上用户线程仍然处于执行的状态。</p>          </div><p>应该说，为了防止出现分析过程中根节点集合的对象引用关系还在不断变化的情况，GC线程和用户线程是不可能并行进行的，只能交替进行（多个GC线程倒是可以并行），所以效率最高的方式就是GC 和用户线程二者并发。后来出现的 CMS 收集器是 HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><h2 id="parallel-scavenge">Parallel Scavenge</h2><p>并行清除</p><p>也是新生代收集器，基于标记-复制算法，能够多线程并行.</p><p>其他垃圾收集器的关注点都是<em>缩短垃圾收集带来的停顿时间</em>，但是Parallel Scavenge 的关注点是达到一个可控制的吞吐量： <spanclass="math display">\[吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}\]</span>吞吐量越大，程序运行花在垃圾收集上的占比就越小，响应越快，越适合与用户频繁交互的程序。这一收集器也被称作“吞吐量优先收集器“。</p><p>Parallel Scavenge 收集器提供了三个参数用于控制吞吐量：</p><ul><li><code>-XX：MaxGCPauseMillis</code>：控制最大垃圾收集停顿时间，是大于0的毫秒数</li><li><code>-XX：GCTimeRatio</code>：程序运行时间和GC时间之比，大于0小于100的整数，默认99</li><li><code>XX：+UseAdaptiveSizePolicy</code>：激活后，垃圾收集采用自适应的调节策略（GCErgonomics）</li></ul><p>使用<code>-XX：MaxGCPauseMillis</code>减小最大垃圾收集停顿时间是有代价的：通过减小新生代的内存空间大小显然能够缩短垃圾收集消耗的时间，但这样的话<code>Eden</code>区更容易满，GC发生的频率更快。虽然每一次停顿的时间少了，但是停顿的频率变高了，吞吐量可能反而下降。</p><p>调优时，可以把内存管理的任务交给自适应调节策略，然后人工调节最大垃圾收集停顿时间和XX：GCTimeRatio。</p><h2 id="serial-old">Serial Old</h2><p>Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><figure><img src="https://s21.ax1x.com/2025/06/09/pVFllan.png"alt="Serial/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">Serial/SerialOld收集器运行示意图</figcaption></figure><p>图中左侧为 Serial 收集器，基于标记-复制算法；右侧为 Serial Old收集器。</p><h2 id="parallel-old-收集器">Parallel Old 收集器</h2><p>Parallel Old是ParallelScavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 ParallelScavenge 加 Parallel Old 收集器这个组合。工作流程如下：</p><figure><img src="https://s21.ax1x.com/2025/06/09/pVFloJP.png"alt="运行示意图" /><figcaption aria-hidden="true">运行示意图</figcaption></figure><h2 id="cms">CMS</h2><p>CMS(Concurrent MarkSweep)收集器，是一种以获取最短回收停顿时间为目标的收集器，运行在老年代。</p><p>基于<strong>标记-清除</strong>法，运行过程包括四步：</p><ol type="1"><li>初始标记：仅标记GC Roots直接关联到的对象</li><li>并发标记：从直接关联到的对象开始遍历整个对象图</li><li>重新标记：修正并发标记期间，因为用户线程的活动造成的对象标记的变动</li><li>并发清除：清理删除掉标记阶段判断的已经死亡的对象</li></ol><p>初始标记和重新标记这两步都需要暂停用户线程，但是并发标记和并发清除不需要。</p><figure><img src="https://s21.ax1x.com/2025/06/09/pVF8bQK.png"alt="Concurrent Mark Sweep收集器运行示意图" /><figcaption aria-hidden="true">Concurrent MarkSweep收集器运行示意图</figcaption></figure><p>CMS 的缺点：</p><ol type="1"><li>对处理器资源很敏感，因为在并发的过程中需要额外占用一部分处理器的资源用于垃圾收集，虽然用户的线程不会停顿，但是应用程序的响应速度会变慢。</li><li>无法处理浮动垃圾(FloatingGarbage)，浮动垃圾指的是在标记过程结束以后，由于用户的线程仍然在运行，所以会产生新的未被标记的垃圾，这些垃圾只能在下一次被清理。另一方面，由于垃圾收集和用户线程同时进行，所以内存区需要提前进行垃圾收集，在JDK6中老年代收集的触发阈值是92%。可以通过参数<code>-XX：CMSInitiatingOccu-pancyFraction</code>修改CMS触发的百分比。当CMS运行期间预留的内存不够用时，会触发并发失败，JVM临时调用SerialOld重新进行老年代的垃圾收集。</li><li>CMS基于标记-清除算法，收集结束的时候会产生大量的空间碎片，需要再触发FyllGC用于碎片整理。</li></ol><h2 id="garbage-firstg1">Garbage First(G1)</h2><p>垃圾收集器技术发展历史上的里程碑式的成果，开创了收集器面向局部收集的设计思路和基于Region 的内存布局形式。面向服务端。</p><ul><li>MixedGC模式：<strong>面向局部收集</strong>，哪块内存中存放的垃圾数量最多，回收收益最大，就回收哪里，可以面向堆内存任何部分来组成回收集（CollectionSet，一般简称CSet）进行回收</li><li>基于Region的堆内存布局：<strong>把连续的 Java堆划分为多个大小相等的独立区域</strong>（Region），每一个 Region都可以根据需要，扮演新生代的 Eden 空间、Survivor空间，或者老年代空间；收集器能够对扮演不同角色的Region采用不同的策略去处理。<strong>Region是单次回收的最小内存单元</strong>。</li></ul><p>相比于以往固定新生代和老年代分配内存区域大小的方式，这种基于Region的堆内存布局更加灵活。</p><p>G1对大对象的处理：</p><ul><li><code>-XX：G1HeapRegionSize</code>参数指定每个Region区域的大小，一个对象只要超过了一个Region大小的一半即被视为大对象</li><li>对于超过了一个Region大小的超级大对象，将会被存放在N个连续的<code>Humongous Region</code>之中</li></ul><p>G1在进行垃圾收集时，优先收集那些收集价值大的Region，即收集之后能获得最多的空间且处理时间尽可能短的区域，</p><figure><img src="https://s21.ax1x.com/2025/06/10/pVFH1Tf.png"alt="Region堆内存布局中，新生代和老年代的区域不一定连续" /><figcaptionaria-hidden="true">Region堆内存布局中，新生代和老年代的区域不一定连续</figcaption></figure><p>G1的运行过程大致为以下四个步骤：</p><ol type="1"><li>初始标记，只标记和GCRoots对象直接关联的对象，需要暂停线程但是耗时很短</li><li>并发标记：从直接关联到的对象开始遍历整个对象图，与用户线程并发</li><li>最终标记：暂停用户线程，处理原始快照（SATB）</li><li>筛选回收：确定需要回收哪些Region，把需要回收的Region的对象复制到空Region中，然后清理旧Region的所有空间。</li></ol><figure><img src="https://s21.ax1x.com/2025/06/10/pVFHH9e.png"alt="G1收集器运行过程" /><figcaption aria-hidden="true">G1收集器运行过程</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-堆</title>
    <link href="/2025/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <url>/2025/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆的分类">堆的分类</h1><p>先回顾一下完全二叉树。</p><p>完全二叉树是指：如果二叉树除了最后一层有缺失外，其它是满的，且最后一层只有右侧有缺失的叶子节点，则这样的二叉树叫完全二叉树。</p><p><strong>换句话说，完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐</strong>。图示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://jokinkuang.github.io/2017/01/30/complete-binary-tree.html">[1]</span></a></sup>：</p><figure><imgsrc="https://jokinkuang.github.io/w3c/images/algorithm/tree/complete-binary-tree.jpg"alt="完全二叉树图示" /><figcaption aria-hidden="true">完全二叉树图示</figcaption></figure><p>下面来看什么是堆（heap）。<strong>堆是一种特殊的完全二叉树</strong>，可以分为两种类型：</p><ul><li><strong>小顶堆</strong>（minheap）：任意节点的值小于等于其子节点的值。</li><li><strong>大顶堆</strong>（maxheap）：任意节点的值大于等于其子节点的值。</li></ul><figure><imgsrc="https://www.hello-algo.com/chapter_heap/heap.assets/min_heap_and_max_heap.png"alt="小顶堆与大顶堆[2]" /><figcaptionaria-hidden="true">小顶堆与大顶堆<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.hello-algo.com/chapter_heap/heap/">[2]</span></a></sup></figcaption></figure><ul><li>二叉树的根节点称为“堆顶”，底层最靠右的节点称为“堆底”。</li><li>小顶堆的根节点具有最小值，大顶堆的根节点具有最大值。</li></ul><h1 id="应用">应用</h1><p>堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列。从使用角度来看，我们可以将“优先队列”和“堆”看作等价的数据结构（当然底层实现不见得相同）。</p><p>如果面试题需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题。</p><p>在实际应用中，可以使用Java提供的优先队列<code>PriorityQueue</code>建堆:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 初始化小顶堆</span><br> Queue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br> <span class="hljs-comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span><br> Queue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br></code></pre></td></tr></table></figure><p>该建堆方法使用了<code>PriorityQueue.java</code>提供的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">* 该构造器创建一个拥有初始容量（11）且每个元素按照指定的比较器排列的优先队列。</span><br><span class="hljs-comment">* 如果comparator为null，那么会按照自然排序（从小到大）排序。</span><br><span class="hljs-comment">* */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);<br>&#125;<br></code></pre></td></tr></table></figure><p>其他常用方法如下：</p><table><thead><tr><th>操作类型</th><th>方法</th><th>时间复杂度</th><th>含义</th></tr></thead><tbody><tr><td>入队 / 出队</td><td><code>offer()</code>, <code>poll()</code></td><td>O(log n)</td><td>插入或取出堆顶元素</td></tr><tr><td>删除指定对象 / 查找</td><td><code>remove(obj)</code>, <code>contains(obj)</code></td><td>O(n)</td><td>在整个堆里查找/删除某个对象</td></tr><tr><td>查看堆顶 / 队列大小</td><td><code>peek()</code>, <code>element()</code>,<code>size()</code></td><td>O(1)</td><td>访问不移除堆顶元素 / 获取大小信息</td></tr></tbody></table><p>注意：</p><ol type="1"><li>没有<code>push</code>和<code>pop</code></li><li>算法最常用：<code>offer</code> <code>poll</code><code>isEmpty</code> <code>size</code></li><li><code>PriorityQueue</code><strong>并不保证迭代顺序是有序的</strong>，它只保证每次调用出堆和入堆时拿到的是最小（或最大）的元素。举个例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 输入列表并建堆 */</span><br>minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">/*PriorityQueue 并不保证迭代顺序是有序的！*/</span><br>minHeap.forEach((a) -&gt; System.out.print(a + <span class="hljs-string">&quot;\t&quot;</span>));<br></code></pre></td></tr></table></figure><p>打印结果：<code>1 3   2   5   4</code>，所以不要指望通过这种方式按顺序遍历堆了。</p><h1 id="底层结构">底层结构</h1><p>Java中的<code>PriorityQueue</code>的<strong>底层是数组实现的平衡二叉堆</strong>，并不是指针型二叉树。不妨看看下面的<code>grow</code>方法，优先队列的<code>add</code>中就调用了该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">* Increases the capacity of the array.</span><br><span class="hljs-comment">* Params:minCapacity – the desired minimum capacity</span><br><span class="hljs-comment">* */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> queue.length;<br>    <span class="hljs-comment">// Double size if small; else grow by 50%</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> ArraysSupport.newLength(oldCapacity,<br>            minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span><br>            oldCapacity &lt; <span class="hljs-number">64</span> ? oldCapacity + <span class="hljs-number">2</span> : oldCapacity &gt;&gt; <span class="hljs-number">1</span><br>                                       <span class="hljs-comment">/* preferred growth */</span>);<br>    queue = Arrays.copyOf(queue, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>明显是对数组的操作。</p><p>虽然堆是一种特殊的完全二叉树，属于非线性的数据结构，但是堆在存储的时候完全可以使用线性数据结构来存储。也就是说，<strong>逻辑上是树形结构，物理上还是线性存储的</strong>。</p><p>而且，在堆的实现中，数组比链表指针结构更加高效，具体体现在： -结构紧凑 - 支持随机访问 - 堆调整只需要交换数组元素，效率高</p><p>而指针型二叉树结构虽然清晰，但是内存开销大、难以高效地进行堆调整（比如上浮、下沉操作）。</p><p>至于怎么使用数组存储二叉树，可以看看下面这张图：</p><figure><img src="https://s21.ax1x.com/2025/05/25/pVSKEHU.png"alt="用数组存储堆" /><figcaption aria-hidden="true">用数组存储堆</figcaption></figure><p>实现方法有两种：从索引 0 开始存储数据，和从索引 1开始存储数据。上图演示的是前者。用数组存储的方式遵循如下规律：</p><figure><img src="https://s21.ax1x.com/2025/05/25/pVSKTVU.png"alt="数组-堆特征" /><figcaption aria-hidden="true">数组-堆特征</figcaption></figure><p>这样以来，只要知道了一个节点的索引，就可以很轻松地定位其父节点和子节点。</p><h1 id="手写小顶堆">手写小顶堆</h1><p>下面根据 <ahref="https://www.hello-algo.com/chapter_heap/heap/#2">Hello算法</a>和jdk源码手写一个固定容量的整数小顶堆。</p><h2 id="堆的存储与表示">堆的存储与表示</h2><p>堆的初始化（源码中优先队列的初始默认容量也是11），这里创建一个固定容量的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br><br><span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] minHeap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PQ</span><span class="hljs-params">()</span> &#123;<br>    minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[DEFAULT_INITIAL_CAPACITY];<br>    size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据前面得到的索引与堆中元素的映射关系，写出获取节点索引的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*索引映射*/</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">left</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">right</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 向下整除</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问堆顶元素">访问堆顶元素</h2><p>这个很简单，因为是从索引 0 开始存储的，获取索引 0的值就好了。源码中的<code>peek</code>如下，可以看到java也是从0位置开始存储元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) queue[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>自己写的<code>peek</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> minHeap[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="入堆">入堆</h2><p>先把新元素放在堆底，然后不断上移它，直到它大于等于其父节点，或者直接成为根节点，来维持一个小顶堆。入堆操作的时间复杂度是O(logn)。</p><p>从底至顶进行堆化，或者叫做<strong>上浮（siftUp）</strong>。先看看源码中是怎么做的（源码对变量的起名其实也挺随意的...）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<br>    siftUp(i, e);<br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)<br>        siftUpUsingComparator(k, x, queue, comparator);<br>    <span class="hljs-keyword">else</span><br>        siftUpComparable(k, x, queue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>comparator</code>为<code>null</code>的情况下，执行的代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">* k: 当前插入元素的索引位置</span><br><span class="hljs-comment">* x: 当前要插入的元素</span><br><span class="hljs-comment">* es: PriorityQueue 底层使用的数组</span><br><span class="hljs-comment">* */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] es)</span> &#123;<br>    <span class="hljs-comment">// 将元素 x 强制转换为可比较类型 Comparable，以便后续调用 compareTo 方法</span><br>    Comparable&lt;? <span class="hljs-built_in">super</span> T&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;) x;<br><br>    <span class="hljs-comment">// 当前元素不是根节点(k=0)时执行：</span><br>    <span class="hljs-comment">// k 来源于 size，正常情况下都是大于0的，如果等于0那就把它当作新的根节点</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 计算当前元素的父节点的索引，相当于除以2</span><br>        <span class="hljs-comment">// 使用移位能够提高运行速度，并且适用于大数的情形</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//获取父节点元素</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> es[parent];<br>        <span class="hljs-comment">// 比较当前节点元素与父节点 e 的大小，符合规则就退出</span><br>        <span class="hljs-keyword">if</span> (key.compareTo((T) e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 如果当前元素小于父节点，则违反了小顶堆的性质</span><br>        <span class="hljs-comment">// 将当前位置 k 替换为父节点，然后继续向上检查父节点</span><br>        es[k] = e;<br>        k = parent;<br>    &#125;<br>    es[k] = key;<br>&#125;<br></code></pre></td></tr></table></figure><p>据此可以写出自己实现的小顶堆的offer方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*元素入堆*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span>(size &gt;= minHeap.length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Heap overflow&quot;</span>);<br>    siftUp(i, val, minHeap);<br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> currentIndex, <span class="hljs-type">int</span> insertVal, <span class="hljs-type">int</span>[] es)</span> &#123;<br>    <span class="hljs-keyword">while</span>(currentIndex &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父节点的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parentIndex</span> <span class="hljs-operator">=</span> (currentIndex - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 父节点元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parentVal</span> <span class="hljs-operator">=</span> es[parentIndex];<br>        <span class="hljs-keyword">if</span>(insertVal &gt;= parentVal)<br>            <span class="hljs-keyword">break</span>;<br>        es[currentIndex] = parentVal;<br>        currentIndex = parentIndex;<br>    &#125;<br>    <span class="hljs-comment">// 出循环之后，currentIndex就是插入的元素该放的正确位置</span><br>    es[currentIndex] = insertVal;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆顶元素出堆">堆顶元素出堆</h2><p>通常只删除位于堆顶部的元素。如果删除最大堆的顶部节点，则将堆最低层最右边的节点移到堆的顶部。如果此时它的左子节点或右子节点的值大于它，那么它和左右子节点中值较大的节点交换。如果交换之后节点的值仍然小于它的子节点的值，则再次交换，直到该节点的值大于或等于它的左右子节点的值，或者到达最低层为止。删除最小堆的顶部节点的过程与此类似，唯一的不同是要确保节点的值要小于它的左右子节点的值。</p><p>jdk源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] es;<br>    <span class="hljs-keyword">final</span> E result;<br><br>    <span class="hljs-keyword">if</span> ((result = (E) ((es = queue)[<span class="hljs-number">0</span>])) != <span class="hljs-literal">null</span>) &#123;<br>        modCount++;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) es[(n = --size)];<br>        es[n] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; cmp;<br>            <span class="hljs-keyword">if</span> ((cmp = comparator) == <span class="hljs-literal">null</span>)<br>                siftDownComparable(<span class="hljs-number">0</span>, x, es, n);<br>            <span class="hljs-keyword">else</span><br>                siftDownUsingComparator(<span class="hljs-number">0</span>, x, es, n, cmp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>下沉函数<code>siftDownComparable</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDownComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] es, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 将元素 x 强制转换为可比较类型 Comparable，以便后续调用 compareTo 方法</span><br>    <span class="hljs-comment">// key 代表原来的栈底元素</span><br>    <span class="hljs-comment">// k 代表当前要“下沉”的位置（通常是堆顶，即 0）</span><br>    Comparable&lt;? <span class="hljs-built_in">super</span> T&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;)x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n &gt;&gt;&gt; <span class="hljs-number">1</span>;           <span class="hljs-comment">// 对非叶子节点进行循环</span><br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 先取左节点的索引</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> es[child];     <span class="hljs-comment">// 拿到左节点的值 c</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 拿到右节点的索引</span><br>        <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp;<br>            ((Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="hljs-number">0</span>)<br>            c = es[child = right];<br>        <span class="hljs-keyword">if</span> (key.compareTo((T) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        es[k] = c;<br>        k = child;<br>    &#125;<br>    es[k] = key;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个规律：堆中索引小于<code>size / 2</code>的元素都是非叶子节点。所以后面的循环条件是<code>k&lt;half</code>，只有非叶子节点才有子节点，才可能向下比较。</p><p>这个非常长的比较语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (right &lt; n &amp;&amp;<br>    ((Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="hljs-number">0</span>)<br>    c = es[child = right];<br></code></pre></td></tr></table></figure><p>的含义是：如果右节点存在（right &lt;n），而且左节点的值比右节点大，那么就使用右节点。也就是说，每次都将父节点与较小的那一个子节点进行互换。</p><p>手写的出堆的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 堆顶元素出堆</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Heap is empty&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> minHeap[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> minHeap[--size];<br>    <span class="hljs-comment">// 删除栈底元素</span><br>    minHeap[size] = <span class="hljs-literal">null</span>;<br>    siftDown(<span class="hljs-number">0</span>, last, minHeap, size);<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> currentIndex, <span class="hljs-type">int</span> currentVal, Integer[] es, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> size / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(currentIndex &lt; half) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> currentIndex * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 先拿左节点的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">childVal</span> <span class="hljs-operator">=</span> es[childIndex];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> childIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(rightIndex &lt; size &amp;&amp; es[rightIndex] &lt; childVal) &#123;<br>            childVal = es[rightIndex];<br>            childIndex = rightIndex;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(currentVal &lt;= childVal) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        es[currentIndex] = childVal;<br>        currentIndex = childIndex;<br>    &#125;<br>    es[currentIndex] = currentVal;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://jokinkuang.github.io/2017/01/30/complete-binary-tree.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.hello-algo.com/chapter_heap/heap/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>源码剖析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-使用PageHelper实现条件分页</title>
    <link href="/2025/06/08/%E6%9D%A1%E4%BB%B6%E5%88%86%E9%A1%B5/"/>
    <url>/2025/06/08/%E6%9D%A1%E4%BB%B6%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><h3 id="基本信息">基本信息</h3><p>请求路径：/article</p><p>请求方式：GET</p><p>接口描述：该接口用于根据条件查询文章,<strong>带分页</strong>。</p><p>请求参数说明：</p><table><thead><tr><th>参数名称</th><th>说明</th><th>类型</th><th>是否必须</th><th>备注</th></tr></thead><tbody><tr><td>pageNum</td><td>当前页码</td><td>number</td><td>是</td><td></td></tr><tr><td>pageSize</td><td>每页条数</td><td>number</td><td>是</td><td></td></tr><tr><td>categoryId</td><td>文章分类ID</td><td>number</td><td>否</td><td></td></tr><tr><td>state</td><td>发布状态</td><td>string</td><td>否</td><td>已发布 | 草稿</td></tr></tbody></table><p>请求数据示例：<code>pageNum=1&amp;pageSize=3&amp;categoryId=2&amp;state=草稿</code></p><p>响应数据示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;操作成功&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;total&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;陕西旅游攻略&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;兵马俑,华清池,法门寺,华山...爱去哪去哪...&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;coverImg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://big-event-gwd.oss-cn-beijing.aliyuncs.com/9bf1cf5b-1420-4c1b-91ad-e0f4631cbed4.png&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;草稿&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;categoryId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;createTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2023-09-03 11:55:30&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;updateTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2023-09-03 11:55:30&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="mybatis-pagehelper-分页思路">MyBatis + PageHelper 分页思路</h2><p>分页查询的目的：<strong>避免一次性加载大量数据，节省内存和网络资源，提高性能</strong>。</p><p>例如，前端传来两个参数：<code>pageNum=3, pageSize=5</code>，意思是查询第三页，指定每一页5条数据，也就是查询数据库中第11到第15条记录。</p><p>可以使用<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现这一功能，表示从第<code>M</code>条记录开始，取<code>N-M</code>条记录，结果就是从结果集中“截取”出第<code>M~N</code>条记录。有如下规则：</p><ul><li>LIMIT 总是设定为<code>pageSize</code>；</li><li>OFFSET 计算公式为<code>pageSize * (pageIndex - 1)</code>。</li></ul><p>如果每次都是自己手算的话，未免有点麻烦，于是就有了<code>PageHelper</code>，它可以自动在SQL语句后面附加这一子句。</p><h3 id="引入依赖">引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="控制层">控制层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> Result&lt;PageBean&lt;Article&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(</span><br><span class="hljs-params">        Integer pageNum,</span><br><span class="hljs-params">        Integer pageSize,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(required = false)</span> Integer categoryId,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(required = false)</span> String state</span><br><span class="hljs-params">)</span>&#123;<br>    PageBean&lt;Article&gt; pb = articleService.list(pageNum, pageSize, categoryId, state);<br>    <span class="hljs-keyword">return</span> Result.success(pb);<br>&#125;<br></code></pre></td></tr></table></figure><p>接收前端传来的参数：<code>pageNum</code> <code>pageSize</code>和两个可选条件：<code>categoryId</code><code>state</code>，这里调用服务层的<code>list</code>方法获取结果集。</p><p>返回：自定义类<code>PageBean</code>，具体定义如下。它用来保存查询到的这一页的总记录数、所有查询到的结果构成的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span> &lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> Long total;<span class="hljs-comment">//总条数</span><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; items;<span class="hljs-comment">//当前页数据集合</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务层">服务层</h3><p>在服务层设置分页，总共分为5步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PageBean&lt;Article&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Integer pageNum, Integer pageSize, Integer categoryId, String state)</span> &#123;<br>    <span class="hljs-comment">// 1. 开启分页插件拦截</span><br>    PageHelper.startPage(pageNum, pageSize);<br><br>    <span class="hljs-comment">// 2. 获取当前登录用户 id（一般用于权限控制）</span><br>    Map&lt;String, Object&gt; map = ThreadLocalUtil.get();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Integer) map.get(<span class="hljs-string">&quot;id&quot;</span>);<br><br>    <span class="hljs-comment">// 3. 执行数据库查询（SELECT * FROM ... LIMIT ...）</span><br>    List&lt;Article&gt; list = articleMapper.list(userId, categoryId, state);<br><br>    <span class="hljs-comment">// 4. 用 PageInfo 封装分页信息</span><br>    PageInfo&lt;Article&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(list);<br><br>    <span class="hljs-comment">// 5. 封装成自己的 PageBean，返回前端</span><br>    PageBean&lt;Article&gt; pb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>&lt;&gt;();<br>    pb.setTotal(pageInfo.getTotal());     <span class="hljs-comment">// 总记录数</span><br>    pb.setItems(pageInfo.getList());      <span class="hljs-comment">// 当前页数据列表</span><br>    <span class="hljs-keyword">return</span> pb;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>PageHelper.startPage(pageNum, pageSize);</code><strong>会动态拦截接下来的SQL查询</strong>，并自动在SQL后面添加<code>LIMIT</code>和<code>OFFSET</code>。</p></li><li><p><code>ThreadLocalUtil.get()</code>获取当前用户的登录信息</p></li><li><p><code>PageInfo&lt;Article&gt; pageInfo = new PageInfo&lt;&gt;(list);</code>将查询数据库返回的记录封装成<code>PageInfo</code>，然后可以调用以下方法：</p><ul><li><code>getTotal()</code>：总记录数</li><li><code>getList()</code>：当前页数据</li><li><code>getPageNum()</code>：当前页码</li><li><code>getPageSize()</code>：每页记录数</li><li><code>getPages()</code>：总页数</li><li><code>isHasNextPage()</code>、<code>isHasPreviousPage()</code>等</li></ul></li></ul><p>这里用到了两个方法：</p><ul><li><code>getTotal()</code>，对应<code>PageBean</code>中的<code>total</code>字段，用setter 为pb赋值；</li><li><code>getList()</code>，对应<code>getList</code>中的<code>items</code>字段，用setter 为pb赋值。</li></ul><h3 id="mapper">Mapper</h3><p>服务层调用了<code>articleMapper.list(userId, categoryId, state);</code>用于从<code>article</code>表中读取满足以下条件的所有记录：</p><ol type="1"><li><code>userId</code>为登录用户的id</li><li><code>categoryId</code>为前端发来的指定分类id</li><li><code>state</code>为前端发来的指定文章状态</li></ol><p>第一条需要从<code>ThreadLocal</code>中读取，这一步在服务层已经做过了，所以接下来只需要写SQL语句。</p><p>首先应该注意到，categoryId 和 state都是可选的条件，可以为空，这是非常合理的，因为用户在前端可能只想按照分类查找，或者只想查某个状态（比如“草稿”或“已发布”），不应该强制他提供所有条件。</p><p>当可选条件存在时就加入SQL子句，不存在时就忽略，需要动态SQL才能做到这一点。先编写接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArticleMapper</span> &#123;<br>    List&lt;Article&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Integer userId, Integer categoryId, String state)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 resources目录下的<code>com/kzn/mapper/ArticleMapper.xml</code>里写动态SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kzn.mapper.ArticleMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kzn.pojo.Article&quot;</span>&gt;</span><br>        select * from article<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>                create_user=#&#123;userId&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId!=null&quot;</span>&gt;</span><br>                and category_id = #&#123;categoryId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state!=null&quot;</span>&gt;</span><br>                and state = #&#123;state&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在不传<code>categoryId</code>和<code>state</code>时只会拼接<code>user_id</code>，避免了冗余查询。</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal使用场景+源码简析</title>
    <link href="/2025/06/07/ThreadLocal%E5%89%96%E6%9E%90/"/>
    <url>/2025/06/07/ThreadLocal%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="作用">作用</h2><ol type="1"><li>线程并发：多线程并发的场景</li><li>传递数据：可以在同一个线程的不同组件中传递公共变量</li><li>线程隔离：每个线程的变量都是独立的不会互相影响</li></ol><h2 id="用法">用法</h2><p>用来存储数据，而且线程安全。为每个线程单独创建一个存储空间。</p><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>设置当前线程绑定的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    set(Thread.currentThread(), value);<br>    <span class="hljs-keyword">if</span> (TRACE_VTHREAD_LOCALS) &#123;<br>        dumpStackIfVirtualThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前线程绑定的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> get(Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>移除当前线程绑定的局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="业务场景">业务场景</h2><p>在一个应用中，某些页面仅当用户登录以后才能访问，可以在每当用户登录成功时就为用户发放一个JWT令牌，随后的每次请求都在请求头里带上这个token，如果token校验通过，则说明用户的确已经登录，允许继续访问。</p><p>采用这种思路，查询用户的文章列表的处理方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(name = &quot;Authorization&quot;)</span> String token, HttpServletResponse resp)</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token); <span class="hljs-comment">// 解析token</span><br>            <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;所有的文章数据&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            resp.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;未登录&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;所有的文章数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在形参里主动接收请求头携带的token，然后手动解析。如果解析出错，则抛出异常，返回结果“未登录”。</p><p>上面的思路有一个问题：登录成功以后，每个和用户有关的功能都需要验证token，如果在每个页面的处理方法都写一遍解析token的方法未免太过冗余。为此，可以考虑使用<code>ThreadLocal</code>存储tokean解析后的结果，而token解析的工作放在拦截器的<code>preHandle</code>里进行，并在<code>afterCompletion</code>清除局部变量。</p><p>为此，先写一个 ThreadLocalUtil工具类，封装了存储局部变量、获取局部变量、清除的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalUtil</span> &#123;<br>    <span class="hljs-comment">//提供ThreadLocal对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">THREAD_LOCAL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">//根据键获取值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> (T) THREAD_LOCAL.get();<br>    &#125;<br><br>    <span class="hljs-comment">//存储与线程绑定的局部变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(Object value)</span>&#123;<br>        THREAD_LOCAL.set(value);<br>    &#125;<br><br>    <span class="hljs-comment">//清除ThreadLocal 防止内存泄漏</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>        THREAD_LOCAL.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再配置拦截器，在拦截器里解析token。此处token的解析结果是一个哈希表，包括</p><ul><li><code>"id=用户id"</code></li><li><code>"username=用户名"</code></li></ul><p>然后把解析得到的表作为<code>ThreadLocalMap</code>的value存储起来，后面执行方法的时候直接读取就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-comment">// 在执行方法之前进行拦截</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);<br>            <span class="hljs-comment">// 把业务数据存储到 ThreadLocal 中</span><br>            ThreadLocalUtil.set(claims);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放行</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不放行</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Spring DispatcherServlet 在完成一次 HTTP 请求的整个处理流程后，</span><br>    <span class="hljs-comment">// 自动调用 afterCompletion() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 这里清除 ThreadLocal 中已经使用过的数据，防止内存泄漏</span><br>        ThreadLocalUtil.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的查询文章的处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 能够执行到这里的话一定是通过验证了</span><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;所有的文章数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，查询用户基本信息的话可以先从<code>ThreadLocalUtil</code>获取用户名或id，然后调用业务层的方法查询信息并返回:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取用户的详细信息</span><br><span class="hljs-meta">@GetMapping(&quot;/userInfo&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(name = &quot;Authorization&quot;)</span> String token)</span> &#123;<br>    <span class="hljs-comment">// 先从 token 中读取用户的用户名</span><br>    Map&lt;String, Object&gt; stringObjectMap = ThreadLocalUtil.get();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) stringObjectMap.get(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-comment">// 调用业务层的方法，查询这个用户名的具体信息</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> userService.findByUserName(username);<br>    <span class="hljs-keyword">return</span> Result.success(u);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="与同步代码块的区别">与同步代码块的区别</h2><p><strong>作用机制</strong></p><ul><li><code>ThreadLocal</code>为多个线程提供<strong>独立的变量副本</strong>，每个线程互不干扰</li><li><code>synchronized</code>多个线程<strong>共享</strong>资源，通过锁实现同步访问</li><li><code>ThreadLocal</code>实现线程隔离，各个线程保存自己的变量（常用于用户上下文）</li><li><code>synchronized</code>实现线程互斥，防止多个线程同时修改资源，造成数据不一致</li></ul><p><strong>线程安全方式</strong></p><ul><li><code>ThreadLocal</code>各个线程拥有自己的变量副本，不需要加锁就可以访问</li><li><code>synchronized</code>通过加互斥锁防止多个线程同时访问共享变量</li></ul><p><strong>性能</strong></p><ul><li><code>ThreadLocal</code>性能更好，避免了锁竞争；<code>synchronized</code>性能较差</li></ul><h2 id="threadlocal底层实现">ThreadLocal底层实现</h2><p>核心思想：</p><p>每个线程维护一个<code>ThreadLocalMap</code>，用来存储自己的局部变量副本。</p><p>这个<code>Map</code>的<code>key</code>是<code>ThreadLocal</code>对象本身，<code>value</code>是为它设置的值。</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="set方法">set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 不为空，则将ThreadLocal作为键，value作为值</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为空则创建</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取指定线程 t 维护的 ThreadLocalMap 的方法</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-comment">// 为线程创建ThreadLocalMap</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>threadLocals</code>在<code>Thread.java</code>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与此线程相关的 threadLocal 值。此映射由 ThreadLocal 类维护</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h3 id="get方法">get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回当前线程绑定的局部变量的副本。</span><br><span class="hljs-comment">// 如果该变量在当前线程中没有值，则首先将其初始化为调用 initialValue 方法返回的值。</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">// 已经创建过 map 继续看里面是否存放的有映射</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 存放的有映射，则把映射中的值取出来返回</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 没有创建过map，或者没有entry，则延迟初始化当前线程绑定的局部变量的值</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue(); <span class="hljs-comment">// 即 value = null</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value); <span class="hljs-comment">// 有map，就把null存进去，否则新建map</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>先获取当前线程的ThreadLocalMap，再根据调用者ThreadLocal（键）找到存储的值</p><h3 id="remove方法">remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 移除这个entry</span><br>            m.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>为什么要手动移除？因为 ThreadLocalMap 的键是<strong>弱引用</strong>的ThreadLocal 实例，值是实际的值（Object value）。</p><p><code>ThreadLocalMap.Entry</code>的键是用弱引用包装的，<strong>但是它的值是强引用</strong>。如果键不再被任何地方引用，但是值引用的对象还在被强引用，占着内存，必须手动清除。</p><h2 id="threadlocalmap">ThreadLocalMap</h2><p>为什么不用 HashMap 而用 ThreadLocalMap？</p><p>ThreadLocalMap 是 ThreadLocal 的私有静态内部类，它是专门为ThreadLocal 定制的：</p><ul><li>它的 key 是 ThreadLocal 弱引用</li><li>如果 ThreadLocal 没有外部引用，key 会被 GC 掉；但如果不清理value，会造成内存泄漏。</li></ul><hr /><p>ThreadLocalMap是ThreadLocal的<strong>内部静态实现类</strong>，没有实现Map 接口，独立实现了 Map 的功能。</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="entry">Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Entry</code>继承了<code>WeakReference</code>，是<code>ThreadLocalMap</code>的底层。</p><p><code>ThreadLocal</code>被弱引用，这种引用不会影响 GC过程。构造器<code>Entry(ThreadLocal&lt;?&gt; k, Object v)</code>内部的<code>super(k);</code>调用了父类的构造器。这里的泛型<code>T</code>对应<code>ThreadLocal&lt;?&gt;</code>，父类构造器定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new weak reference that refers to the given object.  The new</span><br><span class="hljs-comment"> * reference is not registered with any queue.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> referent object the new weak reference will refer to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent)</span> &#123;<br>    <span class="hljs-built_in">super</span>(referent);<br>&#125;<br></code></pre></td></tr></table></figure><p>于是就创建了一个指向<code>ThreadLocal</code>的弱引用<code>k</code>。另一个参数<code>v</code>使用的是强引用：<code>value = v</code>。</p><h3 id="成员变量">成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始容量——必须是 2 的次幂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * M用于存储元素的Entry数组，容量必须是2的次幂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 现存的entry的个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扩容阈值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br></code></pre></td></tr></table></figure><h3 id="基本方法">基本方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扩容阈值取为当前数组长度的2/3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回当前索引 i 的下一个索引，如果到头了就绕回数组起始处（0）。</span><br><span class="hljs-comment"> * 这是用于线性探测的一个辅助方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟上面的反过来，找到前一个索引，到头了就绕回尾部。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 从上面两个取索引的方法可以看出，这里的数组相当于一个环形数组</span><br></code></pre></td></tr></table></figure><p>负载因子之所以取2/3，是因为 ThreadLocalMap内部使用的是<strong>开放地址法</strong>（线性探测），这种策略对负载因子比较敏感，在高负载下的插入和查找都会变慢，所以需要提前扩容。</p><div class="note note-info">            <p>什么是开放地址法？</p><p>开放地址法也是一种哈希冲突的解决策略：当我们向哈希表中插入一个键时，如果它映射到的位置已经被占用了，就在表中继续寻找下一个空位置。</p><p>例如，如果 key1 和 key2都映射到了索引3，那么key2插入的时候会继续向后寻找索引 4 ，索引 4也不为空的话就找索引 5，直到找到一个空位置。这个继续寻找的过程就称之为<strong>探测</strong>。探测的方法有很多种，ThreadLocalMap使用的是线性探测法，也就是刚才描述的每次索引加一的思路。</p><p>开放地址法的好处是节省内存，仅用一个数组存储所有的元素，无需额外的数据结构，但缺点也很明显：数组中存储的个数越接近数组长度，空位越少，哈希冲突的概率会迅速上升，每次插入/查找的效率迅速下降。所以说它对负载因子是很敏感的，一般不能超过0.7。</p>          </div><p>总结：开放地址法是指哈希冲突时，通过在数组中继续找下一个空位来解决冲突的方法。它不使用链表，所有数据都存在数组中，因此对负载因子非常敏感，一旦太满，性能会迅速下降。为了尽可能减小哈希冲突的概率，对哈希值的选取采用了特殊的处理办法。</p><p>相比之下，哈希表采用<strong>链地址法</strong>，发生哈希冲突时将冲突的元素存储到链表或红黑树中，对负载更耐受，对负载因子不那么敏感，所以取0.75。</p><h3 id="弱引用和内存泄漏">弱引用和内存泄漏</h3><p>再详细地介绍一下这两个概念：</p><p>内存泄漏：程序中已经分配的动态堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行减慢甚至系统崩溃等严重后果。内存的堆积最终将导致内存溢出。</p><p>然后回顾一下JVM对象引用的四种类型：</p><ul><li>强引用：比如<code>Object obj = new Object()</code>，只要强引用还存在，该对象就永远也不会被回收</li><li>软引用：描述一些有用，但是并非必须的对象。被软引用的对象，在系统的内存快要溢出的时候会被回收，如果回收之后内存还是不够才会抛异常</li><li>弱引用：只要垃圾收集器开始工作，只具有弱引用的对象就会被回收。</li><li>虚引用：虚引用完全不会对一个对象是否被回收造成影响，它是为了让系统知道这个对象被回收了</li></ul><p>垃圾回收器一旦发现了只具有弱引用的对象，就会回收它的内存。</p><hr /><p>ThreadLocal 相关变量的引用关系如下：</p><p>Thread ───▶ ThreadLocalMap ───▶ Entry[] ───▶(WeakReference<ThreadLocal>, value)</p><p>所有对象的实例都保存在 Java堆中，引用类型的字段由于是对象的一部分，所以也在堆里。</p><p><code>Thread</code>类持有一个 <code>ThreadLocalMap</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap的实例也位于堆中，它被当前线程（CurrentThread）引用。</p><p>下面这张图展示了 ThreadLocal 持有的局部变量有效时的情况：</p><p><img src="https://s21.ax1x.com/2025/06/07/pViDMnI.png" /></p><ul><li>当<code>ThreadLocalRef</code>不再被使用的时候，<code>ThreadLocal</code>只具备一个来自<code>k</code>的弱引用，所以马上会被GC回收，于是<code>k</code>变为空。</li><li>但是<code>value</code>是由强引用<code>value = v;</code>创建的，<code>ThreadLocalMap</code>中的<code>Entry</code>数组持有对<code>value</code>的强引用，因此无法被GC，必须手动清除。</li></ul><p><strong>ThreadLocal内存泄漏的根源</strong>：ThreadLocalMap 是 Thread的字段，生命周期和 Thread 相同，当 ThreadLocal使用完毕之后，线程并没有结束。比如，在线程池中，线程结束之后是不会被销毁的，这种情况下如果不手动清除entry，会造成严重的内存泄漏问题。</p><p>使用弱引用还有一个好处：</p><p>如果在执行<code>ThreadLocalMap</code>的 set 或者 get方法的时候找不到<code>key</code>，就会分别执行<code>expungeStaleEntry((int staleSlot))</code>方法和<code>replaceStaleEntry</code>方法，前者的作用是清除过期的entry， 后者的作用是把过期的 entry 更新为新的 entry，而判断 entry是否过期就是看它是否满足<code>key == null &amp;&amp; value != null</code>。<strong>所以使用弱引用的方式实际上为我们添加了一层保障，就算是忘记了手动清除过期的entry， 调用 get 或 set 方法也会自动帮我们把它们清理掉</strong>。</p><h3 id="减轻哈希冲突">减轻哈希冲突</h3><p>ThreadLocalMap 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY]; <span class="hljs-comment">// 初始容量16</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算索引</span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue); <span class="hljs-comment">// 先创建一个entry</span><br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY); <span class="hljs-comment">// 设置阈值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>threadLocalHashCode</code>是<code>ThreadLocal</code>的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br></code></pre></td></tr></table></figure><p>nextHashCode：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br></code></pre></td></tr></table></figure><p><code>AtomicInteger</code>是一个提供原子操作的 Integer类，通过线程安全的方式加减。<code>nextHashCode()</code>是通过把原来的值不断加上<code>HASH_INCREMENT</code>得来的。<code>HASH_INCREMENT</code>与黄金分割数有关，目的是让哈希码均匀地分布在2的n次方的数组里。</p><blockquote><p><code>HASH_INCREMENT = 黄金分割 * 2^32</code>是目前被认为最接近完美均匀散列的方式。</p></blockquote><p>所有的 ThreadLocal 实例的哈希值就是一个等差数列：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">0<br>0 + HASH_INCREMENT<br>0 + 2*HASH_INCREMENT<br>0 + 3*HASH_INCREMENT<br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li>ThreadLocal让每个线程都有自己的变量副本，互不干扰，适合线程复用环境下保存线程私有数据，比如在一次请求中保存用户信息，避免层层方法传参；</li><li>每个线程维护一个<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>是ThreadLocal的内部静态类，将<code>ThreadLocal</code>对象作为key，将需要与线程绑定的局部变量作为value，其中<code>key</code>为弱引用，<code>value</code>为强引用，因为存在强引用所以需要手动清除内存，避免内存泄漏</li><li><code>ThreadLocalMap</code>独立实现了 Map的功能，底层是<code>Entry</code>数组，容量是 2 的次幂，但是负载因子取2/3，减轻哈希冲突的方法是开放地址法中的线性探测法，相比之下 HashMap采用链地址法</li><li><code>ThreadLocalMap</code>的哈希值等距分布，间隔为<code>HASH_INCREMENT = 黄金分割*2^32</code>，目的是让哈希值尽可能均匀分布，减小哈希冲突的概率</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>源码剖析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-3.2-垃圾回收算法</title>
    <link href="/2025/06/02/JVM-3-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/06/02/JVM-3-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》读书笔记(3)</p><span id="more"></span><h2 id="对象存活判定算法">对象存活判定算法</h2><h3 id="什么区域需要垃圾回收">什么区域需要垃圾回收？</h3><p>虚拟机栈、本地方法栈、程序计数器属于线程私有，随线程而生，随线程而灭，而且它们占据的内存大小在编译的时候就已经确定下来了，线程结束的时候自然会被回收，不用担心垃圾回收的问题。</p><p>方法区、堆由线程共享，其中方法区存储类的信息和运行时常量池，堆内存存放对象的实例。方法区存储的信息相对固定，垃圾收集行为比较少见，堆内存是垃圾回收的重灾区。</p><h3 id="引用计数算法">引用计数算法?</h3><p>引用计数算法的含义如下：</p><div class="note note-info">            <p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>          </div><p>引用计数法有个很明显的缺陷：<strong>如果两个对象互相引用，那么他们的引用计数都不为零，虽然属于垃圾但是永远不会被回收</strong>。主流Java虚拟机没有采用这种算法。</p><h3 id="可达性分析算法">可达性分析算法</h3><p>首先，可达性分析和可达鸭没有任何关系（雾）</p><p>简单来说，从被称为GCRoots的根对象出发，根据对象的引用关系查找其他节点，如果没有一条路径能够到达某个对象，那么这个对象就被视为垃圾。</p><figure><img src="https://s21.ax1x.com/2025/06/02/pV9L4Xt.png"alt="可达性分析算法图解" /><figcaption aria-hidden="true">可达性分析算法图解</figcaption></figure><p>固定可以作为 GC Roots 的对象有：</p><ul><li>虚拟机栈栈帧中的局部变量表引用的对象</li><li>方法区中类的静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中的Native方法引用的对象</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><p>除了这些固定的对象意以外，还可以有其他的对象临时加入。</p><h3 id="引用的四种类型">引用的四种类型</h3><ul><li>强引用：比如<code>Object obj=new Object()</code>，只要强引用还存在，该对象就永远也不会被回收</li><li>软引用：描述一些有用，但是并非必须的对象。被软引用的对象，在系统的内存快要溢出的时候会被回收，如果回收之后内存还是不够才会抛异常</li><li>弱引用：只要垃圾收集器开始工作，弱引用的对象就会被回收。</li><li>虚引用：虚引用完全不会对一个对象是否被回收造成影响，它是为了让系统知道这个对象被回收了</li></ul><h3 id="方法区的回收">方法区的回收</h3><p>方法区主要回收两部分内容：</p><ul><li>不再使用的常量</li><li>不再使用的类型</li></ul><p>回收废弃常量：很简单，如果当前系统中没有任何一个对象引用该常量池中的常量，那么这个常量已经废弃了，需要被回收。</p><p>不再使用的类型的判断条件比较苛刻：</p><ol type="1"><li>该类的所有实例都已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对象的 Class对象没有被任何地方引用，并且无法在任何地方通过反射访问该方法。</li></ol><p>满足以上条件的类<strong>允许</strong>被回收，但是不一定真的会被回收。</p><h2 id="垃圾收集算法-追踪式垃圾收集">垃圾收集算法-追踪式垃圾收集</h2><p>追踪式垃圾收集是主流Java虚拟机采用的算法，以下所有算法均属于跟踪式垃圾收集的范畴。</p><h3 id="分代收集理论">分代收集理论</h3><p><code>Generational Collection</code></p><p>分代收集理论的假说基础：</p><ol type="1"><li><strong>弱分代假说</strong>（Weak GenerationalHypothesis）：绝大多数的对象都是朝生夕灭的</li><li><strong>强分代假说</strong>（Strong GenerationalHypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li></ol><p>根据 1 和 2可以推论：存在引用关系的对象大多数都属于同一代的对象，比如如果一个老年代的对象引用了一个新生代的对象，那么这个新生代对象就不太可能被回收，迟早会变成老年代。由此可以得到第三条假说：</p><ol start="3" type="1"><li><strong>跨代引用假说</strong>（Intergenerational ReferenceHypothesis）：跨代引用相对于同代引用来说仅占极少数</li></ol><p>对象的年龄：对象熬过垃圾回收过程的次数。</p><p><strong>垃圾收集器的设计原则：收集器应该把java堆划分出不同的区域，将对象根据年龄存放在不同的区域</strong>。这样的好处是：把难以熬过垃圾收集的对象集中在一起，对它们进行回收的时候只需要关注少量没有被回收的对象，并且提高回收的频率；把难以消亡的对象集中在一起，回收他们的时候只需要关注少量被回收的对象，并且降低回收的频率。</p><p>因为对不同的区域采取针对性的回收策略，所以提高了垃圾收集的效率，尽可能把内存空间用到有意义的对象身上，提高了堆内存空间的利用率。</p><div class="note note-secondary">            <p>垃圾收集相关名词：</p><ul><li>部分收集（Partial GC）：指收集整个Java堆的一部分的垃圾收集，包括：<ul><li>新生代收集（Minor GC/Young GC）：只针对新生代的收集</li><li>老年代收集（Major GC/OldGC）：只针对老年代的收集（只有CMS收集器存在）</li><li>混合收集（MixedGC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li></ul>          </div><h3 id="标记清除算法">标记清除算法</h3><blockquote><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p></blockquote><p>标记清除算法是最基础的算法，后续的很多算法以它为基础。它有两个缺点：</p><ol type="1"><li>效率不稳定，需要标记的对象数量越多效率越低</li><li>内存空间的碎片化，标记清除之后会产大量的不连续的内存空间，后续如果需要为大对象分配空间，需要再临时调用一次垃圾收集操作腾出空间。</li></ol><h3 id="标记复制算法">标记复制算法</h3><p>为了解决内存空间的碎片化问题，Fenichel 提出了标记复制算法：</p><blockquote><p>复制算法将内存分为两个区间,这两个区间是动态的，在任意一个时间点，所有分配的对象内存只能在其中一个区间（活动区间），另外一个区间就是空闲区间。</p><p>当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址一次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。这个时候空闲内存已经变成了活动区间，垃圾对象全部在原来的活动区间，清理掉垃圾对象，原活动区间就变成了空闲区间。</p></blockquote><figure><img src="https://s21.ax1x.com/2025/06/02/pV9XVPg.png"alt="标记复制算法" /><figcaption aria-hidden="true">标记复制算法</figcaption></figure><p>这种算法有两个明显缺点：</p><ol type="1"><li>空间利用率过低，可用内存缩小为原来的一半</li><li>执行效率取决于存活对象数量，存活数量越多，需要复制的对象就越多，执行效率越慢</li></ol><p>第 2点决定了这种算法<strong>只适用于新生代对象</strong>；对于第一点，AndrewAppel 提出了优化后的算法，即Appel回收：</p><blockquote><p>将新生代的空间分为一块较大的 Eden 空间和两块较小的 Survivor空间，每次分配内存时，只使用 Eden 和其中一块 Survivor ，另一块 Survivor为空闲。每次发生垃圾收集时，把 Eden 和 Survivor中仍然存活的对象一次性复制到空闲 Survivor 中，然后清理Eden 和Survivor。</p></blockquote><p>HotSpot 默认 Eden 和 一块 Survivor 的比例是8:1，所以每次可用的内存空间为整个新生代内存空间的90%。</p><p>在大部分的情况下，存活对象不会超过内存的10%，如果真的超过了，多出来的对象会依赖老年代的内存区域进行<strong>分配担保</strong>（HandlePromotion）。</p><p>HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了 Appel回收策略来设计新生代的内存布局。</p><h3 id="标记整理算法">标记整理算法</h3><p>老年代对象在每次垃圾收集时的存活数量要大于消亡数，Edward Lueders针对这种存亡特征设计了标记-整理（Mark-Compact）算法。</p><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><figure><img src="https://s21.ax1x.com/2025/06/02/pV9j4XR.png"alt="回收前的状态" /><figcaption aria-hidden="true">回收前的状态</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/06/02/pV9jIn1.png"alt="回收后的状态" /><figcaption aria-hidden="true">回收后的状态</figcaption></figure><p>标记整理算法相比于标记清除算法多了一个移动内存的过程。这个过程优缺点并存：</p><ul><li>缺点：老年代对象区域每次垃圾收集后会有大量的对象存活，移动这些对象在内存中的位置并更新其他地方对这些对象的引用非常耗时，需要将用户程序停顿较长的时间专门执行操作。</li><li>优点：解决了空间的碎片化问题，内存分配和访问的负担都会被减轻，而内存的访问就是用户执行最频繁的操作</li></ul><p>“程序吞吐量” = 用户程序执行效率 + 垃圾收集器效率 的总和——</p><p><strong>虽然移动对象的垃圾回收成本较高，但由于它能显著提升对象分配和访问效率，所以整体来看，对程序吞吐量更有利；而不移动对象虽然减少了GC停顿，延迟更低，但降低了内存分配效率，不适合高吞吐量需求场景</strong>。不同的垃圾回收器选择了不同的策略来适应不同的需求。</p><p>正因如此，HotSpot虚拟机里面关注吞吐量的 Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的 CMS收集器则是基于标记-清除算法的。</p><h2 id="参考链接">参考链接</h2><p>https://www.cnblogs.com/gengaixue/p/13602322.html</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-Java虚拟机中的对象</title>
    <link href="/2025/06/01/JVM-2-3-%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98/"/>
    <url>/2025/06/01/JVM-2-3-%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》读书笔记(2)</p><span id="more"></span><h1 id="hotspot对象">HotSpot对象</h1><h2 id="创建新对象">创建新对象</h2><blockquote><p>当Java虚拟机遇到一条字节码 new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，</p></blockquote><p>类加载完毕后，虚拟机会为该新对象分配内存。因为每个对象所需要的内存大小在类加载完成后就就可以确定，所以现在的问题是怎么从Java堆这一大块内存中划分一块确定大小的内存。</p><p><strong>两种划分堆内存的方式</strong>：</p><ol type="1"><li><strong>指针碰撞</strong>（Bump ThePointer）：适用于堆内存非常规整、已使用内存和空闲内存界限分明的情况，这样只需要把用作分界点的指针向空闲内存的方向挪动一小段距离就行了。</li><li><strong>空闲列表</strong>（FreeList），适用于堆内存不规整，空闲内存和已用内存混杂不清的情况，这时虚拟机需要维护一个列表，列表中记录了空闲内存的位置，因此被称作空闲列表。每次更新内存都要同步更新空闲列表中的内容。</li></ol><p>堆内存的规整与否由垃圾收集器是否带有<strong>空间压缩整理</strong>（Compact）功能决定。</p><hr /><p>划分空间使用的是一个指针，在高并发的情况下，会出现线程安全的问题：正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。两种解决方案：</p><ul><li>对分配内存空间的动作进行同步处理，但是实际上虚拟机采用的是<strong>CAS+失败重试</strong>保证操作的原子性</li><li><strong>本地线程分配缓冲</strong>（Thread Local AllocationBuffer，TLAB），每个线程在Java堆中提前分配了一块缓冲区，本地缓冲区用完了，分配新的缓冲区的时候才会考虑同步锁定</li></ul><div class="note note-secondary">            <p>CAS(Compare AndSet)+失败重试是一种<strong>乐观锁</strong>策略，它假设并发不会太激烈，如果失败就不断重试，直到原子更新成功。</p>          </div><p>内存分配完成后，虚拟机会把分配好的内存空间初始化为零值（所以Java中的字段不赋初值就可以使用），最后设置对象头。这样一个新的对象就创建好了，可以继续执行构造方法。</p><h2 id="对象的内存布局">对象的内存布局</h2><p>Java对象保存在堆中时，由以下三部分组成：</p><figure><img src="https://s21.ax1x.com/2025/05/31/pV9uJ1A.png"alt="对象的内存布局" /><figcaption aria-hidden="true">对象的内存布局</figcaption></figure><h3 id="对象头object-header">对象头（Object Header）</h3><ol type="1"><li><strong>MarkWord</strong>，在64位虚拟机中占据64个比特，用于存储对象自身的运行时数据，包括堆对象布局、类型、GC状态、同步状态和身份哈希码的基本信息</li><li><strong>KlassPointer</strong>，类型指针，指向它的类型元数据，用于确定该对象是哪个类的实例。</li><li><strong>对于数组对象，还有一块用于存储数组长度的区域</strong>。因为以后的JVM需要进行边界检查、GC需要知道对象占多大空间等等，数组长度的值是要被多次使用的，所以数组对象自身必须也保存一个长度。</li></ol><p>64位JVM的对象头结构：</p><figure><img src="https://s21.ax1x.com/2025/05/31/pV9Koa8.png" alt="对象头" /><figcaption aria-hidden="true">对象头</figcaption></figure><h3 id="实例数据instance-data">实例数据（Instance Data）</h3><p>实例数据是对象真正存储的有效信息，包括：</p><ul><li>从父类继承的各种类型的字段</li><li>在子类中定义的各种类型的字段</li></ul><p>如果对象没有属性字段，那么这里不会有信息。</p><h3 id="对齐填充padding">对齐填充（Padding）</h3><p>并非必要信息，起到占位符的作用，原因是Java的自动内存管理系统要求对象的起始地址必须是8 字节的整数倍，而对象的实例数据可能不满足，所以需要对齐填充一下。</p><p>至于为什么起始地址会有这个要求:<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/jajian/p/13681781.html">[1]</span></a></sup></p><div class="note note-success">            <p>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</p>          </div><h2 id="对象的访问定位">对象的访问定位</h2><p>Java程序会通过栈上的<code>reference</code>数据来操作堆上的具体对象，主流的虚拟机的对象访问方式主要有两种：</p><ol type="1"><li><strong>句柄</strong></li></ol><figure><img src="https://s21.ax1x.com/2025/05/31/pV9MHw6.png" alt="句柄" /><figcaption aria-hidden="true">句柄</figcaption></figure><p>Java堆中会划分出来一块区域用户存放句柄，句柄中包含了对象的实例和类型数据的地址信息。此时，<code>reference</code>中存放的是对象的句柄地址，访问过程是：<code>reference</code>-&gt;句柄-&gt;对象的实例数据和类型数据</p><ol start="2" type="1"><li><strong>直接指针访问</strong></li></ol><p><code>reference</code>直接存储对象实例数据的地址，对象实例数据中保存了指向类型数据的指针。</p><figure><img src="https://s21.ax1x.com/2025/05/31/pV9MbTK.png" alt="直接访问" /><figcaption aria-hidden="true">直接访问</figcaption></figure><p><code>reference</code>-&gt;对象实例数据-&gt;对象类型数据，这种方式的访问速度更快。这也是HotSpot主要采用的方式。</p><p>最后看看 Oracle是如何描述对象的定位的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.7">[2]</span></a></sup></p><div class="note note-success">            <p>Java 虚拟机并不强制规定对象的内部结构必须是什么样的。</p><p>在 Oracle 的一些 Java虚拟机实现中，对类实例的引用实际上是指向一个“句柄”（handle）的指针。而这个句柄本身是由一对指针组成的：-一个指针指向一个表，该表包含了该对象的方法，以及一个指向表示该对象类型的Class 对象的指针； - 另一个指针指向堆中为该对象数据分配的内存。</p>          </div><p>奇怪的是这里没有提到HotSpot采用的方式。</p><h2 id="参考链接">参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.cnblogs.com/jajian/p/13681781.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.7<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer-题目链接+解析</title>
    <link href="/2025/05/31/%E5%89%91%E6%8C%87offer%E5%8A%9B%E6%89%A3%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86/"/>
    <url>/2025/05/31/%E5%89%91%E6%8C%87offer%E5%8A%9B%E6%89%A3%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><a href="/2025/06/07/剑指offer-链表/">链表</a></p><p><a href="/2025/06/03/剑指offer-哈希表/">哈希表</a></p><p><a href="/2025/05/23/剑指offer-树/">树&amp;堆</a></p><p><a href="/2025/05/31/剑指offer-栈/">栈</a></p><p><a href="/2025/06/01/剑指offer-队列/">队列</a></p><p><a href="/2025/06/14/剑指offer-排序/">排序</a></p><p><a href="/2025/06/19/剑指offer-回溯/">回溯</a></p><p><a href="/2025/07/14/剑指offer-动态规划/">动态规划</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM：运行时数据区域简析</title>
    <link href="/2025/05/31/JVM-2.2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <url>/2025/05/31/JVM-2.2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》读书笔记(1)</p><span id="more"></span><h1 id="jvm运行时数据区域">JVM运行时数据区域</h1><p><code>Run-Time Data Areas</code></p><figure><img src="https://s21.ax1x.com/2025/05/28/pVp3Xe1.png"alt="Java虚拟机运行时数据区" /><figcaption aria-hidden="true">Java虚拟机运行时数据区</figcaption></figure><h2 id="程序计数器">程序计数器</h2><p>官方文档的表述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1">[1]</span></a></sup>：</p><blockquote><p>Java 虚拟机可以同时支持多个执行线程。每个 Java 虚拟机线程都有自己的pc（程序计数器）寄存器。在任何时候，每个 Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。如果该方法不是本地方法，则pc 寄存器包含当前正在执行的 Java虚拟机指令的地址。如果线程当前正在执行的是本地方法，则 Java 虚拟机的 pc寄存器的值未定义。</p></blockquote><ul><li>概念：程序计数器（Program CounterRegister）是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</li><li>作用范围：线程私有<ul><li>在任何一个时刻，一个处理器只会处理多线程中的一个线程的指令。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这块内存区域是线程私有的内存。</li></ul></li><li>程序计数器适用于Java方法，不适用于本地方法。运行Java方法时，它记录虚拟机的字节码指令的地址；对于本地方法，则为空。</li></ul><h2 id="java虚拟机栈">Java虚拟机栈</h2><h3 id="含义">含义</h3><p>Java虚拟机运行时数据区之一。</p><ul><li>作用范围：<strong>线程私有，每个线程在创建时都会创建一个新的虚拟机栈</strong>。虚拟机栈的作用就是用来存储与<em>该线程的方法调用</em> 对应的栈帧。</li><li>生命周期：当线程运行结束，方法调用也就全部完成了，对应的 JVM栈自然就不需要了，可以由 JVM自动释放回收，因此<strong>虚拟机栈和线程的生命周期相同</strong>。</li></ul><h3 id="栈帧">栈帧</h3><p><strong>栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息</strong>。每次方法调用时都会创建一个新的帧（栈帧入虚拟机栈）；当该方法调用完成时，不论是正常完成还是由于抛出未捕获异常而异常终止，对应的帧都会被销毁（栈帧出虚拟机栈）。可以这样说，栈帧是方法运行时的工作内存。</p><p><strong>局部变量数组和操作数栈的容量（槽位数量）是在编译时确定的，并与该方法的字节码一起提供给帧</strong>（这一点通过分析反编译得到的字节码文件就可以看出，后面会分析）。既然槽位数量是确定的，那么<strong>帧的数据结构的大小仅取决于Java虚拟机的实现方式</strong>（譬如按照1个变量槽占用32个比特、64个比特，或者更多），其所需的内存可以在方法调用时一并分配。</p><p>Oracle文档的描述：</p><blockquote><p>Each frame has its own array of local variables (§2.6.1), its ownoperand stack (§2.6.2), and a reference to the run-time constant pool(§2.5.5) of the class of the current method.</p><p>每个帧拥有自己的局部变量数组、操作数栈，以及指向当前方法所在类的运行时常量池的引用。</p></blockquote><p><strong>在一个线程的控制流程中，任何时刻只有一个帧是活动的</strong>，这个帧称为<strong>当前帧</strong>（currentframe），其对应的方法称为<strong>当前方法</strong>（currentmethod），定义该方法的类称为<strong>当前类</strong>（currentclass）。对局部变量和操作数栈的操作通常都是针对当前帧进行的。</p><p>如果当前方法调用了另一个方法或者该方法已经执行完成，当前帧就不再是当前帧。当一个方法被调用时，会创建一个新的帧，并在控制转移到该方法时成为当前帧。方法返回时，当前帧会将其方法调用的结果（如果有）传回给前一个帧。然后，当前帧将被丢弃，而前一个帧将成为当前帧（这就是递归嘛）。</p><p><strong>由线程创建的帧是该线程私有的，不能被其他线程引用！</strong></p><h3 id="局部变量表">局部变量表</h3><h4 id="概况">概况</h4><p>局部变量表储存在栈帧中，定义为一个数字数组，主要用于存储<strong>方法参数</strong>和<strong>定义在方法体内的局部变量</strong>。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（可能是通过句柄引用，也可能是指针直接引用）、<code>returnAddress</code>类型（指向了一条字节码指令的地址）。正是因为它所存储的东西都是编译的时候就可知的，所以局部变量表的分配是在方法调用时（即创建栈帧时）就完成的。</p><blockquote><p><code>returnAddress</code>类型用于 Java 虚拟机的 jsr、ret 和 jsr_w指令。<code>returnAddress</code>类型的值是指向 Java虚拟机指令操作码的指针。与数值型的基本类型不同，<code>returnAddress</code>类型不对应于任何Java编程语言中的类型，并且无法被运行中的程序修改。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3">[2]</span></a></sup></p></blockquote><h4 id="占用空间">占用空间</h4><p>单个局部变量可以保存一个类型为<code>boolean</code> <code>byte</code><code>char</code> <code>short</code> <code>int</code> <code>float</code><code>reference</code>或<code>returnAdress</code>的值。至于<code>long</code>、<code>double</code>都需要一对局部变量才能储存。</p><p>局部变量表最基本的存储单元是Slot（变量槽），一个局部变量对应一个槽位。一些数据类型占用的槽位数如下：</p><table><thead><tr><th>数据类型</th><th>占用槽位数</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td>1</td><td>基本类型</td></tr><tr><td><code>float</code></td><td>1</td><td>基本类型</td></tr><tr><td><code>reference</code></td><td>1</td><td>对象引用（包括数组）</td></tr><tr><td><code>returnAddress</code></td><td>1</td><td>某些跳转指令的返回地址（少见）</td></tr><tr><td><code>long</code></td><td>2</td><td>64 位，需要两个槽位</td></tr><tr><td><code>double</code></td><td>2</td><td>64 位，需要两个槽位</td></tr></tbody></table><h4 id="寻址">寻址</h4><p><strong>局部变量通过索引来寻址</strong>。第一个局部变量的索引为零。当且仅当一个整数介于零到比局部变量数组的大小小一之间时，该整数才被视为局部变量数组的索引。</p><p>值得一提的是，类型为<code>long</code>或<code>double</code>的值会<strong>占用两个连续的局部变量槽位</strong>，<strong>只能通过较小的索引来访问</strong>。</p><p>例如，一个类型为<code>double</code>的值如果存储在索引为<code>n</code>的局部变量数组中，它实际上会占用索引为<code>n</code>和<code>n+1</code>的两个局部变量槽。但你不能从索引为<code>n+1</code>的槽中加载该值。你可以向索引为<code>n+1</code>的槽写入数据，但这样做会使索引为<code>n</code>中的原始数据失效。</p><h4 id="局部变量传递方法参数">局部变量传递方法参数</h4><p>Java 虚拟机使用局部变量来传递方法调用时的参数：</p><ol type="1"><li>对于<strong>类方法</strong>（即<code>static</code>方法）的调用，所有参数从局部变量槽0 开始，依次按顺序存放在连续的局部变量中。</li><li>对于<strong>实例方法</strong>（即非<code>static</code>方法）的调用，局部变量槽0 总是用于存放对<strong>当前对象的引用</strong>（即 Java编程语言中的<code>this</code>关键字）。之后的方法参数从局部变量槽 1开始，依次存放在连续的局部变量中。</li></ol><h3 id="操作数栈">操作数栈</h3><p><code>Operand Stacks</code></p><p>操作数栈是栈帧中的另一个比较重要的组成部分。局部变量存储方法参数和局部变量，而操作数栈用于<strong>临时保存中间运算数据</strong>。操作数栈和局部变量表是配合使用的。</p><p>操作数栈中的每个条目(Entry)可以保存任意一种 Java虚拟机类型的值，包括<code>long</code>或<code>double</code>类型，虽然它们占用两个巨变变量槽，但是在操作数栈中是作为一个单元被看待的。操作数栈有一个与之对应的总深度，<code>long</code>或<code>double</code>为其贡献两个深度，其他的都是一个。</p><p>JVM是一个<strong>强类型</strong>的虚拟机，操作数栈中的值必须用<strong>与之相符</strong>的指令进行操作。比如，不能将两个<code>int</code>值压入栈中，然后试图把它们当作一个<code>long</code>值来处理；也不能将两个<code>float</code>值压入栈后，使用<code>iadd</code>指令来执行加法。编译器和JVM 会通过字节码验证机制（class fileverification），确保所有栈操作都类型正确。否则会抛出验证错误，程序根本无法运行。</p><p>为了说明操作数栈和局部变量表的配合过程，看下面的测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a * b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用IDEA可以查看<code>main</code>方法的字节码（前面的类定义部分和构造函数已忽略）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static main([Ljava/lang/String;)V<br>   <span class="hljs-attribute">L0</span><br>    <span class="hljs-attribute">LINENUMBER</span> <span class="hljs-number">10</span> L0<br>    <span class="hljs-attribute">BIPUSH</span> <span class="hljs-number">6</span><br>    <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">1</span><br>   <span class="hljs-attribute">L1</span><br>    <span class="hljs-attribute">LINENUMBER</span> <span class="hljs-number">11</span> L1<br>    <span class="hljs-attribute">BIPUSH</span> <span class="hljs-number">9</span><br>    <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">2</span><br>   <span class="hljs-attribute">L2</span><br>    <span class="hljs-attribute">LINENUMBER</span> <span class="hljs-number">12</span> L2<br>    <span class="hljs-attribute">ILOAD</span> <span class="hljs-number">1</span><br>    <span class="hljs-attribute">ILOAD</span> <span class="hljs-number">2</span><br>    <span class="hljs-attribute">IMUL</span><br>    <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">3</span><br>   <span class="hljs-attribute">L3</span><br>    <span class="hljs-attribute">LINENUMBER</span> <span class="hljs-number">13</span> L3<br>    <span class="hljs-attribute">RETURN</span><br>   <span class="hljs-attribute">L4</span><br>    <span class="hljs-attribute">LOCALVARIABLE</span> args<span class="hljs-meta"> [Ljava/lang/String; L0 L4 0</span><br><span class="hljs-meta">    LOCALVARIABLE a I L1 L4 1</span><br><span class="hljs-meta">    LOCALVARIABLE b I L2 L4 2</span><br><span class="hljs-meta">    LOCALVARIABLE c I L3 L4 3</span><br><span class="hljs-meta">    MAXSTACK = 2</span><br><span class="hljs-meta">    MAXLOCALS = 4</span><br><span class="hljs-meta">&#125; </span><br></code></pre></td></tr></table></figure><p><code>L0</code>~<code>L4</code>都代表生命周期。逐一查看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">L0</span><br>  <span class="hljs-attribute">BIPUSH</span> <span class="hljs-number">6</span><br>  <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><code>BIPUSH 6</code>: 将数字常量 6 压入操作数栈</li><li><code>ISTORE 1</code>: 将操作数栈的栈顶整数存入局部变量表的 index 1位置（也就是<code>a</code>）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">L1</span><br>  <span class="hljs-attribute">BIPUSH</span> <span class="hljs-number">9</span><br>  <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li><code>BIPUSH 6</code>: 将数字常量 9 压入操作数栈</li><li><code>ISTORE 2</code>: 将操作数栈的栈顶整数存入局部变量表的 index 2位置（也就是<code>b</code>）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">L2</span><br>  <span class="hljs-attribute">ILOAD</span> <span class="hljs-number">1</span><br>  <span class="hljs-attribute">ILOAD</span> <span class="hljs-number">2</span><br>  <span class="hljs-attribute">IMUL</span><br>  <span class="hljs-attribute">ISTORE</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ul><li><code>ILOAD 1</code>：从局部变量表中加载 a（index 1）</li><li><code>ILOAD 2</code>：加载 b（index 2）</li><li><code>IMUL</code>：执行整数相乘，这时产生一个新的结果</li><li><code>ISTORE 3</code>：将结果存入 index 3（即 c）</li></ul><p><code>RETURN</code>: 方法返回（<code>void</code>）</p><p>最后是局部变量表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">LOCALVARIABLE</span> <span class="hljs-variable">args</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Ljava</span><span class="hljs-operator">/</span><span class="hljs-variable">lang</span><span class="hljs-operator">/</span><span class="hljs-built_in">String</span><span class="hljs-operator">;</span> <span class="hljs-variable">L0</span> <span class="hljs-variable">L4</span> <span class="hljs-number">0</span><br><span class="hljs-variable">LOCALVARIABLE</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">L1</span> <span class="hljs-variable">L4</span> <span class="hljs-number">1</span><br><span class="hljs-variable">LOCALVARIABLE</span> <span class="hljs-variable">b</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">L2</span> <span class="hljs-variable">L4</span> <span class="hljs-number">2</span><br><span class="hljs-variable">LOCALVARIABLE</span> <span class="hljs-variable">c</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">L3</span> <span class="hljs-variable">L4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>含义如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>生命周期范围</th><th>槽位 index</th></tr></thead><tbody><tr><td><code>args</code></td><td><code>String[]</code></td><td>L0 到 L4</td><td>0</td></tr><tr><td><code>a</code></td><td><code>int</code></td><td>L1 到 L4</td><td>1</td></tr><tr><td><code>b</code></td><td><code>int</code></td><td>L2 到 L4</td><td>2</td></tr><tr><td><code>c</code></td><td><code>int</code></td><td>L3 到 L4</td><td>3</td></tr></tbody></table><p>最后的<code>MAXSTACK = 2 MAXLOCALS = 4</code>分别指定<strong>操作数栈的最大栈深度</strong>和<strong>局部变量槽的槽位数量</strong>。可见，局部变量数组和操作数栈的大小在编译时就已经确认下来了，这也印证了前面的表述。</p><h4 id="动态链接">动态链接</h4><p><code>Dynamic Linking</code></p><p>前面提到，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口，现在来说说动态链接是怎么一回事。</p><p>在字节码文件中，方法的字节码通过<strong>符号引用</strong>（symbolicreferences）来引用要调用的方法或访问的变量，这时的方法还不知道要调用方法和变量的地址到底在哪里，只是拿到了几个抽象的符号。</p><p><strong>在程序运行期间，动态链接机制会根据需要把符号引用解析为实际的内存地址</strong>，具体来说：</p><ul><li>方法调用的符号引用会被解析为实际的方法地址，并根据需要进行类的加载，确保所有还没解析的符号都被解析完毕；</li><li>变量的符号引用会被解析为从对象或者类结构的起始地址算起的地址偏移量。</li></ul><hr /><p>总而言之，“动态链接”的关键就在于“动态”和“链接”：</p><ul><li>当方法调用、字段访问等字节码指令首次执行时，JVM根据需要动态地把需要解析的符号引用转换为实际地址；</li><li>链接，也就是把符号引用和对应的内存地址连接起来的过程。</li></ul><p>注意，局部变量表的分配在动态链接之前，即使某个字段还没解析出来，局部变量表也照样分配好了，只是等真正执行访问某个方法或字段时，才触发动态链接。</p><hr /><p>还有一个问题，动态链接是怎么知道某个符号引用的实际地址是在哪里的？这是因为每个栈帧包含对当前方法的类型的<em>运行时常量池</em>的引用，而运行时常量池除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。所以说动态链接的实现是依靠运行时常量池的。</p><p>这种在运行时才确定方法和变量的实际地址的机制被称为<strong>延迟绑定机制</strong>。</p><h3 id="异常">异常</h3><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：</p><ol type="1"><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；</li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</li></ol><p>所谓“虚拟机所允许的深度”，指的是虚拟机栈中可容纳的栈帧的深度。因为每调用一个方法都会压入一个栈帧，所以意思就是调用的方法最多能嵌套多少层。</p><p>比如下面这个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recurse</span><span class="hljs-params">()</span> &#123;<br>        recurse();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        recurse();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法调用了<code>recurse</code>，<code>recurse</code>继续调用它本身，每调用一次就压入一个栈帧。由于没有设定终止条件，所以虚拟机栈很快就会溢出。运行报异常：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.StackOverflowError</span><br>at JVMtest<span class="hljs-selector-class">.test1</span><span class="hljs-selector-class">.recurse</span>(test1<span class="hljs-selector-class">.java</span>:<span class="hljs-number">10</span>)<br>at JVMtest<span class="hljs-selector-class">.test1</span><span class="hljs-selector-class">.recurse</span>(test1<span class="hljs-selector-class">.java</span>:<span class="hljs-number">10</span>)<br>        ...<br></code></pre></td></tr></table></figure><p>至于第二种异常，因为HotSpot虚拟机的栈容量是不可以动态扩展的，所以只要线程申请栈空间成功了就不会有OOM。</p><h2 id="本地方法栈">本地方法栈</h2><p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>对应到jdk源码中，由<code>native</code>修饰的方法都是本地方法。比如下面这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">currentTimeMillis</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>在 HotSpot 中是使用 C++ 实现的。</p><p>本地方法栈的异常和虚拟机栈相同。</p><p>Java虚拟机规范没有规定本地方法栈具体的实现形式，HotSpot直接将本地方法栈和虚拟机栈合二为一了。</p><h2 id="java堆">Java堆</h2><h3 id="含义-1">含义</h3><p>首先需要澄清：内存中的堆的和数据结构中的堆完全是两个不同的概念，事实上内存中的堆是用来<strong>存储对象实例</strong>的一块内存区域，数据结构的堆是一种特殊的树形结构，二者没有任何直接关系。</p><p><strong>Java堆（JavaHeap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，由GC 自动管理</strong>。</p><ul><li>作用：Java堆的唯一目的就是<strong>存放对象实例</strong>（Instance），几乎所有的对象的实例（包括数组）都在这里分配内存。直白点说，所有<code>new</code>出来的对象都是在这里分配内存的。</li><li>生命周期：Java堆的生命周期由程序控制或垃圾回收器（GC）控制.</li><li>Java堆可以处于物理上不连续的内存空间，但是在逻辑上必须连续。对于大的对象，连续的内存空间可以提高访问速度。</li></ul><h3 id="异常-1">异常</h3><p><code>OutOfMemoryError</code></p><p>堆相关的异常主要就是内存不够用的问题。当前主流的Java虚拟机都是按照可扩展堆内存来实现的（通过参数-Xmx和-Xms设定）：</p><p><code>-Xmx</code>设置初始堆内存大小，<code>-Xms</code>设置最大堆内存大小。默认情况下JVM会从较小的堆容量开始运行。如果手动设置<code>-Xmx = -Xms</code>，可以避免动态扩容造成的开销，提高性能。</p><p>JVM在启动时会分配一定大小的堆。在<code>new</code>一个对象时，JVM会做如下检查：</p><ul><li>Java堆是否还有可用的空间？<ul><li>有则直接分配</li><li>没有，则尝试通过垃圾分配机制回收出空间</li><li>如果回收后还是不够用，JVM会尝试拓展堆（允许的话）</li><li>如果堆已经达到上限，则抛出异常：<code>OutOfMemoryError</code></li></ul></li></ul><h2 id="方法区">方法区</h2><figure><img src="https://s21.ax1x.com/2025/05/30/pVpxvHx.png"alt="方法区示意图" /><figcaption aria-hidden="true">方法区示意图</figcaption></figure><h3 id="含义-2">含义</h3><p><code>Method Area</code></p><p>运行时数据区有两个多线程共享的区域，一个是Java堆，另一个就是方法区。</p><p>Oracle <ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">官方文档</a>是这样描述方法区的：</p><blockquote><p>方法区类似于传统语言中编译代码的存储区域，或者类似于操作系统进程中的<code>text</code>段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p></blockquote><ul><li>作用：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li><li>生命周期：方法区在虚拟机启动时创建，关闭时释放</li><li>Java虚拟机规范既不强制要求方法区的位置、管理编译后的机器代码(compiledcode)的位置，也不要求方法区的大小是否固定，既可以是固定大小，也可以扩展或者收缩。</li><li>方法区的内存不需要是连续的。</li><li>方法区的垃圾收集行为比较少见，主要是针对常量池的回收和对类型的卸载。</li></ul><h3 id="hotspot方法区的演进">HotSpot方法区的演进</h3><p>JDK8 之前使用永久代来实现方法区，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是这种设计也导致了Java应用更容易遇到内存溢出的问题。</p><p>在Java 8以后，永久代被<strong>元空间</strong>(Metaspace)元空间也不属于 Java堆，而是使用本地内存分配，即在操作系统的内存中开辟区域。</p><h3 id="异常-2">异常</h3><p>《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p><h3 id="运行时常量池">运行时常量池</h3><p>运行时常量池（Runtime ConstantPool）是方法区的一部分，每个运行时常量池是从方法区分配内存的。</p><p>运行时常量池是每个类或接口在运行时对 class文件中<code>constant_pool</code>表（常量池表）的一种实现形式。字节码中的<code>constant_pool</code>表存放了编译期生成的各种字面量与符号引用，类加载以后这些信息被存放到方法区的运行时常量池中。一般来说，它除了保存Class文件中描述的<strong>符号引用</strong>外，还会把由符号引用翻译出来的<strong>直接引用</strong>也存储在运行时常量池中。</p><p>简单来说，运行时JVM会把class文件中预置的 <em>常量池表</em> 加载为<em>运行时常量池</em> 。相当于把预制菜煮熟的过程(?)</p><p>除了这种预制的方式以外，运行时常量池中的常量也可以是<strong>动态</strong>生成的，例如String 的<code>intern</code>方法。这是因为 Java 中的 String类自己(privately)维护了一个字符串常量池，调用<code>intern</code>方法时，如果池中已包含一个由<code>equals(Object)</code>方法确定与此<code>String</code>对象相等的字符串，则返回池中的字符串。否则，将此<code>String</code>对象添加到池中，并返回对此<code>String</code>对象的引用。</p><h2 id="直接内存">直接内存</h2><figure><img src="https://s21.ax1x.com/2025/05/30/pVpz6Vx.png"alt="直接内存、堆外内存、本地内存的关系[3]" /><figcaptionaria-hidden="true">直接内存、堆外内存、本地内存的关系<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://juejin.cn/post/7195478842432028732">[3]</span></a></sup></figcaption></figure><div class="note note-secondary">            <p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</p>          </div><p><strong>直接内存是在Java堆外的、直接向系统申请的内存区间，专门用于JVM 和 IO 设备打交道，Java底层使用 C 语言的 API 调用操作系统与 IO设备进行交互</strong>。</p><p>例如，在JDK1.4中新加入的<code>NIO(New Input/Output)</code>类，引入了一种利用<strong>通道</strong>和<strong>缓冲区</strong>的IO方式，调用<code>Native</code>函数库分配堆外内存，通过JVM堆中的<code>DirectByteBuffer</code>对这一部分本地内存进行<strong>虚引用</strong>。</p><p><em>虚引用</em>，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>为什么要用虚引用？因为直接内存位于 JVM掌控的范围之外，垃圾收集器对它不起作用。因此，直接内存的回收需要做进一步的手动清理，你想对内存操作的话起码得通过引用拿到它的地址吧。虚引用的作用就是跟踪<em>被引用的对象被垃圾回收器回收</em> 这一活动，具体来讲：</p><ul><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的<strong>引用队列</strong>中；</li><li>于是 Java程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收；</li><li>如果程序发现某个虚引用已经加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动（调用<code>Cleaner</code>的<code>clean</code>方法）。</li></ul><figure><img src="https://s21.ax1x.com/2025/05/30/pVpz8rn.png" alt="NIO" /><figcaption aria-hidden="true">NIO</figcaption></figure><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://juejin.cn/post/7195478842432028732<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloudflare配置将博客旧域名的请求重定向到新域名</title>
    <link href="/2025/05/30/Cloudflare%E9%87%8D%E5%AE%9A%E5%90%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2025/05/30/Cloudflare%E9%87%8D%E5%AE%9A%E5%90%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>在博客更换域名之后利用Cloudflare将向旧域名的请求重定向到新域名，并且保留请求的资源路径和查询字符串</p><span id="more"></span><h2 id="前言">前言</h2><p>最近为博客更换了域名，原域名为<code>kznep19.blog</code>，因为续费费用过高而更换为现在的<code>kznleaf.top</code>。现在遇到了几个问题：</p><ol type="1"><li>原域名虽然不再使用了，但是一直到2026年1月才过期；</li><li>Google和必应搜索引擎仍在收录原域名下的文章页，如果马上废弃原域名，又要重新抓取一遍文章；</li><li>有几篇博客在别的地方被引用了，我希望这些外链仍然能够生效</li></ol><p>综上考虑，我希望获得的效果是：将博客切换为新域名，同时为旧域名配置重定向，使得对旧域名下的资源的请求会被自动重定向到新域名下对于的资源路径。</p><p>花了不少时间查资料，大部分的解决方案都是通过配置页面规则(PageRules)配置的方式实现重定向，我经过尝试之后发现并没有效果。最后找到了这篇博客：</p><p><ahref="https://appscross.com/blog/issues-resolved-during-cloudflares-configuration-site-redirection-process.html">Cloudflare配置站点重定向</a></p><p>这个博客是把对旧域名下的任何资源的请求都重定向到一个固定的URL下，我在该博客的基础上做了一些补充，最后达到了理想的效果。</p><h2 id="配置要点">配置要点</h2><h3 id="配置重定向规则">配置重定向规则</h3><p>先打开主页左侧的“规则”，然后点击右侧的创建规则——<strong>重定向规则</strong>。（注意不是最左边的页面规则，这两个不是一个东西，后面会说）</p><figure><img src="https://s21.ax1x.com/2025/05/30/pV9F3fP.png"alt="重定向规则" /><figcaption aria-hidden="true">重定向规则</figcaption></figure><p>这里为我们提供了三个选项：</p><p><img src="https://s21.ax1x.com/2025/05/30/pV9FGSf.png" /></p><p>应当选择<strong>重定向到其他域</strong>。<ahref="https://developers.cloudflare.com/rules/url-forwarding/examples/redirect-all-different-hostname/">官方文档</a>对它的描述为：</p><div class="note note-secondary">            <p>创建重定向规则，将对<code>smallshop.example.com</code>的所有请求重定向到使用HTTPS 的其他主机名，同时保留原始路径和查询字符串。</p>          </div><p>使用通配符匹配模式，如果请求的URL为<code>http*://smallshop.example.com/*</code>，那么：</p><ul><li>目标URL：<code>https://globalstore.example.net/$&#123;2&#125;</code></li><li>状态码：301</li><li>保留查询字符串：启用</li></ul><p>请求URL中的<code>*</code>是对零个或者多个字符进行匹配，这里表示使用HTTP 或 HTTPS协议对<code>smallshop.example.com</code>下的任意资源的请求都将被匹配。</p><p>目标URL即该请求将会被重定向到的URL，其中的<code>$&#123;2&#125;</code>是对通配符捕获的内容的引用，这里代表的是请求URL中的第二个<code>*</code>，所以用户最终访问的是新域名<code>globalstore.example.net</code>下的对应资源。</p><p>从上面的描述可以看出这就是我们想要的东西。那接下来的配置就很简单了，按照刚才提到的三点：目标URL、状态码、启用保留查询字符串配置即可。</p><p><img src="https://s21.ax1x.com/2025/05/30/pV9FO7d.png" /></p><h3 id="使规则生效">使规则生效</h3><p>光是配置规则是不够的，还要给这个域名添加DNS记录以使规则生效。创建一条A记录即可，IP地址可以随便写，我这里用的是保留IP地址<code>192.0.2.1</code>，写了两条</p><p><img src="https://s21.ax1x.com/2025/05/30/pV9kn3V.png" /></p><p>关于这一部分，Cloudflare文档在Page Rules一节中是这样说的：</p><p><img src="https://s21.ax1x.com/2025/05/30/pV9kajO.png" /></p><p><ahref="https://developers.cloudflare.com/rules/page-rules/">原文链接</a></p><p>也就是说如果IP地址作为占位符的话，最好使用保留IP地址<code>192.0.2.*</code>，避免把流量发到什么奇怪的地方。</p><h2 id="page-rules和redirects的区别">Page Rules和Redirects的区别</h2><p>前面提到了，在搜索引擎中搜索“使用Cloudflare把旧域名重定向到新域名”，弹出来的结果大部分都是使用PageRules的，但这其实不太合适。其实关键就是<strong>转发</strong>和<strong>重定向</strong>的区别。PageRules中可以配置一个叫做<code>URL Forwarding(转发URL)</code>的东西：</p><figure><img src="https://s21.ax1x.com/2025/05/30/pV9Alxf.png"alt="页面规则中的转发URL" /><figcaption aria-hidden="true">页面规则中的转发URL</figcaption></figure><p>如果你配置了目标地址，那么：</p><div class="note note-secondary">            <p>If you enter the address above in the forwarding box and select AddRule, within a few seconds any requests that match the pattern youentered will automatically be forwarded with an HTTP 302 redirect statuscode to the new URL.</p>          </div><p>即这样配置返回的状态码是<code>302</code>，而刚才的重定向状态码是301，至此熟悉计网的人应该清楚是怎么一回事了。不过还是再看看<ahref="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">wiki</a>对这两种状态码的表述：</p><figure><img src="https://s21.ax1x.com/2025/05/30/pV9Amad.png"alt="状态码301和302的区别" /><figcaption aria-hidden="true">状态码301和302的区别</figcaption></figure><ul><li>301用于永久重定向的情况，发起请求的客户端收到这个状态码之后，除了收到一个用于重定向的地址以外，还会被告知把以后的请求目标地址也改成这个地址，而且这个地址默认是会被缓存的。</li><li>302用于临时重定向，而且这个响应不会被缓存，客户端以后继续向旧域名发送请求。</li></ul><p>所以在考虑是选择页面规则中的转发URL还是创建重定向规则的时候，应当根据以上内容进行考虑。像我这种为网站更换域名的情况当然是选择重定向了。</p>]]></content>
    
    
    <categories>
      
      <category>Cloudflare</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Cloudflare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三次博客折腾记录</title>
    <link href="/2025/05/27/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%98%E8%85%BE/"/>
    <url>/2025/05/27/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%98%E8%85%BE/</url>
    
    <content type="html"><![CDATA[<p>最近又折腾了一下博客，第一次折腾应该是年初的时候绑定域名，第二次是一个月之前，这回应该是近期的最后一次了。</p><p>主要内容：</p><ol type="1"><li>把博客的域名换成了<code>kznleaf.top</code>，因为觉得原来的域名不好听。续费的话大约一年30rmb，还算实惠，以后没有特殊情况的话应该不会再改了</li><li>DNS解析服务由 DNSPod 换成 Cloudflare，因为不想用腾讯的产品</li><li>移除毛玻璃效果</li><li>移除关于页的 GitHub 事件统计和 contribution graph</li></ol><p>最后一条为什么要关闭这两个呢，因为今天测试网站功能的时候，关掉代理，F12关闭缓存，发现关于页的加载速度极其缓慢，查看网络：</p><figure><img src="https://s21.ax1x.com/2025/05/27/pVSLhpn.png" alt="乐" /><figcaption aria-hidden="true">乐</figcaption></figure><p>这里用到的两个项目：GitHub事件统计 和 Contribution Graph都被大陆墙了</p><p>因为我之前设置了预加载功能，并且规定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  $(<span class="hljs-string">&quot;#Loadanimation&quot;</span>).<span class="hljs-title function_">fadeOut</span>(<span class="hljs-number">500</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>即整个页面的资源都加载完毕后再退出动画，所以这两个无法访问项目会使访问者长时间卡在预加载动画出不来，直到达到超时时间放弃加载。</p><p>ChatGPT:</p><blockquote><p>Contribution Graph的服务部署在 vercel.app 域名上，大陆对 vercel.app屏蔽严重，所以无法访问。</p></blockquote><p>我现在也没精力去想解决方案...干脆删掉好了</p><p><span class="heimu" title="你知道的太多了">GFW你赢了</span></p><p>之前我在某电子信息强校（大嘘）的电子实验室的古董电脑上尝试访问过自己的博客，已经发现了关于页无法加载的问题，而且由于最早发布的十几篇博客的封面图是托管在imgur 上的，所以博客的前两页的内容全都无法加载。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-缓存</title>
    <link href="/2025/05/20/MyBatis-%E7%BC%93%E5%AD%98/"/>
    <url>/2025/05/20/MyBatis-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis的缓存">MyBatis的缓存</h1><p>参考链接：</p><p><ahref="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制-美团技术团队</a></p><p><ahref="https://itmyhome.com/mybatis-pdf/MyBatis-3-User-Guide-Simplified-Chinese.pdf">MyBatis用户指南</a></p><p><ahref="https://www.cnblogs.com/gavincoder/p/13977037.html">Mybatis深入浅出之缓存机制</a></p><h2 id="一级缓存">一级缓存</h2><h3 id="使用">使用</h3><p>一级缓存默认开启，是sqlSession级别的。同一个 sqlSession对象在执行查询时，如果执行过相同的 SQL 且参数也一样，MyBatis会将结果缓存起来，后续再查相同内容时直接从缓存中取，而不是再访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br><span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> session.selectOne(<span class="hljs-string">&quot;getUserById&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> session.selectOne(<span class="hljs-string">&quot;getUserById&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>u1</code>正常查询数据库，<code>u2</code>直接从一级缓存中读取查询过的数据。</p><figure><img src="https://s21.ax1x.com/2025/05/20/pExKhgx.png"alt="一级缓存流程图" /><figcaption aria-hidden="true">一级缓存流程图</figcaption></figure><p>每个SqlSession中持有Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入LocalCache，最后返回结果给用户。</p><!-- ![一级缓存时序图](https://s21.ax1x.com/2025/05/20/pExKIKK.jpg) --><h3 id="失效">失效</h3><p>一级缓存不是永久有效的，它在以下几种情况下会失效：</p><ol type="1"><li>不同的sqlSession。<strong>每个sqlSession都有自己的一级缓存</strong>，互不影响，不同的session不会共享缓存。</li><li>执行了增删改操作。这些操作可能会修改数据，为了保证数据的一致性，MyBatis会清除缓存。不管是否真的改动了数据库、也不管是否提交事务，一级缓存都会被清除。</li><li>手动清除缓存，调用<code>session.clearCache()</code>清除一级缓存。</li><li>同一条SQL但是查询参数不同。</li></ol><p><strong>手动清除缓存测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(student);<br>    sqlSession.clearCache();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(student2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>因为两次查询之间手动清除了缓存，所以第二次查询的时候仍然要连接数据库，发送sql语句至数据库进行查询。</p><p><strong>增删改清除缓存测试</strong></p><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;第一次查询：&quot;</span> + student);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteStudentById(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;第二次查询：&quot;</span> + student2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>第一次查询：Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br>DEBUG [main] - ==&gt;  Preparing: DELETE FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 12(Integer)<br>DEBUG [main] - &lt;==    Updates: 1<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>第二次查询：Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>可以清楚地看到，虽然删除操作并没有被提交，但是第二次查询还是要重新连接数据库。</p><h2 id="二级缓存">二级缓存</h2><p>一级缓存是 <strong>SqlSession</strong> 级别的缓存，每个 SqlSession拥有自己的缓存。</p><p>二级缓存是 <strong>namespace</strong>级别的缓存，<strong>它是可以被多个 SqlSession共享的缓存</strong>。因为一个Mapper映射配置文件往往对应一个namespace，所以也可以说它是 <strong>Mapper</strong> 级别的缓存。</p><figure><img src="https://s21.ax1x.com/2025/05/20/pExM3GR.png"alt="二级缓存流程图" /><figcaption aria-hidden="true">二级缓存流程图</figcaption></figure><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p><p>当开启二级缓存后，数据的查询执行的流程就是<code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>，更新执行顺序：<code>数据库-&gt;一级缓存-&gt;二级缓存</code>。</p><h3 id="二级缓存配置">二级缓存配置</h3><p>MyBatis默认情况下只开启局部的session 缓存，二级缓存需要手动开启。</p><ol type="1"><li>在<code>&lt;setting&gt;</code>标签中设置<code>cacheEnabled</code>属性的值为<code>true</code>;</li><li>在MyBatis的映射XML中配置cache：<code>&lt;cache/&gt;</code>;</li><li>二级缓存必须在sqlSession关闭或提交后才有效；</li><li>查询数据所转换的实体数据类型必须实现序列化接口<code>Serializable</code>。</li></ol><p>完成上述配置之后，查询语句会默认使用缓存。效果如下：</p><ul><li>XML映射语句文件中的所有<code>select</code>都会被缓存，所有增删改关键字都会刷新缓存。</li><li>缓存会使用<ahref="https://leetcode.cn/problems/lru-cache/">LRU算法</a>来收回。</li><li>缓存没有刷新间隔，不会根据时间自动刷新。</li></ul><p>二级缓存依赖于一级缓存，<code>sqlSession.close()</code>执行完，Mybatis会将一级缓存对象拷贝存储到二级缓存，然后二级缓存才会起作用。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 加载配置</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br><br>    <span class="hljs-comment">// 2. 创建两个 sqlSession 进行数据库操作</span><br><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-type">CacheMapper</span> <span class="hljs-variable">sqlSession1Mapper</span> <span class="hljs-operator">=</span> sqlSession1.getMapper(CacheMapper.class);<br>    <span class="hljs-type">CacheMapper</span> <span class="hljs-variable">sqlSession2Mapper</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(CacheMapper.class);<br><br>    <span class="hljs-comment">// 第一次查询</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> sqlSession1Mapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(s1);<br>    <span class="hljs-comment">// 关闭一级缓存,将数据从内存存储到硬盘</span><br>    sqlSession1.close();<br>    <span class="hljs-comment">// 第二次查询，相同 namespace 下查询，二级缓存命中</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> sqlSession2Mapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(s2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - Cache Hit Ratio [com.kzn.mapper.CacheMapper]: 0.0<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br> WARN [main] - As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66<br>DEBUG [main] - Cache Hit Ratio [com.kzn.mapper.CacheMapper]: 0.5<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>第二次查询使用了缓存，缓存命中率0.5.</p><p>注意：</p><ul><li><strong>二级缓存依赖于一级缓存写入</strong>，不关闭sqlSession1，不会写入当前namespace的二级缓存，造成二级缓存失效。</li><li>Mybatis二级缓存对象存储在<strong>硬盘</strong>中，因此需要namespace下实体对象序列化，如果不序列话运行会报错。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-结果映射（resultMap）详解</title>
    <link href="/2025/05/18/MyBatis-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/"/>
    <url>/2025/05/18/MyBatis-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1id="mybatis-结果映射resultmap详解">MyBatis-结果映射（resultMap）详解</h1><h2 id="前言">前言</h2><p>看MyBatis网课的时候这一部分把我听红温了，遂自己梳理。</p><p>resultMap的作用是什么？如果JavaBean的属性名和数据库中的列名（字段名）刚好一一对应并且名字也相同，那么就不需要什么映射关系了，可以直接通过SQL查询出表中的所有信息。但是事实往往没那么理想，很多情况下这两个的名字并不相同，甚至不存在一一对应的关系；而且我们可能并不满足于仅查询一张表，而是要把两张表的关键信息合在一起。不管是那种情况，都需要手动处理映射关系。</p><h2 id="目录">目录</h2><ol type="1"><li><ahref="#mybatis的结果映射resultmap详解">MyBatis的结果映射（resultMap）详解</a><ol type="1"><li><a href="#前言">前言</a></li><li><a href="#目录">目录</a></li><li><a href="#resultmap">resultMap</a></li><li><a href="#id和result">id和result</a></li><li><a href="#constructor">constructor</a><ol type="1"><li><a href="#为什么需要构造方法">为什么需要构造方法</a></li><li><a href="#用法">用法</a></li></ol></li><li><a href="#association">association</a><ol type="1"><li><a href="#嵌套-select-查询按需加载">嵌套 Select 查询（按需加载）</a><ol type="1"><li><a href="#概念">概念</a></li><li><a href="#实战">实战</a></li><li><a href="#反思">反思</a></li></ol></li><li><a href="#嵌套结果映射">嵌套结果映射</a></li></ol></li><li><a href="#resultset">resultSet</a></li></ol></li></ol><h2 id="resultmap">resultMap</h2><p>一个映射关系由<code>&lt;resultMap&gt;</code>标签包裹，而这个标签本身也有它的属性：</p><ul><li><code>id</code>: <code>resultMap</code>标签的唯一标识。</li><li><code>type</code>: 返回值的 Java全限定类名，或类型别名（在已经处理好别名的情况下）。</li><li><code>autoMapping</code>: MyBatis 用来控制是否自动映射数据库字段到Java 对象属性的开关。<code>autoMapping="true"</code>时，MyBatis会自动匹配列名与属性名相同的字段。匹配规则：<ul><li>数据库的列名与 Java的属性名匹配（忽略大小写、支持下划线转驼峰）；</li><li>没有被<code>&lt;result&gt;</code>明确指定</li><li>必须依赖<code>&lt;setting&gt;</code>中的全局配置项：<code>&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;</code></li></ul></li></ul><h2 id="id和result">id和result</h2><blockquote><p>id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int,double, Date 等）的属性或字段。</p></blockquote><p>两个元素的常用属性有：</p><ul><li><code>property</code>: 映射到列结果的字段或属性。如果 JavaBean有这个名字的属性（property），会先使用该属性。可以理解为“Java的实体类的属性”。<ul><li><code>id</code>元素的<code>property</code>往往取表中的主键对应的Java1实体类的属性名，例如<code>&lt;id property="id" column="user_id" /&gt;</code>意思就是表的主键名字是<code>user_id</code>，与之对应的Java属性名为<code>id</code>。</li><li><code>result</code>元素的<code>property</code>用来定义其他普通元素和表中的列的一一对应的映射关系。</li></ul></li><li><code>column</code>：已经存在的数据库中的列名，如果有别名的话也可以是别名。</li><li><code>javaType</code>:Java类的全限定名，对于内置的类型别名，如<code>java.lang.String</code>，可以写为<code>String</code>。如果映射到一个JavaBean，MyBatis 通常可以推断类型，此项忽略不写。</li></ul><p>简而言之，<code>id</code>用于设置主键字段与领域模型属性的映射关系，<code>result</code>用于设置普通字段与领域模型属性的映射关系。</p><h2 id="constructor">constructor</h2><h3 id="为什么需要构造方法">为什么需要构造方法</h3><p>首先明确一点，当我们执行查询操作的时候，MyBatis不会直接返回数据库原始数据，它会把查询结果“映射”成<strong>Java对象</strong>返回给你。例如，<code>SELECT id, name FROM user;</code>这一sql语句，如果在MySQL中直接运行，返回的是一张表格，但你总不能让Java 返回原始的 SQL 表格吧？你希望得到的是<strong>Java对象</strong>，对应下面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = userMapper.selectAll();<br></code></pre></td></tr></table></figure><p>MyBatis 会把那张表的每一行构造成一个 User 对象，然后放到 List里返回。</p><p>对于一般的可变对象，JavaBean会提供一个<code>setter</code>方法，有了这个方法之后事情就很好办了，只需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>u.setId(<span class="hljs-number">1</span>);<br>u.setName(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure><p>MyBatis 先通过空参构造器构建一个<code>User</code>对象，然后通过setter 为这个对象一一赋值。</p><p>但是，有时我们希望一个类的对象一旦创建就不能更改（即不可变类），例如用户的id ，名字和年龄在特定时间段内是固定不变的，那么 JavaBean 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 全参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String username, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">// 没有 setter 方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时想给对象的属性赋值，最直接的一种方式就是使用构造函数，在初始化的时候就赋好值。</p><p>因为 MyBatis 不能像原来一样调用 setter来赋值，所以需要使用构造函数赋值。“赋值”这个操作也就是所谓的<strong>注入</strong>(injection)，官方文档是这样说的：</p><blockquote><p>MyBatis 也支持私有属性和私有 JavaBean属性来完成注入，但有一些人更青睐于通过构造方法进行注入。</p></blockquote><p>这句话的意思就是：<em>MyBatis也可以通过反射直接修改私有字段的值，但这不总是最好的做法。很多程序员更喜欢只允许通过构造函数设置属性值</em>。</p><p>上面提到，MyBatis也可以通过反射直接注入私有字段，不过有些程序员还是喜欢使用构造方法达成目的，而<code>constructor</code>就是为此而生的。</p><h3 id="用法">用法</h3><p>假设我们的数据库中的字段为：user_id, user_name, user_age。</p><p>先把<code>User</code>需要用到的方法补充完整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id,</span><br><span class="hljs-params">                <span class="hljs-meta">@Param(&quot;username&quot;)</span> String username,</span><br><span class="hljs-params">                <span class="hljs-meta">@Param(&quot;age&quot;)</span> <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// getter 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> id; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> username; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> age; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper接口：<code>User selectUserById(int id);</code></p><p>然后为上面那个<code>User</code>写一个XML映射吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 构造器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_age&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    SELECT user_id, user_name, user_age FROM users WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>column=数据库字段名</code><br /></li><li><code>name=构造器参数名</code></li><li><code>idArg</code>是主键，<code>arg</code>是普通字段</li><li>因为我们在接口中使用<code>@Param</code>显式为参数起名，所以<code>&lt;constructor&gt;</code>内部的顺序可以是任意的。</li></ul><h2 id="association">association</h2><p>关联（association）元素处理一对一类型的关系。MyBatis有两种不同的方式加载关联：</p><h3 id="嵌套-select-查询按需加载">嵌套 Select 查询（按需加载）</h3><h4 id="概念">概念</h4><ul><li>嵌套 Select查询：也叫<strong>延迟加载</strong>、<strong>按需加载</strong>。它是通过调用另一个SQL 映射语句，来加载关联对象的。</li></ul><p><strong>嵌套Select查询的特点</strong>：按需加载，也就是“懒汉式”；执行效率稍慢。</p><p>假如我们现在有两个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">users(id, name, dept_id)<br>departments(id, dept_name)<br></code></pre></td></tr></table></figure><p>Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    Department dept;  <span class="hljs-comment">// 关联属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义一个<code>selectAllById</code>方法<code>User selectAllById(Integer id)</code>，User的前两个属性都是基本数据类型，查询起来很简单。但是<code>dept</code>属于引用类型，<strong>MyBatis不会自动填充这种关联字段</strong>，除非我显式地配置了关联查询。</p><p>按照嵌套 Select查询的思路，我们可以在映射关系中将<code>dept</code>属性和<code>selectDeptById</code>方法关联起来，需要查询时就调用<code>selectDeptById</code>部门查询语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义映射关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Department&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectDeptById&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 部门查询语句 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDeptById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Department&quot;</span>&gt;</span><br>  SELECT id, dept_name AS deptName<br>  FROM departments<br>  WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>javaType</code>用于修饰<code>dept</code>属性，指定该属性的数据类型；</li><li><code>select</code>指定关联的是查询方法，且方法名为<code>selectDeptById</code>，意思就是<code>dept</code>这个属性是靠这个查询语句查出来的。</li><li><code>column</code>为数据库中的列名，这里表示将数据库中的这一字段作为参数<strong>传递</strong>给<code>selectDeptById</code>语句，由<code>#&#123;id&#125;</code>接收。<code>column</code>往往是多个表共有的列。</li></ul><p>然后利用<code>resultMap</code>定义查询语句就OK：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>SELECT * FROM users WHERE id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样依赖调用<code>selectAllById</code>就能获取用户的所有信息了。</p><h4 id="实战">实战</h4><p>好了下面是实战环节🥰</p><p>现在我的数据库中有两张表：</p><ul><li>sys_user</li></ul><table><thead><tr><th>uid</th><th>username</th><th>user_pwd</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>114411</td></tr><tr><td>2</td><td>测试</td><td>111</td></tr><tr><td>3</td><td>CowBoy</td><td>2233</td></tr></tbody></table><ul><li>sys_schedule</li></ul><table><thead><tr><th>id</th><th>uid</th><th>title</th><th>completed</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>学习Java</td><td>0</td></tr><tr><td>2</td><td>2</td><td>吃饭</td><td>1</td></tr></tbody></table><p>目标：写一个查询语句，能够把所有用户本身的属性及其对应的事务一次性查询出来。</p><p>根据两张表的字段名，定义两个Java类：</p><ul><li><code>User.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String user_pwd;<br><br>    <span class="hljs-keyword">private</span> Schedule schedule;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Integer uid, String username, String user_pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.uid = uid;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.user_pwd = user_pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, String user_pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.user_pwd = user_pwd;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, user_pwd=&#x27;&quot;</span> + user_pwd + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, schedule=&quot;</span> + schedule +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>schedule.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Schedule</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Integer completed;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Schedule</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Schedule&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;sid=&quot;</span> + sid +<br>                <span class="hljs-string">&quot;, uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, title=&#x27;&quot;</span> + title + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, completed=&quot;</span> + completed +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面开始考虑接口。</p><p><code>sys_user</code>记录了每一个用户的信息，<code>sys_schedule</code>记录了用户的事务，两张表通过主键<code>uid</code>关联起来。现在的目标是：写一个查询语句，能够把所有用户的所有自带属性及其对应的事务一次性查询出来。编写接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打印所有的用户及其对应的日程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含所有属性的用户实体类</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">getAllUserAndSchedule</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>既然要查询日程，那就少不了查询日程的方法，所以在<code>ScheduleMapper.java</code>添加接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduleMapper</span> &#123;<br>    <span class="hljs-comment">// 根据uid查询用户的事务</span><br>    Schedule <span class="hljs-title function_">getScheduleByUid</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> Integer uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK下面可以配置XML了。先从最简单的日程的查询开始，在<code>ScheduleMapper.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Schedule getScheduleByUid(Integer uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getScheduleByUid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Schedule&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_schedule<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是很简单的根据<code>uid</code>查询指定日程的sql语句。</p><p>接下来在<code>UserMapper.xml</code>配置映射关系和查询语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--获取所有的用户及其实体类，测试associate标签--&gt;</span><br><span class="hljs-comment">&lt;!--  User getAllUserAndSchedule();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ScheduleAndUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.kzn.mapper.ScheduleMapper.getScheduleByUid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserAndSchedule&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ScheduleAndUser&quot;</span>&gt;</span><br>    SELECT * FROM sys_user LIMIT 3<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：因为在映射关系中引用的<code>getScheduleByUid</code>方法的XML配置位于另一个XML文件中，所以这里对该方法的引用要使用<code>全类名.方法名</code>的形式。</p><p>所有的代码都准备完毕之后就可以测试了。准备单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserAndSchedule</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; allUserAndSchedule = userMapper.getAllUserAndSchedule();<br>    allUserAndSchedule.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果（附带日志功能，这里我手动加了空行方便阅读）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user LIMIT 3<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;====    Columns: sid, uid, title, completed<br>TRACE [main] - &lt;====        Row: 1, 1, 学习Java, 0<br>DEBUG [main] - &lt;====      Total: 1<br><br>TRACE [main] - &lt;==        Row: 2, 测试, 111<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 2(Integer)<br>TRACE [main] - &lt;====    Columns: sid, uid, title, completed<br>TRACE [main] - &lt;====        Row: 2, 2, 吃饭, 1<br>DEBUG [main] - &lt;====      Total: 1<br><br>TRACE [main] - &lt;==        Row: 3, CowBoy, 2233<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 3(Integer)<br>DEBUG [main] - &lt;====      Total: 0<br>DEBUG [main] - &lt;==      Total: 3<br><br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;, schedule=Schedule&#123;sid=1, uid=1, title=&#x27;学习Java&#x27;, completed=0&#125;&#125;<br>User&#123;uid=2, username=&#x27;测试&#x27;, user_pwd=&#x27;111&#x27;, schedule=Schedule&#123;sid=2, uid=2, title=&#x27;吃饭&#x27;, completed=1&#125;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;2233&#x27;, schedule=null&#125;<br></code></pre></td></tr></table></figure><p>从日志中可以直观地发现一共执行了4次查询操作（每一组<code>==&gt;</code>都对应一次查询请求）。</p><h4 id="反思">反思</h4><p>嵌套 Select的复用性更很好，结构也很清晰，方便维护，但是它会导致所谓的<strong>N+1查询问题</strong>，结合上面的例子就很好说明：</p><ul><li><code>1</code>，指的是操作者调用了一次查询语句<code>getAllUserAndSchedule</code>，操作者期望一次返回所有的用户及其日程</li><li><code>N</code>，为了完成<code>getAllUserAndSchedule</code>的查询命令，对于N个用户，MyBatis一共需要调用N次<code>getScheduleByUid</code>查询语句以获取日程信息。</li></ul><p>宏观调用的一次加上MyBatis内部调用的N次，合起来就是N+1次。显然，这个问题会导致成百上千的SQL 语句被执行，效率是非常低下的。</p><blockquote><p>好消息是，MyBatis能够对这样的查询进行<strong>延迟加载</strong>，因此可以将大量语句同时运行的开销分散开来。然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。</p></blockquote><p>所以还有另外一种方法——<strong>嵌套结果映射</strong>。</p><h3 id="嵌套结果映射">嵌套结果映射</h3><ul><li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</li></ul><p>嵌套结果映射的查询方式本质上还是MySQL的<ahref="/2025/05/06/MySQL基本使用/#多表查询联结表">多表查询</a>。仍然以上面的情况为例，要把用户的基本信息和日程放在一起并且保证用户的信息一个不少，那不就是外部链接查询吗：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.uid, user.Username, schedule.title<br><span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">AS</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> sys_schedule <span class="hljs-keyword">AS</span> schedule<br><span class="hljs-keyword">ON</span> schedule.uid <span class="hljs-operator">=</span> user.uid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.uid<br>LIMIT <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>（这是利用ORDER BY是因为不这样做的话输出会乱序）</p><p>所以只要把剩下的xml配置做好就行了，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--嵌套映射方式--&gt;</span><br><span class="hljs-comment">&lt;!--List&lt;User&gt; getAllUserAndSchedule_mapping();--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ScheduleAndUserMapping&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--第三列使用映射解决--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--把表中的title字段映射到Schedule的title属性--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserAndSchedule_mapping&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ScheduleAndUserMapping&quot;</span>&gt;</span><br>    SELECT user.uid, user.Username, schedule.title<br>    FROM sys_user AS user<br>    LEFT JOIN sys_schedule AS schedule<br>    ON schedule.uid = user.uid<br>    ORDER BY user.uid<br>    LIMIT 3<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT user.uid, user.Username, schedule.title FROM sys_user AS user LEFT JOIN sys_schedule AS schedule ON schedule.uid = user.uid ORDER BY user.uid LIMIT 3<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, Username, title<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 学习Java<br>TRACE [main] - &lt;==        Row: 2, 测试, 吃饭<br>TRACE [main] - &lt;==        Row: 3, CowBoy, null<br>DEBUG [main] - &lt;==      Total: 3<br><br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;null&#x27;, schedule=Schedule&#123;sid=null, uid=null, title=&#x27;学习Java&#x27;, completed=null&#125;&#125;<br>User&#123;uid=2, username=&#x27;测试&#x27;, user_pwd=&#x27;null&#x27;, schedule=Schedule&#123;sid=null, uid=null, title=&#x27;吃饭&#x27;, completed=null&#125;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;null&#x27;, schedule=null&#125;<br></code></pre></td></tr></table></figure><p>查询出的数据只有三列：uid, username,title，没有查询的数据均显示为null，这样只查询了必要的数据。</p><p>而且，从日志可以发现全程只执行了一次查询操作，大大提高执行的效率。</p><h2 id="resultset">resultSet</h2><div class="note note-secondary">            <p>某些数据库允许存储过程返回多个结果集(resultSet)，或一次性执行多个语句，每个语句返回一个结果集。我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。</p>          </div><p>比如，下面这个存储过程一次性执行了用户基本信息的查询和日程的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> get_student_by_id (<br>    <span class="hljs-keyword">IN</span> p_uid <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> uid <span class="hljs-operator">=</span> p_uid;<br>    <span class="hljs-keyword">SELECT</span> uid, title, completed <span class="hljs-keyword">FROM</span> sys_schedule <span class="hljs-keyword">WHERE</span> uid <span class="hljs-operator">=</span> p_uid;<br><span class="hljs-keyword">END</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>在DBeaver中调用这个存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; <span class="hljs-keyword">CALL</span> schedule_system.get_student_by_id(<span class="hljs-number">1</span>) &#125;<br></code></pre></td></tr></table></figure><p>得到下面的结果：</p><figure><img src="https://s21.ax1x.com/2025/05/19/pEvL4Cq.png" alt="第一张表" /><figcaption aria-hidden="true">第一张表</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/19/pEvLbb4.png" alt="第二张表" /><figcaption aria-hidden="true">第二张表</figcaption></figure><p>这是两张独立的表，也就是两个<strong>结果集</strong>。</p><p>我们要考虑的是如何用MyBatis完成对存储过程的调用，以及调用完成之后如何使用这两个结果集。这样做的目的是<strong>避免使用连接查询</strong>，改用“多个独立结果集”，来减少数据库的负担。</p><hr /><p>定义以下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">getUserByResultSet</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> Integer uid)</span>;<br></code></pre></td></tr></table></figure><p>数据库中已经有存储过程<code>get_student_by_id(IN p_uid INT)</code>，想要使用这个存储过程，映射语句如下；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--通过结果集查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByResultSet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--定义第一个结果集--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user_pwd&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_pwd&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--定义第二个结果集--&gt;</span><br>    <span class="hljs-comment">&lt;!--column 表示第一个结果集中的字段（通常是主表字段），</span><br><span class="hljs-comment">         foreignColumn 表示第二个结果集中的字段（通常是子表字段）。--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Schedule&quot;</span> <span class="hljs-attr">resultSet</span>=<span class="hljs-string">&quot;resultSet2&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">foreignColumn</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里必须和存储过程的第二个语句完全对应--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;completed&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;completed&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--getUserByResultSet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByResultSet&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectByResultSet&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;CALLABLE&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultSets</span>=<span class="hljs-string">&quot;resultSet1,resultSet2&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--#&#123;传入参数名, jdbcType=类型, mode=模式&#125;--&gt;</span><br>    &#123;CALL get_student_by_id(#&#123;uid, jdbcType=INTEGER, mode=IN&#125;)&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>几个注意点：</p><ul><li><code>association</code>的<code>column</code>表示<strong>主结果集</strong>（父结果集，也就是第一个结果集<code>sys_user</code>表）中的字段，<code>foreignColumn</code>表示<strong>关联结果集</strong>（子结果集，比如<code>sys_schedule</code>表）中的字段匹配。</li><li><code>resultSets</code>结果集的命名默认为<code>resultSet1, resultSet2, ...</code>，这里没有起别名，直接用默认的了</li></ul><p>然后测试输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: &#123;CALL get_student_by_id(?)&#125;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - &lt;==      Total: 1<br>TRACE [main] - &lt;==    Columns: uid, title, completed<br>TRACE [main] - &lt;==        Row: 1, 学习Java, 0<br>DEBUG [main] - &lt;==      Total: 1<br>DEBUG [main] - &lt;==    Updates: 0<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;, schedule=Schedule&#123;sid=null, uid=1, title=&#x27;学习Java&#x27;, completed=0&#125;&#125;<br></code></pre></td></tr></table></figure><p>因为这里没有查询<code>sid</code>，所以显示为null。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis配置过程和基本用法</title>
    <link href="/2025/05/14/MyBatis%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2025/05/14/MyBatis%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-mybatis">什么是 MyBatis</h1><p>MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来，映射成数据库内对应的纪录。<ahref="https://mybatis.org/mybatis-3/zh_CN/index.html">官方文档地址</a></p><p>MyBatis 属于 SSM框架的数据访问层，有了它就不必再写JDBC那种繁琐的操作数据库的代码，更简单易用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Controller（控制层）       &lt;<span class="hljs-comment">-- SpringMVC</span><br>   ↓<br>Service（业务逻辑层）       &lt;<span class="hljs-comment">-- Spring</span><br>   ↓<br>DAO / Mapper（数据访问层） &lt;<span class="hljs-comment">-- MyBatis</span><br>   ↓<br><span class="hljs-keyword">Database</span>（数据库）<br></code></pre></td></tr></table></figure><h1 id="配置-mybatis">配置 MyBatis</h1><ol type="1"><li>使用IDEA<strong>创建</strong>一个Maven工程，加入mybatis, junit,mysql-connector-j依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在resources目录下<strong>创建</strong><code>mybatis-config.xml</code>配置文件（参数改成自己的）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置实体类的别名，这样以后可以直接使用类名而不用再写全类名了 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kzn.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/schedule_system&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;************&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>在java目录下<strong>创建</strong>pojo包和mapper包，分别存放表对应的实体类和处理映射关系的接口。存在这样的对应关系：<code>表——实体类——mapper接口——映射文件</code>。</li></ol><p>然后创建映射文件。映射文件用于将我们创建的接口和sql语句建立联系。考虑到一个项目中会存在多个接口，因此在resources目录下创建mappers文件夹统一管理<code>.xml</code>文件：</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEj8Phj.png" alt="项目结构" /><figcaption aria-hidden="true">项目结构</figcaption></figure><ol start="4" type="1"><li><strong>MyBatis 面向接口编程的两个一致</strong><ol type="1"><li>映射文件的<code>namespace</code>和对应接口的<strong>全类名</strong>保持一致</li><li>映射文件中sql语句的id和mapper接口中定义的<strong>方法名</strong>一致</li></ol></li></ol><p>以上两点是如何体现的呢？先写<code>UserMapper.xml</code>配置（这里是sql的插入语句）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 命名空间是接口的全类名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kzn.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里就可以愉快地写 sql 语句啦--&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里使用动态sql --&gt;</span><br>        insert into sys_user (username, user_pwd)<br>        values (#&#123;username&#125;, #&#123;user_pwd&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是对应的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向表中插入新用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 新用户的实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对数据库影响的行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写配置文件时就遵循了这两个原则：</p><ul><li><code>namespace</code>改成对应接口的全类名：<code>com/kzn/mapper/UserMapper</code></li><li><code>mapper</code>标签内部写映射语句，并且映射语句的标签名就是要对数据库进行的操作(<code>insert</code>)；<code>id</code>属性要和接口中定义的方法名(此处为<code>insertUser</code>)保持一致。</li></ul><ol start="5" type="1"><li><strong>向核心配置文件中引入映射文件</strong></li></ol><p><code>mappers</code>标签在刚才复制粘贴的模板中已经存在，只需要修改内容即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>测试功能是否可以正常使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyBatis</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//加载核心配置文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-comment">// 获取SqlSessionFactoryBuilder （工厂模式）</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-comment">// 获取SqlSessionFactory</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(is);<br>        <span class="hljs-comment">// 获取SqlSession: Java程序和数据库之间的对话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory.openSession();<br>        <span class="hljs-comment">// 获取mapper接口的实现类的实例对象（底层采用代理模式）</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 然后利用接口的实现类对象，调用对应的方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Origami&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>));<br>        <span class="hljs-comment">// 提交事务</span><br>        sqlSession.commit();<br>        System.out.println(result);<br><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>factory.openSession();</code>可以传入<code>boolean</code>参数决定是否自动提交，<code>true</code>为开启自动提交，<code>false</code>为关闭自动提交。默认为<code>false</code>。</p><p>获取mapper接口的实现类的实例对象之前的代码对于每个测试都是相同的，不妨把它封装成一个测试类<code>MyBatisUtils.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;初始化SqlSessionFactory失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 SqlSession（可以自动提交或手动提交）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(autoCommit);<br>    &#125;<br>    <span class="hljs-comment">// 获取 SqlSession 默认手动提交</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getSqlSession(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了这样一个工具类以后，就可以在测试中直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession()) &#123;<br>    <span class="hljs-comment">// 通过 sqlSession 获取接口的实现类的实例对象</span><br><br>    <span class="hljs-comment">//调用接口中的方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志的配置">日志的配置</h2><p>Mybatis通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j（3.5.9起废弃）</li><li>JDK logging</li></ul><p>这里使用的是 Log4j2 。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.23.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>向<code>log4j2.xml</code>中加入语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://logging.apache.org/log4j/2.0/config&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%5level [%t] - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kzn.mapper.UserMapper&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;trace&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stdout&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>com.kzn.mapper.UserMapper</code>要换成自己接口的全类名。当然也可以将日志的记录方式从接口级别切换到语句级，只需将这一项改为对应方法的名称。<code>level</code>是日志级别，可以自己设置，日志的所有级别如下：</p><p>FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DUBUG</p><p>这时运行测试代码，得到的输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEBUG [main] - ==&gt;  Preparing: insert into sys_user (username, user_pwd) values (?, ?)<br>DEBUG [main] - ==&gt; Parameters: xQc(String), 123(String)<br>DEBUG [main] - &lt;==    Updates: 1<br>1<br></code></pre></td></tr></table></figure><h1 id="查询">查询</h1><h2 id="针对已知值的查询">针对已知值的查询</h2><p>目标：实现对<code>sys_user</code>表中的单个用户的查询和所有用户的查询。</p><p>如果查询的数据有多条，必须使用<code>List</code>接收。</p><h3 id="基于-xml-的方式">基于 XML 的方式</h3><h4 id="定义接口中的抽象方法">定义接口中的抽象方法</h4><p>向<code>UserMapper.java</code>接口中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询单个用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid 用户的唯一uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户类的实例</span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户，返回用户组成的列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">selectAllUsers</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>查询单个用户直接返回对应用户的<code>User</code>对象，查询所有用户就返回组成的列表。</p><h4 id="xml-映射文件">XML 映射文件</h4><p>在映射文件<code>UserMapper.xml</code>的<code>&lt;mapper&gt;</code>标签内部引入方法的映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User selectUserById(int uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kzn.pojo.User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--List&lt;User&gt; selectAllUsers();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kzn.pojo.User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个语句名为 selectUserById，接受一个 int（或Integer）类型的参数，并返回一个 User 类型的对象。注意参数符号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">&#123;<span class="hljs-built_in">id</span>&#125;</span><br></code></pre></td></tr></table></figure><p>这就告诉 MyBatis创建一个<strong>预处理语句</strong>（PreparedStatement）参数。这其实相当于JDBC中的预处理语句，当时我们是这样处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义sql语句，参数值用？替代</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from sys_user where uid=?&quot;</span>;<br><span class="hljs-comment">// 获取PreparedStatement 对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">// 设置参数值</span><br><span class="hljs-comment">// 第一个参数是编号，从 1 开始。第二个参数是赋值</span><br>preparedStatement.setInt(<span class="hljs-number">1</span>, uid);<br></code></pre></td></tr></table></figure><p><code>select</code>元素允许你配置很多属性来配置每条语句的行为细节。这里用到的属性有：</p><ul><li><code>id</code>: 在命名空间中唯一的标识符，一般写成方法名</li><li><code>parameterType</code>:将会传入这条语句的<strong>参数的类全限定名或别名</strong>。这个属性是<strong>可选</strong>的，因为MyBatis可以根据语句中实际传入的参数计算出应该使用的类型处理器（TypeHandler），默认值为未设置（unset）。</li><li><code>resultType</code>:期望从这条语句中<strong>返回结果的类全限定名或别名</strong>。注意，如果返回的是集合，那应该设置为<strong>集合包含的类型</strong>（这里为<code>com.kzn.pojo.User</code>），而不是集合本身的类型。<code>resultType</code>和<code>resultMap</code>之间只能同时使用一个。<ul><li>MyBatis中设置了默认的类型别名，例如<code>int</code>或<code>_int</code>都可正确地对应<code>Integer</code>。</li></ul></li></ul><h4 id="测试">测试</h4><p>得益于我们对<code>MyBatisUtils</code>工具类的封装，现在的测试代码会简洁很多：</p><p>对了，为了保证<code>userList.forEach(System.out::println);</code>能正确打印出用户所有字段的信息而不是具体的地址，在运行之前有必要重写<code>User</code>类的<code>toString()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAllUsers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession()) &#123;<br><br>        <span class="hljs-comment">// 获取mapper接口的实现类的实例对象（底层采用代理模式）</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br><br>        List&lt;User&gt; userList = mapper.selectAllUsers();<br>        userList.forEach(System.out::println);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user WHERE uid = ?<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - &lt;==      Total: 1<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;&#125;<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>TRACE [main] - &lt;==        Row: 2, lisi, 223322<br>TRACE [main] - &lt;==        Row: 3, CowBoy, 2233<br>TRACE [main] - &lt;==        Row: 4, ddd, 1234<br>TRACE [main] - &lt;==        Row: 5, Asuka, 456<br>TRACE [main] - &lt;==        Row: 8, Spike, 123455<br>TRACE [main] - &lt;==        Row: 11, Origami, 123456<br>TRACE [main] - &lt;==        Row: 14, xQc, 123<br>DEBUG [main] - &lt;==      Total: 8<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;&#125;<br>User&#123;uid=2, username=&#x27;lisi&#x27;, user_pwd=&#x27;223322&#x27;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;2233&#x27;&#125;<br>User&#123;uid=4, username=&#x27;ddd&#x27;, user_pwd=&#x27;1234&#x27;&#125;<br>User&#123;uid=5, username=&#x27;Asuka&#x27;, user_pwd=&#x27;456&#x27;&#125;<br>User&#123;uid=8, username=&#x27;Spike&#x27;, user_pwd=&#x27;123455&#x27;&#125;<br>User&#123;uid=11, username=&#x27;Origami&#x27;, user_pwd=&#x27;123456&#x27;&#125;<br>User&#123;uid=14, username=&#x27;xQc&#x27;, user_pwd=&#x27;123&#x27;&#125;<br></code></pre></td></tr></table></figure><p>看起来比较长，这是因为我启用了日志打印功能。</p><h3 id="基于注解的方式">基于注解的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;SELECT id, username, password FROM users WHERE id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT id, username, password FROM users&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAllUsers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现的功能和前面是一样的。</p><h1 id="特殊-sql">特殊 SQL</h1><h2 id="模糊匹配">模糊匹配</h2><p>上述查询操作中的所有操作符都是针对已知值进行过滤的，有时候并不好用，例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。MySQL中使用<code>LIKE</code>关键字表名接下来要执行模糊匹配，与之对应的通配符有：</p><ul><li>百分号<code>%</code>: 匹配多个字符（包括空字符和空格）</li><li>下划线<code>_</code>: 只匹配单个字符</li></ul><p>在 MyBatis 中写sql语句时，下面这种赋值方式不可取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%#&#123;username&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>因为这里的<code>#&#123;&#125;</code>被当成字符串处理了，无法引用传入的参数。如果把它换成<code>$&#123;&#125;</code>，虽然可以运行，但是不推荐，因为这时存在<strong>SQL注入</strong>的问题。例如当username=<code>"' or '1'='1"</code>时，sql语句实际上变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>where条件始终成立，这会导致整个表的数据都被返回。正确的做法是使用<code>#&#123;&#125;</code>配合文本处理函数<code>concat</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> concat(<span class="hljs-string">&#x27;%&#x27;</span>, #&#123;username&#125;)<br></code></pre></td></tr></table></figure><p>这也是最常用的方式。</p><h2 id="批量删除">批量删除</h2><p>考虑这样一个情景：用户在邮箱中一次性选中多个文件进行批量删除。用户按下删除按钮后，前端向后端发来被选中的序号构成的数组，后端根据这个数组执行数据库的删除操作。为此可以写出以下接口抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUsersByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;<br></code></pre></td></tr></table></figure><p>这里使用列表而不是数组储存数据，因为列表的话更具通用性。</p><p>重头戏是<code>.xml</code>配置文件。我使用的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUsersByIds&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    DELETE FROM sys_user<br>    WHERE uid IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关键在于<code>foraeach</code>标签。<code>&lt;foreach&gt;</code>用于生成<strong>动态SQL</strong>，比如构造<code>IN (...)</code>子句，以支持批量操作（插入、删除、更新等）。</p><ul><li><code>collection</code>:指定要遍历的集合名称，也就是传入的集合名<code>ids</code></li><li><code>item</code>:遍历集合中的每个变量时使用的临时变量的名字，类似于增强型 for 循环。</li><li><code>open="xxx"</code>:指定遍历开始前就输出的内容。因为我们要构造的是<code>IN(...)</code>字句，所以开始位置先放上一个左括号</li><li><code>separator="xxx"</code>: 每个元素之间的分隔符</li><li><code>close="xxx"</code>:遍历结束后输出的内容，这里放一个右括号。</li></ul><p>下面结合测试用例看一下效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteUsersByIds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除uid为2，4的记录</span><br>    userMapper.deleteUsersByIds(List.of(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br>    sqlSession.commit();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于执行<code>DELETE FROM sys_user WHERE uid IN(2, 4)</code>，打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: DELETE FROM sys_user WHERE uid IN ( ? , ? )<br>DEBUG [main] - ==&gt; Parameters: 2(Integer), 4(Integer)<br>DEBUG [main] - &lt;==    Updates: 2<br></code></pre></td></tr></table></figure><p>成功删除两条记录。</p><h1 id="mybatis-获取数据值的两种方式">MyBatis 获取数据值的两种方式</h1><h2 id="细节">细节</h2><p>使用<code>#&#123;&#125;</code>参数语法时，MyBatis会创建<code>PreparedStatement</code>参数占位符，并通过占位符安全地设置参数（就像使用<code>?</code>一样）。这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL语句中直接插入一个不转义的字符串，这时候可以使用<code>$&#123;&#125;</code>。</p><div class="note note-secondary">            <p><code>${}</code>的本质就是字符串的拼接<code>str1 + str2</code>，<code>#{}</code>的本质就是占位符赋值。</p>          </div><p><code>$&#123;&#125;</code>的使用情景主要是动态设置表名、列名、ORDER BY动态排序等，例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">ORDER</span> <span class="hljs-title">BY</span> $&#123;columnName&#125;<br></code></pre></td></tr></table></figure><p>举个例子，如果你想<code>select</code>一个表任意一列的数据时，可以直接写成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@Select</span>(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)<br><span class="hljs-keyword">User</span> findByColumn(<span class="hljs-variable">@Param</span>(&quot;column&quot;) String <span class="hljs-keyword">column</span>, <span class="hljs-variable">@Param</span>(&quot;value&quot;) String <span class="hljs-keyword">value</span>);<br></code></pre></td></tr></table></figure><p><code>$&#123;column&#125;</code>引用一个动态的字段名，比如<code>uid</code>，<code>user_pwd</code>。这样就不必为每个字段都单独写一个查询方法了，这也适用于替换表名的情况。</p><p>但是，凡是使用<code>$&#123;&#125;</code>出现的地方都有<strong>SQL注入</strong>的风险，如果要使用这种写法，因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p><hr /><p><code>#&#123;&#125;</code>用于给参数赋值，MyBatis<strong>默认只能识别单个参数</strong>。</p><p>多个参数时，MyBatis会把这些参数放到一个map中，在没有显式命名参数的情况下：</p><ul><li><code>$&#123;&#125;</code>，以<code>param1, param2...</code>为键，参数为值<br /></li><li><code>#&#123;&#125;</code>，以<code>arg0, arg1...</code>为键，参数为值</li></ul><p>此时最好在接口的方法中用<code>@Param</code>为参数<strong>显式命名</strong>，方便在sql语句中引用。这种情况下MyBatis创建的集合中实际上同时存在两种引用方式，默认和自定义都可使用，当然一般都是用自定义的名字。</p><p>对单参数和多参数各举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询单个用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid 用户的唯一uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户类的实例</span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查用户名和密码对应的人是否存在（仅作为测试，实际数据库中不可能存储明文密码）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">checkUserExists</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User selectUserById(int uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- boolean checkUserExists(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkUserExists&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;boolean&quot;</span>&gt;</span><br>    SELECT COUNT(*) &gt; 0 <span class="hljs-comment">&lt;!--用于检测满足后面的记录是否存在，存在的话就返回true--&gt;</span><br>    FROM sys_user<br>    WHERE username = #&#123;username&#125; AND user_pwd = #&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>selectUserById</code>只有一个参数，所以无需显式命名，直接在配置文件中用<code>#&#123;uid&#125;</code>表示（这里的名字可以随便起，不一定是uid）。但是第二个方法传入了两个参数，显式命名为<code>username</code>和<code>password</code>，这样在xml配置文件中就可以使用<code>#&#123;username&#125;</code>和<code>#&#123;password&#125;</code>引用传入的值了。</p><hr /><p>还有一种情况是传入的参数刚好是某个实体类的类型，如果要使用sql访问实体类的属性值，使用<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>都可。之前查询部分的代码就属于这种情况，不再赘述。</p><h2 id="总结">总结</h2><p><strong>获取数据值的两种方式：</strong></p><ul><li><code>$&#123;&#125;</code>: 字符串拼接，不安全，少用</li><li><code>#&#123;&#125;</code>: 占位符赋值，安全，优先使用。</li></ul><p><strong>接口方法中传入的参数也可以分成两大类：</strong></p><ul><li>如果传入的参数是某个实体类的类型，sql语句可以直接使用<code>#&#123;属性名&#125;</code>访问某个实体类的值，如<code>insert into sys_user (username, user_pwd) values (#&#123;username&#125;, #&#123;user_pwd&#125;)</code></li><li>如果传入了一个或多个参数，建议都使用<code>@Param</code>显式命名参数，之后sql语句就可以直接使用别名来引用参数的值</li></ul>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2025/05/10/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/05/10/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>主要参考：wiki 和 小林coding，以及<ahref="https://www.cnblogs.com/jojop/p/14111160.html">这篇博客</a></p><h1 id="tcp-报文头部格式">TCP 报文头部格式</h1><p>一个 TCP 报文（TCP segment） 是 TCP协议在网络中传输的基本单位。它有一个<strong>固定格式的头部</strong>（Header）和一个<strong>可变长度的数据部分</strong>（Payload）。</p><figure><img src="https://s21.ax1x.com/2025/05/10/pEODgrd.png"alt="TCP头部格式" /><figcaption aria-hidden="true">TCP头部格式</figcaption></figure><h2 id="源端口号和目标端口号">源端口号和目标端口号</h2><ul><li><code>Source Port</code>: 16位，源端口号，标识发送端口。</li><li><code>Destination Port</code>: 16位，标识接收端口</li></ul><h2 id="序列号">序列号</h2><ul><li><code>Sequence Number</code>：32位，序号（或者序列号），有双重作用：<ul><li>如果 SYN标志位为1，那么这就是初始序列号。实际的第一个数据字节的序列号以及相应ACK 中的确认号（acknowledged number，也叫ACK号）都等于此序列号加1。</li><li>如果 SYN 标志位为 0，那么这个序列号就是当前会话中的这个 segment中第一个数据的累计字节序号。这主要是因为在 TCP 连接已经建立之后，SYN就不再使用了（为 0）。</li></ul></li></ul><h2 id="数据偏移量">数据偏移量</h2><ul><li><code>Data Offset</code>(DOffset): 4位，数据偏移量，用指定 TCP头的size，以word（32-bit，即4字节）为单位。TCP 头的最小长度是 5words（因为固定部分的 TCP 报文头正好是 5 个 word），最大是 15words，因此最小是 20 字节，最大是 60 字节，报头最多可以容纳 40字节的选项（options）字段。这个字段之所以叫“offset”，是因为它也表示从TCP 段起始处 到 实际数据开始位置(Data) 的偏移量。</li></ul><h2 id="保留位">保留位</h2><ul><li><code>Reserved</code>(Rsrvd): 4 bits, 保留位，供未来使用，应当设置为0.在没有进一步的规范的情况下，发送方不应该设置这些位，接收方也应当忽略他们（就算被不慎设置了）。</li></ul><h2 id="状态位">状态位</h2><ul><li><code>Flags</code>: 8 bits, 8位状态位，包含以下 8 个标志位：<ul><li><code>CWR</code>(Congestion window reduced):<strong>拥塞窗口已减少</strong>标志，由<strong>发送方</strong>设置，以表明它收到了设置了ECE 标志的 TCP段，并且已经根据拥塞控制机制作出了响应。它的作用是：发送方告诉接收方“我知道网络拥塞了，我已经减小了发送窗口”。<strong>有的图解会把<code>CWR</code>归入保留位</strong>。</li><li><code>ECE</code>(ECN-Echo): 1 bit, ECN回显标志具有双重作用，其含义取决于 SYN 标志位：<ul><li>如果 SYN 标志位为1，表示该 TCP peer 支持 ECN 功能</li><li>如果 SYN 标志位为0，则在正常传输期间接收到了 IP标头中设置了拥塞经历标志（<code>ECN=11</code>）的数据包。这告诉 TCP发送方网络已经发生或即将发生拥塞。<strong>有的图解会把<code>ECE</code>归入保留位</strong>。</li></ul></li><li><code>URG</code>, 1 bit, 表示 “紧急指针（UrgentPointer）”字段是有效的。当 URG 标志位置为 1 时，说明当前这个 TCP报文中有“紧急数据”；此时，紧急指针字段告诉接收方：紧急数据在数据段中结束的位置。通常用于telnet 等老旧协议，<strong>现在很少用</strong>。</li><li><code>ACK</code>: 1 bit, 指示确认字段有效。<strong>客户端发送初始SYN数据包之后的所有数据包都应设置此标志</strong>。即，只有客户端请求连接的第一次握手时不用设置ACK标志位，毕竟在此之前客户端还没有收到过信息。</li><li><code>PSH</code>: 1 bit, 表示“推送功能（PushFunction）”，请求将缓冲数据立即推送到接收应用程序。</li><li><code>RST</code>: 1 bit, 重新连接。</li><li><code>SYN</code>: 1 bit,同步序列号。<strong>只有在前两次握手的过程应设置此标志</strong>。一些其他的标志位和字段根据SYN 改变含义，有的只有在SYN为1时有效，有的只有在SYN清空有效。</li><li><code>FIN</code>: 1 bit, 表示发送方的最后一个数据包，<strong>用于TCP 连接的正常关闭</strong>。当一个主机发送带有 FIN=1 的 TCP报文时，它表示主机请求断开连接，然后回进入终止连接的四次挥手进程。</li></ul></li></ul><h2 id="窗口">窗口</h2><ul><li>16位，接收窗口的大小，表示本报文段的<strong>发送方</strong>目前愿意接收的窗口大小单位数。（详见“流量控制”和“窗口缩放”部分）。</li></ul><h2 id="校验和">校验和</h2><p><code>Checksum</code>: 16 bits， 16 位校验和字段用于对 TCP报头、有效载荷(payload)和 IP伪报头(pseudo-header)进行错误校验。伪报头由源 IP 地址、目标 IP 地址、TCP协议号 (6) 以及 TCP报头和有效载荷的长度（以字节为单位）组成。具体见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Internet_checksum">[1]</span></a></sup></p><p>payload data:有效载荷数据，在计算机网络中，指传输的数据中除去协议头和校验码等控制信息之外的实际数据部分。</p><h2 id="紧急指针">紧急指针</h2><p><code>Urgent Pointer</code>: 16 bits, 如果设置了 URG 标志，则此 16位字段是相对于指示最后一个紧急数据字节的序列号的偏移量。<strong>现代协议几乎不使用URG和紧急指针</strong>。</p><h2 id="选项">选项</h2><p>选项（<code>TCP Option</code>）：长度可变，0–320 位（即 0–40字节），单位是 32 位（4 字节）； 其大小由 TCP 报文头的 Data Offset字段决定，计算公式是： <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Options</span> 字段大小 <span class="hljs-operator">=</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Data</span> <span class="hljs-built_in">Offset</span> <span class="hljs-operator">-</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span> × <span class="hljs-number">32</span> 位<br></code></pre></td></tr></table></figure></p><p>如果这个字段存在，数据偏移量将大于 5 words。因为 Data Offset表示的是以 word（32 位）为单位的 TCP头部长度，所以必须通过在末尾添加填充 0，将 TCP 头部长度填充为 4字节的整数倍。</p><h1 id="三次握手">三次握手</h1><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP连接的建立，通常称为<strong>三次握手</strong>。</p><p>先弄清楚几个概念：</p><ul><li><strong>序列号</strong>（SequenceNumber）：是<strong>发送方</strong>为数据流中的字节指定的“标记”，表示它正在发送哪些字节。它告诉接收方“<strong>我准备从这个序列号开始给你发数据</strong>”。</li><li><strong>确认号</strong>（AcknowledgmentNumber）：是<strong>接收方</strong>告诉发送方它已经成功接收到的字节的<strong>下一个序列号</strong>，表示接收方已经收到了所有小于该确认号的字节。它告诉发送方“<strong>接下来我准备接收从这个序列号开始的数据</strong>”。</li></ul><div class="note note-secondary">            <p>在客户端尝试连接服务器之前，服务器必须先绑定并监听某个端口，以便开放连接：这称为<strong>被动开启</strong>(passiveopen)。被动打开建立后，客户端可以通过三次握手(three-way/3-stephandshake)发起<strong>主动开启</strong>(active open)来建立连接。</p>          </div><p>三次握手的步骤如下：</p><ol type="1"><li><strong>SYN</strong>：客户端向服务器发送 SYN 报文（SYN标志位设置为1）主动开启连接。客户端把TCP段的序列号设置为一个随机数A。因为客户端还没有受到过消息，所以这里不用设置确认号，也不包含任何应用层的数据。</li><li><strong>SYN-ACK</strong>：作为回复，服务器响应了一个SYN-ACK报文。该TCP段的确认号被设置为A+1，而序列号被服务器设置为另一个随机数B。到这里客户端已经完成了一发一收，所以处于<code>ESTABLISHED</code>状态。</li><li><strong>ACK</strong>：最后，客户端把 ACK发送给服务器，这时的序列号设置为接收到的确认号，即A+1，而确认号被设置成接收到的序列号加一，即B+1。<strong>这次报文可以携带客户端到服务器的数据</strong>。至此服务器也完成了一发一收，也处于<code>ESTABLISHED</code>状态。</li></ol><p><img src="https://s21.ax1x.com/2025/05/11/pEOHxFf.png" /></p><p>步骤1和2从客户端到服务器的方向建立和确认序列号，步骤2和步骤3从服务器到客户端的方向建立和确认序列号。这些步骤完成之后，客户端和服务器都完成了确认，全双工通信正式建立。</p><p>可见，三次握手目的是保证双方都有发送和接收的能力。</p><h1 id="分割数据">分割数据</h1><p>TCP传输的数据归根结底还是来源于应用程序产生的HTTP请求消息。但是，TCP每个段能传输的数据长度是有最大限制的：</p><ul><li>MTU：一个网络包（IP头+TCP头+数据）的最大长度，以太网中一般为1500字节。</li><li>MSS：除去IP头和TCP头之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>如果数据的长度超过了<code>MSS</code>，则会将数据以<code>MSS</code>的长度为单位进行切分，每一块都会被放进单独的网络包中，加上TCP头部后交给IP模块发送出去。</p><hr /><p>在浏览器中输入网址并回车后，浏览器会向服务器发起 HTTP请求，这是一段纯文本数据，浏览器将这段数据交给操作系统的协议栈，操作系统通过上文讲述的TCP协议建立连接、发送。如果数据的长度超过了<code>MSS</code>，则会将数据以<code>MSS</code>的长度为单位进行切分，每一块都会被放进单独的网络包中，加上TCP头部后交给IP模块发送出去。远程服务器接收到TCP报文后，TCP协议层按照序列号重新组装数据，然后把完整的HTTP请求交给HTTP服务器程序，最后由服务器解析并做出响应，例如返回请求的网页内容。这就是在浏览器输入网址后发生的事情。</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://en.wikipedia.org/wiki/Internet_checksum<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-Java常用API</title>
    <link href="/2025/05/08/Java%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
    <url>/2025/05/08/Java%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h2 id="java-scanner">Java Scanner</h2><p><code>java.util.Scanner</code> 是 Java5 的新特征，我们可以通过Scanner 类来获取用户的输入。ACM 模式必备。</p><p><strong>注意</strong>：JUnit的测试方法（如<code>@Test</code>）默认不会连接控制台（<code>System.in</code>），一定要在<code>main()</code>方法中运行。</p><p>Scanner 类的UML 图如下：</p><p><img src="https://s21.ax1x.com/2025/05/07/pELmNqI.png" /></p><p>它实现了<code>AutoCloseable</code>接口，可以使用try-with-resources自动关闭资源。</p><p>创建一个 Scanner 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><p><strong>接收 String 类型输入</strong>：</p><ul><li><code>next()</code><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，<code>next()</code>方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><code>next()</code> 不能得到带有空格的字符串。</li></ul></li><li><code>nextLine()</code><ul><li>以Enter为结束符,也就是说<code>nextLine()</code>方法返回的是输入回车之前的所有字符。</li><li>可以获得空白</li></ul></li></ul><p><strong>接收<code>int</code>、<code>long</code>类型的输入</strong>，可以使用<code>nextInt()</code>、<code>nextLong()</code>等。但是有以下几点要注意的地方：</p><ol type="1"><li>这类方法不会消耗回车键产生的换行符，但是<code>nextLine()</code>会读取换行符，所以在二者混用的时候要注意：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemoTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        System.out.print(<span class="hljs-string">&quot;请输入一个数字：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> scan.nextInt();  <span class="hljs-comment">// 输入：123</span><br><br>        System.out.print(<span class="hljs-string">&quot;请输入一句话：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> scan.nextLine();  <span class="hljs-comment">// 问题出在这里</span><br><br>        System.out.println(<span class="hljs-string">&quot;你输入的数字是：&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;你输入的话是：&quot;</span> + line);<br><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">请输入一个数字：123<br>请输入一句话：你输入的数字是：123<br>你输入的话是：<br></code></pre></td></tr></table></figure><p>解释：输入<code>123</code>，按下回车键的时候，<code>123</code>赋值给了<code>num</code>，与此同时<code>line</code>接收到回车符，因此还没来得及输入一句话程序就结束了。</p><p>解决方法：在<code>int num = scan.nextInt();</code>后面紧跟一个<code>scan.nextLine()</code>，把回车吸收掉。</p><ol start="2" type="1"><li><code>nextInt()</code>等接收特定数据类型<strong>不能接收其他类型的数据</strong>，否则运行时会报异常<code>Exception in thread "main" java.util.InputMismatchException</code>，所以在接收数据之前最好使用<code>hasNextInt()</code>判断输入的数据是否符合要求。</li><li><code>nextInt</code>、<code>next()</code>等都可以把空格作为分隔符，这样方便我们在一行内输入一个数组，比如对于下面这种输入格式</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>1 4 5 -1<br>1 3 4 -1<br>2 6 -1<br></code></pre></td></tr></table></figure><p>利用<code>nextInt()</code>和适当的条件判断就能搞定。</p><h2 id="测试类的命名">测试类的命名</h2><p>使用单元测试JUnit时，如果测试类的命名不规范，那么IDEA会报警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Test class name &#x27;methodTest&#x27; doesn&#x27;t match regex &#x27;[A-Z][A-Za-z\d]*Test(s|Case)?|Test[A-Z][A-Za-z\d]*|IT(.*)|(.*)IT(Case)?&#x27;<br></code></pre></td></tr></table></figure><p>某些测试框架（如 Maven Surefire、JUnit、IDE插件）会用正则表达式来自动识别哪些类是“测试类”。</p><p>上面这个正则表达式规定了测试类必须符合以下格式之一：</p><ul><li>以大写字母开头，并以 Test、Tests 或 TestCase 结尾，如：<ul><li>LoginTest</li><li>CalculatorTests</li><li>NetworkTestCase</li></ul></li><li>或者 以 Test 开头，如：<ul><li>TestLogin</li><li>TestConnectionManager</li></ul></li><li>或者包含 IT（通常代表集成测试）：<ul><li>UserServiceIT</li><li>ITLoginFlow</li></ul></li></ul><h2 id="实用方法">实用方法</h2><h3 id="split">split</h3><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] split(String regex) &#123;<br>    <span class="hljs-keyword">return</span> split(regex, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：根据给定的正则表达式分割字符串。</p><ul><li><code>参数</code>：定界正则表达式</li><li><code>返回值</code>：根据给定的正则表达式分割得到的<code>String[]</code>数组</li></ul><p>举例：输入 IP地址和子网掩码，输出网络地址和主机地址。第一步从给定的字符串中提取数字的过程可以用<code>split</code>完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] parse(String str) &#123;<br>    String[] newStr = str.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        result[i] = Integer.parseInt(newStr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以下单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.1.10&quot;</span>;<br>    <span class="hljs-type">int</span>[] result = parse(s);<br>    System.out.println(Arrays.toString(result));<br>    <span class="hljs-comment">// [192, 168, 1, 10]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可见原字符串中的小数点已经被成功去掉，四个数字被转换成整型变量保存在了数组中。</p><p>小数点属于正则表达式中的特殊字符，<code>.</code>用于匹配任意一个字符，想匹配它本身必须在前面加上<code>\\</code>。所以必须用<code>"\\."</code>来表示匹配小数点。类似的特殊字符还有：</p><table><thead><tr><th>字符</th><th>含义</th><th>匹配自身需写作</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除换行）</td><td><code>\\.</code></td></tr><tr><td><code>*</code></td><td>匹配前面的内容零次或多次</td><td><code>\\*</code></td></tr><tr><td><code>+</code></td><td>匹配前面的内容一次或多次</td><td><code>\\+</code></td></tr><tr><td><code>?</code></td><td>匹配前面的内容零次或一次</td><td><code>\\?</code></td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td><td><code>\\^</code></td></tr><tr><td><code>$</code></td><td>匹配字符串的结尾</td><td><code>\\$</code></td></tr><tr><td><code>[</code></td><td>开始一个字符类</td><td><code>\\[</code></td></tr><tr><td><code>]</code></td><td>结束一个字符类</td><td><code>\\]</code></td></tr><tr><td><code>&#123;</code></td><td>指定匹配次数（如 <code>&#123;3&#125;</code>）</td><td><code>\\&#123;</code></td></tr><tr><td><code>&#125;</code></td><td>结束指定次数</td><td><code>\\&#125;</code></td></tr><tr><td><code>(</code></td><td>开始一个分组</td><td><code>\\(</code></td></tr><tr><td><code>)</code></td><td>结束一个分组</td><td><code>\\)</code></td></tr><tr><td><code>\|</code></td><td>逻辑“或”</td><td><code>\\\|</code></td></tr><tr><td><code>\\</code></td><td>转义符本身</td><td><code>\\\\</code></td></tr></tbody></table><h3 id="replaceall">replaceAll</h3><p>使用场景：<ahref="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></p><p>序列化，使用<code>StringBuilder</code>得到结果之后，需要删除尾部多余的<code>null</code>，这时可以使用<code>replaceAll</code></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> originalString.replaceAll(String regex, String replacement);<br></code></pre></td></tr></table></figure><ul><li><code>regex</code>：要匹配的正则表达式（pattern）</li><li>`replacement：用于替换的字符串</li></ul><p>在这道算法中的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sb.toString();<br><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> res.replaceAll(<span class="hljs-string">&quot;(null,)+$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">if</span>(result.endsWith(<span class="hljs-string">&quot;,&quot;</span>))<br>    result = result.substring(<span class="hljs-number">0</span>, result.length()-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> result+<span class="hljs-string">&quot;]&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>正则表达式<code>"(null,)+$"</code><ul><li><code>(null,)+</code>：匹配一个或多个<code>"null,"</code>。<code>+</code>是定位符，表示一个或多个匹配。</li><li><code>$</code>表示从文本的末尾位置开始匹配。</li></ul></li></ul><p>所以该正则的含义就是字符串末尾的连续多个<code>null,</code>。</p><h2 id="substring">substring</h2><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;...&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>        <span class="hljs-keyword">return</span> substring(beginIndex, length());<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><code>beginIndex</code>：起始索引，包含</li><li><code>endIndex</code>：结束索引，不包含。如果没有该参数，则从起始索引开始截取到末尾（本质上还是调用的第一个方法）</li><li>返回值：指定的子字符串</li></ul><h2 id="栈应该用哪个实现类">栈应该用哪个实现类？</h2><h3 id="先说结论">先说结论</h3><p><code>Stack.java</code>的文档注释中是这样解释的：</p><div class="note note-secondary">            <p>Stack 类表示一个后进先出 (LIFO) 的对象堆栈。它扩展了 Vector类，增加了五个操作，允许将向量视为堆栈。它提供了常见的 push 和 pop操作，以及一个用于查看堆栈顶部元素的方法、一个用于测试堆栈是否为空的方法，以及一个用于在堆栈中搜索元素并确定其距离顶部距离的方法。</p><p>堆栈首次创建时不包含任何元素。</p><p><strong>Deque 接口及其实现提供了一套更完整、更一致的 LIFO堆栈操作，应优先使用此类</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure>          </div><p><code>Deque</code>右两个常用实现类：<code>LinkedList</code>和<code>ArrayDeque</code>。</p><p>在<code>ArrayDeque.java</code>的开头文档注释：</p><div class="note note-secondary">            <p>Deque接口的动态数组实现。数组双端队列没有容量限制；它们会根据需要扩容以支持使用。它们不是线程安全的；在没有外部同步的情况下，它们不支持多线程并发访问。禁止使用Null 元素。<strong>此类用作堆栈时可能比 Stack 更快，用作队列时可能比LinkedList 更快</strong>。</p>          </div><p>所以应该使用<code>ArrayDeque</code>模拟栈和队列。</p><h3 id="为什么不使用stack">为什么不使用Stack</h3><p>Stack 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vector</span>&lt;E&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>Stack</code>继承了<code>Vector</code>。<code>Vector</code>是一个线程安全的动态数组，但它使用的是同步方法（<code>synchronized</code>），这在单线程环境下反而造成了不必要的性能开销。查看<code>Vector</code>的源码会发现几乎每一个方法被都加上了<code>synchronized</code>修饰，比如添加和删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(E obj)</span> &#123;<br>    modCount++;<br>    add(obj, elementData, elementCount);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(Object obj)</span> &#123;<br>  modCount++;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(obj);<br>  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>      removeElementAt(i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是非常粗暴且不合理的。</p><p><code>Stack</code>作为它的子类也强制使用同步机制，就算是没有线程安全问题也是如此，这样会明显降低性能。</p><h3 id="为什么arraydeque更优">为什么ArrayDeque更优</h3><p><code>ArrayDeque</code>是一个基于<strong>循环数组</strong>实现的双端队列，访问速度非常快。而<code>LinkedList</code>是链表，每次访问的时候都必须从头节点开始往下找，明显慢得多。另一方面，<code>ArrayDeque</code>会自动扩容，而链表的扩容需要频繁创建新的节点对象，垃圾回收负担大。</p><h2 id="treeset和treemap">TreeSet和TreeMap</h2><p>二叉搜索树是否平衡对二叉搜索树的时间效率至关重要。Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构。</p><p>TreeSet实现了接口Set，它内部的平衡二叉树中的每个节点只包含一个值，根据这个值的查找、添加和删除操作的时间复杂度都是<spanclass="math inline">\(O(\log{n})\)</span>。除了Set接口定义的方法以外，常用方法如下：</p><table><thead><tr><th>序号</th><th>函数</th><th>函数功能</th></tr></thead><tbody><tr><td>1</td><td>ceiling</td><td>返回键大于或等于给定值的最小键；如果没有则返回 null</td></tr><tr><td>2</td><td>floor</td><td>返回键小于或等于给定值的最大键；如果没有则返回 null</td></tr><tr><td>3</td><td>higher</td><td>返回键大于给定值的最小键；如果没有则返回 null</td></tr><tr><td>4</td><td>lower</td><td>返回键小于给定值的最大键；如果没有则返回 null</td></tr></tbody></table><p>TreeMap 实现了接口Map。和TreeSet不一样，TreeMap内部的平衡二叉搜索树中的每个节点都是一个包含键值和值的映射。可以根据键值实现时间复杂度为<spanclass="math inline">\(O(\log{n})\)</span>的查找、添加和删除操作。除了Map接口定义的方法以外，常用的方法如下：</p><table><thead><tr><th>序号</th><th>函数</th><th>函数功能</th></tr></thead><tbody><tr><td>1</td><td>ceilingEntry / ceilingKey</td><td>返回键大于或等于给定值的最小映射 / 键；如果没有则返回 null</td></tr><tr><td>2</td><td>floorEntry / floorKey</td><td>返回键小于或等于给定值的最大映射 / 键；如果没有则返回 null</td></tr><tr><td>3</td><td>higherEntry / higherKey</td><td>返回键大于给定值的最小映射 / 键；如果没有则返回 null</td></tr><tr><td>4</td><td>lowerEntry / lowerKey</td><td>返回键小于给定值的最大映射 / 键；如果没有则返回 null</td></tr></tbody></table><p>哈希表的增删改的时间复杂度都是<spanclass="math inline">\(O(1)\)</span>，但是缺点是只能根据键来判断键是否存在以及获取键对应的值。如果需要根据数值的大小查找，如查找数据集合中比某个值大的所有数字中的最小的一个，哈希表就无能为力。</p><p>如果在一个已经排序的动态数组中根据数值的大小进行查找，二分查找也可以实现<spanclass="math inline">\(O(\log{n})\)</span>，但是排序的动态数组的添加和删除操作的时间复杂度都是<spanclass="math inline">\(O(n)\)</span>，不如<code>TreeSet</code>和<code>TreeMap</code>。</p><h2 id="copyof和copyofrange">copyOf和copyOfRange</h2><p>copyOf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-type">int</span> newLength)<br></code></pre></td></tr></table></figure><ul><li><code>original</code>：原始数组</li><li><code>newLength</code>：复制后新的数组的长度，从0开始复制。如果newLength 大于原始数组长度，多出来的部分用默认值填充。</li></ul><p>copyOfRange</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)<br></code></pre></td></tr></table></figure><ul><li><code>original</code>: 原始数组</li><li><code>from</code>: 起点（包含）</li><li><code>to</code>：终点（不包含）</li></ul><p>新数组的长度 = to -from。如果<code>to</code>大于数组的长度，多出来的部分用默认值填充。</p><h2 id="random">Random</h2><p>创建随机数对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br></code></pre></td></tr></table></figure><p>调用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> random.nextInt(bound);<br></code></pre></td></tr></table></figure></p><ul><li>生成一个范围在<code>[0, bound)</code>范围内的整数</li></ul><p>出现位置：<ahref="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">O(1)时间插入、删除和获取随机元素</a></p><h2id="如何将列表转换成特定类型的数组">如何将列表转换成特定类型的数组</h2><h3 id="引入">引入</h3><p>先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ListNode&gt; TempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>...<br>ListNode[] lists = TempList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><code>lists</code>是一个用于存放<code>ListNode</code>数据的数组，<code>Templist</code>是一个存放<code>ListNode</code>元素的列表。最后一行代码实现了从<code>TempList</code>列表向数组的转化。这里的关键是<code>toArray</code>方法，实际上<code>List</code>接口中定义了两个<code>toArray</code>抽象方法，一个空参一个有参，定义分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray();<br>&lt;T&gt; T[] toArray(T[] a);<br></code></pre></td></tr></table></figure><p>为了搞清楚这两个方法如何使用，需要先介绍一下<code>runtime type</code>（运行时类型）和<code>compile type</code>（编译时类型）。</p><h3 id="编译时类型和运行时类型">编译时类型和运行时类型</h3><p>运行时类型，指的是对象在程序运行的过程中真实的类型。之所以强调“真实”，是因为Java中的多态使得编译器认为的类型和程序运行时的类型可能不一样，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><p>所谓<em>编译看左边，运行看右边</em>，<code>a</code>的编译时类型是<code>Animal</code>，运行时类型是<code>Dog</code>。</p><h3 id="java标准库提供的注释">Java标准库提供的注释</h3><p>先看空参方法<code>Object[] toArray();</code>：</p><blockquote><p>按照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。</p><p>返回的数组是“安全的”，意思就是说它不包含任何对原列表的引用，是完全独立于原列表的。你可以放心地修改它，不用担心会对原列表产生任何影响。</p><p>这个方法是基于数组的 API 和基于集合的 API 之间的桥梁。</p></blockquote><p><code>返回值</code>:一个以正确的顺序包含列表中的所有元素的<code>Object</code>数组</p><p>这个方法的返回值类型固定为<code>Object[]</code>，在实际应用中需要手动强转成我们需要的类型，很不方便。于是就有了后面这个带参数的方法</p><hr /><p><code>&lt;T&gt; T[] toArray(T[] a);</code></p><blockquote><p>照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。返回数组的运行时类型与指定数组相同。如果该列表可以装入指定的数组中，则直接把它放进数组并返回；否则，会分配一个具有与指定数组相同运行时类型的新数组，其大小等于列表的大小。</p><p>如果指定的数组比原列表需要的空间还大，那么空缺位置会被赋值为<code>null</code>。（<em>仅当</em>调用者确认原列表中不包含任何<code>null</code>元素时，这个特性才有助于判断列表的长度）</p><p>就像<code>toArray()</code>方法一样，该方法是基于数组的 API和基于集合的 API之间的桥梁。此外，该方法允许对输出数组的运行时类型进行精确的控制，在某些情况下或许可以节省内存开销。</p><p>假设<code>x</code>是一个已知只包含字符串的列表。以下代码可以用于将列表转存到新分配的String数组中：</p><p><code>String[] y = x.toArray(new String[0]);</code></p><p>注意<code>toArray(new Object[0])</code>与上面的<code>toArray()</code>完全相同。</p></blockquote><p><code>参数</code>: <code>a</code>-指定数组，如果足够大，原列表的元素将被直接存入该数组；否则，会分配一个与之相同运行类型的新数组。</p><p><code>返回值</code>: 一个包含列表元素的数组</p><p><code>抛出</code>: <code>ArrayStoreException</code> -如果指定数组的运行时类型不是每一个列表元素的父类型<br /><code>NullPointerException</code> - 如果指定数组是<code>null</code></p><hr /><p>Java标准库中给出的解释已经非常详细了。对于开头处的语句<code>ListNode[] lists = TempList.toArray(new ListNode[0]);</code>，形参<code>new ListNode[0]</code>的主要作用是<strong>确定返回数组的运行时类型</strong>，它作为我们给出的指定数组，其容量为0，显然是不够用的，所以会分配一个运行时类型为<code>ListNode[]</code>的新数组，其容量等于列表的大小。然后，把返回的数组赋给相同类型的数组<code>lists</code>就没有任何问题了。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基本使用</title>
    <link href="/2025/05/06/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/05/06/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库常识">数据库常识</h1><h2 id="数据库的关系模型">数据库的关系模型</h2><p>什么是关系数据库？</p><blockquote><p>关系数据库是一种用于存储相互关联的数据点并提供数据点访问的数据库。它采用关系模型，直接、直观地在表中展示数据。</p><p>在关系数据库中，表中的每一行都代表一条<strong>记录</strong>，每条记录都具有一个唯一的ID（又被称为<strong>键</strong>），而表中的列则用于存储数据的<strong>属性</strong>——每条记录的每一个属性通常都有一个值。籍此，用户可以轻松在数据点之间建立关联。</p><p>数据库的关系模型（Relational Model）是当前最广泛使用的数据模型，它由IBM 的 E.F. Codd 在 1970年提出。该模型使用<strong>二维表格</strong>来组织数据，具有强大的理论基础和良好的实用性。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.oracle.com/cn/database/what-is-a-relational-database/">[1]</span></a></sup></p></blockquote><p>举个例子：这是用来描述学生信息的关系表：</p><table><thead><tr><th>student_id (PK)</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1001</td><td>Alice</td><td>20</td></tr><tr><td>1002</td><td>Bob</td><td>21</td></tr><tr><td>1003</td><td>Charlie</td><td>19</td></tr></tbody></table><ul><li><code>student_id</code>是学生的<strong>键</strong></li></ul><p>这是可选课程表：</p><table><thead><tr><th>course_id (PK)</th><th>course_name</th><th>credits</th></tr></thead><tbody><tr><td>C001</td><td>Database Systems</td><td>3</td></tr><tr><td>C002</td><td>Operating Systems</td><td>4</td></tr><tr><td>C003</td><td>Networks</td><td>3</td></tr></tbody></table><ul><li><code>course-id</code>是课程的<strong>键</strong></li></ul><p>现在这些学生们需要选课，于是就有了选课表：</p><table><thead><tr><th>student_id (FK)</th><th>course_id (FK)</th><th>grade</th></tr></thead><tbody><tr><td>1001</td><td>C001</td><td>A</td></tr><tr><td>1001</td><td>C002</td><td>B</td></tr><tr><td>1002</td><td>C001</td><td>A-</td></tr><tr><td>1003</td><td>C003</td><td>B+</td></tr></tbody></table><p>通过上表，借由学生id就可以查询到课程id进而查询课程信息，又可以查询到学生信息，这样就建立起了不同关系表之间的映射关系。</p><h2 id="数据类型">数据类型</h2><p>关系数据库支持的数据类型主要包括数值、字符串、日期和时间、布尔、二进制。</p><blockquote><p>通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p></blockquote><h2 id="sql">SQL</h2><p>SQL（Structured QueryLanguage），即结构化查询语言，是一种用于<strong>管理关系型数据库</strong>的标准编程语言。不同的数据库都支持SQL，所以使用SQL这一种标准语言就可以操作不同的数据库。</p><p>除了 SQL 标准之外，大部分 SQL数据库程序都拥有它们自己的私有扩展，这些扩展不能用在其他的数据库中。但是如果只使用SQL的核心功能的话，那不会有太大问题，常用的功能是相互兼容的。</p><p>SQL 定义了以下五种语句：</p><table><thead><tr><th>类别</th><th>关键作用</th><th>常见关键字</th></tr></thead><tbody><tr><td>DDL</td><td>定义结构，通常由管理员执行</td><td><code>CREATE</code>, <code>DROP</code>, <code>ALTER</code></td></tr><tr><td>DML</td><td>操作数据，属于应用程序的日常操作</td><td><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></td></tr><tr><td>DQL</td><td>查询数据，供用户查询使用，最为频繁</td><td><code>SELECT</code></td></tr><tr><td>DCL</td><td>控制权限</td><td><code>GRANT</code>, <code>REVOKE</code></td></tr><tr><td>TCL</td><td>管理事务</td><td><code>COMMIT</code>, <code>ROLLBACK</code></td></tr></tbody></table><p><img src="https://s21.ax1x.com/2025/05/03/pEbWCOe.png" /></p><p>SQL的关键字不区分大小写，但是对于表名和列名，不同数据库的规定不同，所以最好关键词一律大写。表名和列名一律小写。</p><h1 id="关系模型构成">关系模型构成</h1><p>用于唯一区分不同记录的字段就是主键。不能使用业务相关的字段作为主键。</p><p>将数据与另一张表联系起来的字段称为外键。</p><p>索引：加快查询速度。</p><blockquote><p>在关系数据库中，索引是用于提高查询效率的重要数据结构。索引可以让数据库在查询时不必遍历整个表，而是快速定位到符合条件的记录，从而显著提升检索速度。</p><p>然而，索引也有其局限性。索引的主要缺点是在执行插入、更新和删除操作时，数据库需要同时调整所有相关的索引，这会增加系统开销。索引数量越多，数据修改的速度就越慢。因此，在设计数据库时，必须在查询优化和修改性能之间权衡。</p></blockquote><p>数据库会自动为主键创建索引，<strong>主键索引的查询效率最高</strong>，因为主键保证每条记录的唯一性。</p><p>唯一索引：可以通过命令为需要确保唯一的数据创建唯一索引，或者添加唯一约束。</p><h1 id="基本的查询操作">基本的查询操作</h1><h2 id="基本查询">基本查询</h2><p><code>SELECT &lt;定义列的名字&gt; FROM &lt;表名&gt;</code></p><p>例如：<code>SELECT * FROM students;</code>查询<code>students</code>表中的所有列</p><h2 id="条件查询">条件查询</h2><p><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code></p><p>使用<code>WHERE</code>指定搜索条件。条件表达式可以用</p><ul><li><code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2</li><li><code>&lt;条件1&gt; OR &lt;条件2&gt;</code>表示满足条件1或者满足条件2。</li></ul><p>应当注意，<code>AND</code>比<code>OR</code>有更高的运算优先级，某些情况下需要使用圆括号<code>()</code>指明运算先后顺序。</p><p><code>BETWEENT AND</code>：查询位于两个值之间的数据，两边都是闭区间。</p><p><code>IN</code>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_id, cust_name<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">10001</span>, <span class="hljs-number">10003</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></td></tr></table></figure><p>把 customers 表中的<code>cust_id</code>为 10001 <strong>或</strong>10003的数据查询出来。<code>IN</code>的作用实际上和<code>OR</code>没有差别，它的优点体现在：</p><ul><li>IN操作符的语法更清楚且更直观；</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）；</li><li>IN操作符一般比OR操作符清单执行更快；</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li></ul><p>还有一个关键字是<code>NOT</code>。WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>)<br></code></pre></td></tr></table></figure><p>筛选所有 vend_id 不是1002或1003的数据。NOT实际上是MySQL的特性：</p><div class="note note-primary">            <p>MySQL支持使用NOT对IN、BETWEEN和EXISTS<strong>子句</strong>取反，这与多数其他DBMS允许使用NOT对各条件取反有很大的差别。</p>          </div><h2 id="排序">排序</h2><p><code>SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</code></p><p><code>DESC</code>表示倒序，默认为<code>ASC</code>即升序。</p><p><code>ORDER BY</code>要放到<code>WHERE</code>的后面。</p><h2 id="分页查询">分页查询</h2><p>在 SQL中，分页查询用于从大型数据集中按页提取一部分数据，以便在应用程序或网页上逐步显示。</p><p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询第1页:</span><br><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>上面的语句表示：选取<code>students</code>中 id, name, gender,score的列，按照分数从高到低排序，<strong>最多只取</strong>前3条（第1页的3条记录，从第0条开始）。</p><p>所以<code>LIMIT</code>语句其实是一个<strong>截取</strong>的过程，输出的结果在外界看来好像实现了分页效果。</p><ul><li>LIMIT总是设定为pageSize；</li><li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li></ul><p>如果查询结果为空，则会返回<code>Empty set</code>。<code>OFFSET</code>是可选的，默认为0。</p><h2 id="聚合查询">聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数（也叫数据处理函数），使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><h3 id="文本处理函数">文本处理函数</h3><ul><li><code>Trim()</code>:去除文本两端的空格，也有<code>RTrim()</code>去除右边的空格，<code>LTrim()</code>去除左边的空格。</li><li><code>Upper()</code>: 将文本转换为大写。</li><li><code>Left()</code>: 返回串最左边的字符</li><li><code>Length()</code>: 返回串的长度</li><li><code>Locate()</code>: 找出串的第一个字串</li><li><code>Lower()</code>: 将串转换为小写</li><li><code>Ltrim()</code>: 去掉串左边的空格</li><li><code>Right()</code>: 返回串右边的字符</li><li><code>Soundex()</code>: 返回串的SOUNDEX值</li><li><code>SubString()</code>: 返回串的字符</li></ul><h3 id="数据处理函数">数据处理函数</h3><p>MySQL 给出了5个以<code>row</code>为单元运行的聚集函数，如下表：</p><table><thead><tr><th>聚合函数</th><th>说明</th></tr></thead><tbody><tr><td><code>COUNT()</code></td><td>返回指定列的行数</td></tr><tr><td><code>SUM()</code></td><td>返回指定列值之和</td></tr><tr><td><code>AVG()</code></td><td>返回特定数值列的平均值</td></tr><tr><td><code>MAX()</code></td><td>返回指定列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回指定列的最小值</td></tr></tbody></table><blockquote><p>COUNT 有两种使用方式： - 使用 COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值 - 使用COUNT(列名) 对特定列中具有值的行进行计数，忽略 NULL 值。</p></blockquote><p>经常与之结合使用的还有:</p><ul><li><code>CEILING()</code>: 向上取整</li><li><code>FLOOR()</code>: 向下取整</li></ul><p>例如<code>SELECT MAX(score), MIN(score) FROM students;</code>用于计算学生的最高分和最低分。</p><p>使用聚合查询时可以给结果起一个别名，使用<code>AS</code>标记：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num <span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">+-----+<br>| num |<br>+-----+<br>|  10 |<br>+-----+<br>1 row in set (0.024 sec)<br></code></pre></td></tr></table></figure><p>聚合查询语句同样可以和条件语句等一起使用。</p><blockquote><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL：</p></blockquote><p>如果在列名的前面加上<code>DISTINCT</code>关键字，那么只会计算不同的数据，相同的数据不会被重复计算。</p><ul><li><code>SELECT COUNT(DISTINCT department_id) FROM employees;</code>统计有多少个不同的<code>department_id</code>。</li></ul><p>但是<code>COUNT(DISTINCT *)</code>是非法的，因为<code>COUNT(*)</code>的计算结果固定为总行数。</p><h1 id="分组">分组</h1><h2 id="group-by">GROUP BY</h2><p>关键词：<code>GROUP BY</code>。分组操作常常需要把分组标准也加入表中，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 第一列是性别，第二列是对应的数量，起一个新名字total</span><br><span class="hljs-keyword">SELECT</span> gender, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> gender;<br></code></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">+--------+-------+<br>| gender | total |<br>+--------+-------+<br>| M      |     5 |<br>| F      |     5 |<br>+--------+-------+<br>2 rows in set (0.013 sec)<br></code></pre></td></tr></table></figure><p>GROUP BY 子句指示 MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</p><p><strong>注意</strong>：</p><ul><li>除聚集计算语句外，SELECT 语句中的每个列都必须在 GROUP BY子句中给出。</li><li>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</li><li>在GROUPBY后面紧接<code>WITH ROLLUP</code>关键字可以在最后一行加上合计。</li></ul><h2 id="having">HAVING</h2><p>HAVING关键字的作用是<strong>对分好的组进行过滤</strong>。之前我们使用 WHERE对表中的行进行过滤，但是WHERE不能用于分组的情况，这时应该使用HAVING。他们的唯一区别是<strong>WHERE过滤行，HAVING过滤组</strong>。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> vend_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> products <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> vend_id <span class="hljs-keyword">with</span> <span class="hljs-keyword">rollup</span> <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>将<code>products</code>表中按照 vend_id分组后，只保留行数大于等于3的组别。</p><h2 id="select-子句顺序">SELECT 子句顺序</h2><ol type="1"><li>SELECT</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li><li>LIMIT</li></ol><h1 id="多表查询联结表">多表查询（联结表）</h1><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT 能执行的最重要的操作，很好地理解联结及其语法是学习 SQL的一个极为重要的组成部分。</p><p>关键是，一个表中的相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。<strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表</strong>。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p><p>现在我们手上有两个表格：<strong>班级表</strong></p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>class1</td></tr><tr><td>2</td><td>class2</td></tr><tr><td>3</td><td>class3</td></tr><tr><td>4</td><td>class4</td></tr></tbody></table><p>和<strong>学生表</strong></p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>ming</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>hong</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>jun</td><td>M</td><td>88</td></tr><tr><td>4</td><td>1</td><td>mi</td><td>F</td><td>73</td></tr><tr><td>5</td><td>2</td><td>bai</td><td>F</td><td>81</td></tr><tr><td>6</td><td>2</td><td>bing</td><td>M</td><td>55</td></tr><tr><td>7</td><td>2</td><td>ling</td><td>M</td><td>85</td></tr><tr><td>8</td><td>3</td><td>xin</td><td>F</td><td>91</td></tr><tr><td>9</td><td>3</td><td>wang</td><td>M</td><td>89</td></tr><tr><td>10</td><td>3</td><td>li</td><td>F</td><td>85</td></tr></tbody></table><p>这里的外键是<code>class_id</code>，它包含了班级表的主键值</p><p>连接是一种机制，用来在一条SELECT语句中关联表，因此称之为连接(JOIN)。采用连接的查询称之为<strong>SQLJOIN连接查询</strong>。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/68136613">[2]</span></a></sup></p><figure><img src="https://s21.ax1x.com/2025/05/04/pEbjEAP.png"alt="联结的分类" /><figcaption aria-hidden="true">联结的分类</figcaption></figure><h2 id="等值联结">等值联结</h2><p>等值联结基于两个表之间的相等数据进行连接。应当确保所有的联结都有WHERE 子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> classes.name, students.name <span class="hljs-keyword">from</span> classes, students <span class="hljs-keyword">where</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://s21.ax1x.com/2025/05/17/pEvKwWt.png" /></p><h2 id="inner-join-内连接">INNER JOIN 内连接</h2><p>对上述sql语句使用不同的语法，也可以实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> classes.name, students.name <span class="hljs-keyword">from</span> classes <span class="hljs-keyword">join</span> students <span class="hljs-keyword">on</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNERJOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p><div class="note note-secondary">            <p>ANSI SQL规范首选INNERJOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>          </div><hr /><p>下面正式给出内连接的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.id, A.name, B.name<br><span class="hljs-keyword">FROM</span> classes A<br><span class="hljs-keyword">JOIN</span> students B<br><span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.class_id;<br></code></pre></td></tr></table></figure><p>当然，内连接也适用于只有一个表的情况。假如已知students表中一个学生的名字为bai，现在要查询和他在同一班级中的其他所有学生的信息，可以使用以下sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> p1.class_id, p1.name<br><span class="hljs-keyword">from</span> students <span class="hljs-keyword">as</span> p1 <span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> p2<br><span class="hljs-keyword">on</span> p1.class_id <span class="hljs-operator">=</span> p2.class_id<br><span class="hljs-keyword">and</span> p2.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bai&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里使用的是两个完全相同的表，但是使用了别名。</p><h2 id="outer-join-外部连接">OUTER JOIN 外部连接</h2><p>左连接是<strong>外部连接</strong>的一种，考虑下面的业务情景：我们有一个表<code>customers</code>，其中存储了所有客户的id等基本信息。现在另有一个表<code>orders</code>记录了客户所下的订单信息。现在我们要查询客户的下单情况，包括没有下单的客户也要记录在内。</p><p>这时如果使用内连接，会直接忽略没有下单的用户。解决方法是使用外部联结，保留客户表中的所有记录，即使订单表中没有记录与之匹配。</p><p>与内部联结关联两个表中的行不同的是，<strong>外部连接还包括没有关联行的行</strong>。在使用OUTERJOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTERJOIN右边的表，而LEFT指出的是OUTERJOIN左边的表）。它们之间的唯一差别是所关联的表的顺序不同。</p><p>左连接：获取左表中的<strong>所有记录</strong>，即使在右表没有对应匹配的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 左连接：显示A表所有记录，即使在B表中没有匹配</span><br><span class="hljs-comment">-- 没有匹配的项则以NULL值代替</span><br><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br></code></pre></td></tr></table></figure><p>以学生表和班级表举例：将班级表作为左表，学生表作为右表，统计每个班中的学生情况。sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> classes.name, students.name<br><span class="hljs-keyword">FROM</span> classes<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> students <span class="hljs-keyword">ON</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">+--------+------+<br>| name   | name |<br>+--------+------+<br>| class1 | mi   |<br>| class1 | jun  |<br>| class1 | hong |<br>| class1 | ming |<br>| class2 | ling |<br>| class2 | bing |<br>| class2 | bai  |<br>| class3 | li   |<br>| class3 | wang |<br>| class3 | xin  |<br>| class4 | NULL |<br>+--------+------+<br></code></pre></td></tr></table></figure><p><code>class4</code>没有学生，但是它已经出现在了表格中。这样能够找到没有关联的孤儿数据。</p><hr /><p>右连接的语法如下，和左连接基本相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 和左连接相反，返回 B 表所有记录，A 表不匹配的显示 NULL。</span><br><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br></code></pre></td></tr></table></figure><h2 id="cross-join-交叉连接">CROSS JOIN 交叉连接</h2><p>每一条 A 表记录都会和 B 表的每一条组合，结果是 A 表记录数 × B表记录数（笛卡尔积），用得不多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> B;<br></code></pre></td></tr></table></figure><p><strong>MySQL 没有内建的 FULLJOIN（全连接）语法关键词</strong>。想实现全连接，要用<code>LEFT JOIN + RIGHT JOIN + UNION</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 模拟 FULL OUTER JOIN</span><br><span class="hljs-keyword">SELECT</span> A.id, B.id<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.id<br><br><span class="hljs-keyword">UNION</span><br><br><span class="hljs-keyword">SELECT</span> A.id, B.id<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.id;<br><br></code></pre></td></tr></table></figure><h1 id="组合查询">组合查询</h1><p>目的：通过操作符将多个 SELECT 查询的结果合并在一起。</p><h2 id="union">UNION</h2><p>UNION的作用相当于包含<code>WHERE...OR...</code>的语句，不过在复杂的情况下写起来更加简洁。使用UNION 查询<code>class_id</code>为 1 或 2的学生，可以使用以下sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students<br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这里包含了两个select语句，第一个查询所有<code>class_id</code>为1的学生，第二个查询所有为2的学生。<code>union</code>关键词将两次查询的结果直接合并（如果有重复的数据会自动去除）。上述语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>UNION几乎总是完成与多个WHERE条件相同的工作。它的一种变体是<code>union all</code>，与union 的唯一区别是<code>union all</code>不会自动去重。</p><p>如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNIONALL而不是WHERE。</p><hr /><p><strong>总结</strong>：利用UNION，可把多条查询的结果作为一条组合查询返回，不管它们的结果中包含还是不包含重复。使用UNION可极大地简化复杂的WHERE子句，简化从多个表中检索数据的工作。</p><h1 id="通配符">通配符</h1><p>查询操作中的所有操作符都是针对已知值进行过滤的，有时候并不好用，例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。</p><div class="note note-info">            <p><strong>通配符</strong>（wildcard）用来匹配值的一部分的特殊字符。</p><p><strong>搜索模式</strong>（search pattern）由字面值、通配符或两者组合构成的搜索条件。</p>          </div><h2 id="like操作符">LIKE操作符</h2><p>LIKE 用于告诉 MySQL 接下来将会使用通配符进行匹配。LIKE一定要搭配通配符使用， 否则 MySQL会认为使用的是完全匹配而非模糊匹配。</p><h3 id="百分号通配符">百分号(%)通配符</h3><p>百分号（%）通配符 ：<strong>用于匹配多个字符</strong>，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;jet%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这样就找出了找出所有以词<code>jet</code>起头的产品:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">+---------+--------------+<br>| prod_id | prod_name    |<br>+---------+--------------+<br>| JP1000  | JetPack 1000 |<br>| JP2000  | JetPack 2000 |<br>+---------+--------------+<br>2 rows in set (0.017 sec)<br></code></pre></td></tr></table></figure><p><code>'jet%'</code>可以这样理解：<code>%</code>代表的其实是一个字符串剩余的其他字符，整个字符串必须以<code>jet</code>开头。类似地，<code>%jet%</code>代表的是包含<code>jet</code>的字符串，因为<code>jet</code>的前后都有字符。注意<code>%</code>匹配的也可以是空字符和空格，但是不能匹配<code>NULL</code>。</p><h3 id="下划线_通配符">下划线(_)通配符</h3><p>下划线的用途与%一样，但下划线只匹配<strong>单个字符</strong>而不是多个字符。</p><hr /><p>通配符虽然使用方便，但是通配符搜索的速度比一般的操作符要慢，所以不可以滥用通配符。在能达到相同目的睇情况下，应该优先使用其他操作符。</p><h1 id="正则表达式">正则表达式</h1><p>正则表达式是用来匹配文本的特殊的串（字符集合），功能非常强大。。MySQL用WHERE子句对正则表达式提供了初步的支持，只是正则表达式的一个很小的子集。</p><p><strong>关键字</strong>：<code>REGEXP</code></p><h2 id="字符匹配">字符匹配</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;.000&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><p>这里使用了正则表达式<code>.000</code>，小数点表示<em>匹配任意一个字符</em>，因此1000 和 2000 都会被匹配。</p><p>正则表达式匹配默认是不区分大小写【1的，如果需要区分，在正则表达式之前加上<code>BINARY</code>，例如<code>REGEXP BINARY 'JetPack .000'</code>。</p><h2 id="or-匹配">OR 匹配</h2><p>搜索两个字符串之一，使用<code>|</code>。例如：<code>REGEXP '1000|2000'</code>匹配所有包含1000 或 2000 的字符串。可以连续使用多个<code>|</code>。</p><h2 id="匹配多个字符之一">匹配多个字符之一</h2><p><code>[]</code>可以匹配中括号中出现的字符之一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;[123] Ton&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">+-------------+<br>| prod_name   |<br>+-------------+<br>| 1 ton anvil |<br>| 2 ton anvil |<br>+-------------+<br></code></pre></td></tr></table></figure><p>成功匹配 1 或 2 或 3。这是另一种形式的 OR语句。<code>[^123]</code>可以匹配除了这三个字符以外的任何东西。</p><h2 id="匹配范围">匹配范围</h2><p>属于上一个例子的加强版：<code>[0-9]</code>匹配数字 0 到9，不必把数字一个一个列举出来了。</p><p><code>[a-z]</code>匹配任意英文字母。</p><h2 id="特殊字符">特殊字符</h2><p>匹配任意字符可以用小数点<code>.</code>，那匹配小数点呢？</p><p>对于这种特殊字符，需要在前面加上<code>\\</code>转义(escaping)来匹配它本身，和Java中的处理方法相同。</p><h2 id="字符类">字符类</h2><p>有预先定义待的字符集可供使用：</p><p><img src="https://s21.ax1x.com/2025/05/11/pEXCWg1.png" /></p><h2 id="匹配多个实例">匹配多个实例</h2><p>对匹配的次数加以指定。例如：</p><ul><li><code>'[[:digit:]]&#123;4&#125;'</code> 匹配连在一起的任意4位数字。</li></ul><p><img src="https://s21.ax1x.com/2025/05/11/pEXCIHO.png" /></p><h2 id="定位符">定位符</h2><p>用于匹配特定位置的文本。</p><ul><li>^ 文本的开始</li><li>$ 文本的结尾</li><li>[[:&lt;:]] 词的开始</li><li>[[:&gt;:]] 词的结尾</li></ul><h1 id="修改数据">修改数据</h1><p>CRUD：Create、Retrieve、Update、Delete</p><p>增、删、改、查</p><p>前面的<code>SELECT</code>用于查，增删改对应的操作是：</p><ul><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul><h2 id="insert">INSERT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p>有默认值的字段在插入的时候可以不屑，自动附上默认值，但是没有默认值的话必须显式赋值。</p><p>可以同时使用多条INSERT语句，这时不同的语句之间用分号隔开。如果每条INSERT语句中的<code>表名(字段1, 字段2...)</code>相同，只需要在后面补充<code>VALUES</code>，并且用逗号隔开，这样可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。</p><h2 id="update">UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>, ... <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure><p><code>WHERE</code>可以涵盖多个对象，同时修改多个对象的值。</p><p>如果不写<code>WHERE</code>条件，整张表的记录都会被修改。</p><h2 id="delete">DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure><p>如果不写<code>WHERE</code>条件，整张表的记录都会被删除。</p><h1 id="mysql-引擎">MySQL 引擎</h1><ul><li>InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索，默认使用此引擎；</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。</li></ul><h1 id="视图">视图</h1><h2 id="用法">用法</h2><p>在 SQL中，视图（View）是一种<strong>虚拟表</strong>，它并不存储实际数据，而是基于一条SELECT查询语句动态生成的“结果集”。视图就是<strong>可重用</strong>的查询语句结果，它看起来像表，但不真正存储数据。</p><p>例如，现在我们要把每个学生所在班级的名字和学生的姓名放在一起，可以使用以下查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.name, s.name<br><span class="hljs-keyword">from</span> classes <span class="hljs-keyword">as</span> c<br><span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> s <span class="hljs-keyword">on</span> c.id <span class="hljs-operator">=</span> s.class_id;<br></code></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th>班级</th><th>学生名</th></tr></thead><tbody><tr><td>class1</td><td>小明</td></tr><tr><td>class1</td><td>hong</td></tr><tr><td>class1</td><td>jun</td></tr><tr><td>class1</td><td>mi</td></tr><tr><td>class2</td><td>bai</td></tr><tr><td>class2</td><td>bing</td></tr><tr><td>class2</td><td>ling</td></tr><tr><td>class3</td><td>xin</td></tr><tr><td>class3</td><td>wang</td></tr><tr><td>class3</td><td>li</td></tr><tr><td>class4</td><td>Spike</td></tr><tr><td>class4</td><td>Elma</td></tr><tr><td>class4</td><td>Amy</td></tr></tbody></table><p>现在，假如经常需要这个格式的结果。不必在每次需要时执行连接，只需创建一个视图，每次需要时使用它即可。为把此语句转换为视图，很简单，</p><ul><li>在查询语句开头加上<code>create view 视图名 as</code></li><li>这里有两个 name 字段，分别来自 classes 和 students 表，但列名都叫name。 所以视图就会有两个叫 name 的列，这在 SQL中是不允许的，解决方法是为两个字段分别起一个别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> class_student <span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> c.name <span class="hljs-keyword">as</span> class_name, s.name <span class="hljs-keyword">as</span> student_name<br><span class="hljs-keyword">from</span> classes <span class="hljs-keyword">as</span> c<br><span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> s <span class="hljs-keyword">on</span> c.id <span class="hljs-operator">=</span> s.class_id;<br></code></pre></td></tr></table></figure><p>以后要想查询班级名和学生名构成的表格，只需要调用以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> class_student;<br></code></pre></td></tr></table></figure><p>这样就完成了对固定连接查询结果的封装和重用。可以看出，视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</p><p>除了重用以外，视图还有以下作用：</p><ol type="1"><li>使用表的组成部分而不是整个表;</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限;</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ol><p>最后一点可以举个例子来说明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(name, <span class="hljs-string">&#x27;(&#x27;</span>, gender, <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">as</span> student<br><span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>上述语句将所有的男性信息按照<code>名字(性别)</code>的格式重建，如下：</p><table><thead><tr><th>student</th></tr></thead><tbody><tr><td>bing (M)</td></tr><tr><td>jun (M)</td></tr><tr><td>ling (M)</td></tr><tr><td>wang (M)</td></tr><tr><td>xQc (M)</td></tr></tbody></table><p>如果需要的话也可以把这个表格封装成一个视图。</p><h2 id="视图的规则和限制">视图的规则和限制</h2><ol type="1"><li>视图必须唯一命名;</li><li>为了创建视图，必须具有足够的访问权限;</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图;</li><li>ORDER BY 可以用在视图中，但如果从该视图检索数据 SELECT 中也含有ORDER BY ，那么该视图中的 ORDER BY 将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li></ol><h2 id="管理视图">管理视图</h2><ul><li>查看创建视图的语句：<code>show create view 视图名</code></li><li>删除视图：<code>drop view 视图名</code></li><li>更新视图时，可以先删除<code>deop</code>再创建<code>create</code>,也可以直接使用<code>create or replace view</code></li></ul><h1 id="存储过程">存储过程</h1><p>在 MySQL 中，存储过程（Stored Procedure）是一种预编译的 SQL语句集合，可以像调用函数一样执行它。它通常用于封装重复执行的操作，比如一组查询、更新或逻辑判断等。</p><p>使用存储过程有3个主要的好处，即简单、安全、高性能。</p><h2 id="创建">创建</h2><p>如果使用的是MySQL命令行，先创建一个存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> GetNameById(<br>  <span class="hljs-keyword">IN</span> custId <span class="hljs-type">INT</span><br>)<br><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> custId;<br><span class="hljs-keyword">END</span> $$<br><br></code></pre></td></tr></table></figure><ul><li><code>DELIMITER</code>的存在意义是改变 SQL语句的“语句结束符”。考虑不使用<code>DELIMITER</code>的情况：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> demo()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;world&#x27;</span>;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>每一个语句的结束处都必须有一个分号，其结果就是刚执行完<code>SELECT 'hello';</code>MySQL就认为语句已经结束了，从而报错。解决方法就是使用<code>DELIMITER</code>手动修改结束符，<code>DELIMITER $$</code>将结束符临时修改成<code>$$</code>，最后<code>END $$</code>把结束符改回默认的分号。</p><p>创建完毕之后，执行语句<code>call GetNameById(12);</code>，可以正确得到id为12 的学生的信息。</p><h2 id="参数问题">参数问题</h2><p>SQL 语句支持三种参数类型：</p><table><thead><tr><th>参数类型</th><th>说明</th></tr></thead><tbody><tr><td><code>IN</code></td><td>调用时传入的只读参数</td></tr><tr><td><code>OUT</code></td><td>存储过程执行后返回的输出值</td></tr><tr><td><code>INOUT</code></td><td>可读可写，调用时传入，过程内可以更改，并返回结果</td></tr></tbody></table><p>为了方便对存储过程传入参数或接收输出结果，往往需要定义变量。在MySQL中，所有的变量必须以<code>@</code>开头，定义变量使用<code>SET</code>关键字。</p><p>下面举一个使用了参数的存储过程的例子：根据传入的<code>id</code>输出对应学生的名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> get_student_by_id (<br><span class="hljs-keyword">in</span> student_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">out</span> student_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">into</span> student_name<br><span class="hljs-keyword">from</span> students<br><span class="hljs-keyword">where</span> students.id <span class="hljs-operator">=</span> student_id;<br><span class="hljs-keyword">end</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用该存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@sname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">call</span> get_student_by_id(<span class="hljs-number">1</span>, <span class="hljs-variable">@sname</span>);<br><br><span class="hljs-keyword">select</span> <span class="hljs-variable">@sname</span>;<br></code></pre></td></tr></table></figure><h2 id="删除">删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名<br></code></pre></td></tr></table></figure><p>如果指定的存储过程不存在，那么该语句会报错。为了防止报错，可以使用<code>DROP PROCEDURE IF EXISTS</code></p><h1 id="触发器">触发器</h1><p>MySQL 5 添加了对触发器的支持。</p><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p><ul><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ul><p>其他sql语句都不支持触发器。</p><h2 id="如何使用">如何使用</h2><p>创建触发器需要给出四条信息：</p><ul><li>唯一的触发器名（MySQL规定每个表中唯一，但是推荐在整个数据库范围内使用唯一的触发器名）；</li><li>触发器关联的表；</li><li>触发器应该响应的事件（DELETE、INSERT或UPDATE）；</li><li>触发器何时执行（处理之前或之后）。</li></ul><p>MySQL规定<strong>触发器中不能有任何返回结果集的行为</strong>，包括：</p><ul><li>SELECT</li><li>CALL 含有 SELECT 的存储过程</li><li>返回游标</li></ul><p>关键字：<code>CREATE TRIGGER</code>。下面的sql脚本创建了一个触发器，每当<code>students</code>表发生插入操作时就会执行，执行的结果是向用于记录日志的表<code>student_insert_log</code>插入一条日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> insert_test<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> students<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student_insert_log (student_id)<br>    <span class="hljs-keyword">VALUES</span> (NEW.id);<br><span class="hljs-keyword">END</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>触发器中还有<code>NEW</code>和<code>OLD</code>这两个特殊的关键字：</p><ul><li>在 INSERT触发器中可以通过<code>NEW</code>访问被插入的行，例如<code>NEW.id</code>获取被插入记录的id值。</li><li>在 DELETE 触发器代码内，可以引用<code>OLD</code>访问被删除的行</li><li>在 UPDATE触发器代码内，可以引用<code>OLD</code>引用原来的行，用<code>NEW</code>引用新的行</li></ul><p>BEFORE 和 AFTER 的使用场景：BEFORE用于对插入数据的数据验证，确保插入/更新/删除操作处理的是正确的数据。AFTER用于在操作完成后执行日志记录等。</p><h2 id="总结">总结</h2><ul><li>应该用触发器来保证<strong>数据的一致性</strong>（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。</li><li>触发器的一种非常有意义的使用是创建<strong>审计跟踪</strong>。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。</li><li>MySQL 触发器中<strong>不支持</strong> CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li></ul><h1 id="事务处理">事务处理</h1><h2 id="概述">概述</h2><p>事务处理(TransactionProcessing)一共有两个操作：提交(<strong>COMMIT</strong>)和回滚(<strong>ROLLBACK</strong>)。它可以用来维护数据库的完整性，保证成批的MySQL操作要么完全执行，要么完全不执行。</p><p>举个例子：现在我们用一个<code>orders</code>表用来记录客户订单的编号和下单日期，另一个表<code>orders_item</code>用来记录每个订单包含的物品、数量、价格的具体细节，这两个表通过主键<code>order_num</code>关联。显然，当我们收到新订单的时候，需要同时往两个表添加记录。但是如果两次插入操作中有某一个发生了错误，就会导致“空订单”的产生，这是不被允许的。</p><p>解决方法是将一个事务的所有操作统一管理起来。上述收到新订单后添加记录的就是一个事务，它包含两个操作：向<code>orders</code>插入订单编号和日期，向<code>orders_item</code>插入其它细节。</p><p>如果没有错误发生，将整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p><h2 id="常用术语">常用术语</h2><ul><li>事务（transaction）指一组SQL语句；</li><li>回滚（rollback）指撤销指定SQL语句的过程；</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回滚（与回退整个事务处理不同）。</li></ul><h2 id="控制事务处理">控制事务处理</h2><p>MySQL 使用以下语句表明事务的开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION<br></code></pre></td></tr></table></figure><p>开启事务后，可以在事务处理内部使用ROLLBACK。ROLLBACK 命令用来撤销INSERT, UPDATE, DELETE 语句。CREATE 和 DROP不能被回退。</p><p>在事务处理中，提交不会隐含地进行，必须显式调用COMMIT。看下面的例子：从账户 A 扣 100 元，给账户 B 加 100 元 ——中间任何一步失败都要回滚。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- A账户扣款</span><br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">-- B账户加款</span><br><br><span class="hljs-comment">-- 检查是否都成功执行</span><br><span class="hljs-comment">-- 可加上判断逻辑，比如检查余额 &gt;= 0，再决定是否提交</span><br><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务</span><br><br><span class="hljs-comment">-- 若发生异常，如余额不足</span><br><span class="hljs-comment">-- ROLLBACK;  -- 回滚事务</span><br></code></pre></td></tr></table></figure><p>实际上，如果第一条UPDATE语句成功执行，但是第二条出错，那么整个事务也会被自动撤销。这就保证了最后提交的结果一定是没有错误的。</p><p>当COMMIT或ROLLBACK语句执行后，事务会<strong>自动关闭</strong>（将来的更改会隐含提交）。</p><h2 id="保留点">保留点</h2><p>上面的回滚和提交的操作都针对整个事务。对于更复杂的事务而言，可能需要部分提交或者回滚。</p><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p><p>用法：<code>SAVEPOINT 保留点的名称</code></p><p>保留点的名字不可以重复，在回滚时，MySQL根据名字精确判断该回滚到哪个位置。为了回滚到已知的保留点，使用以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> 保留点的名字<br></code></pre></td></tr></table></figure><p>保留点设置得越多越好，这样可以充分按照自己的意愿进行回退。在事务处理完成以后，所有的保留点会被自动释放。</p><h2 id="更改默认提交行为">更改默认提交行为</h2><p><code>autocommit</code>标志决定是否自动提交更改，0 代表手动提交，1代表自动提交。使用<code>SET</code>修改即可。该标志的作用范围是一个连接内。</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.oracle.com/cn/database/what-is-a-relational-database/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/68136613<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML基础</title>
    <link href="/2025/04/29/XML%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/29/XML%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="xml">XML</h1><p>XML 还没有被淘汰，应用的地方还有不少，比如说 Maven 的 pom.xml文件里就还在用。但是作为一种数据传输格式，它正在被 JSON替代。所以以下简单列举一些XML的基础知识，更深层次的目前没必要去学。</p><h2 id="什么是xml">什么是XML</h2><p>XML(eXtensible MarkupLanguage，可扩展标记语言)，其设计目的就是存储和传输数据。XML也是一种标记语言，类似于HTML，但是HTML只负责显示数据，而且XML的标签不像HTML一样预先被定义。在许多HTML 应用程序中，XML 用于存储或传输数据，而 HTML用于格式化和显示这些数据。</p><p><strong>可扩展性</strong>就体现在，允许用户自定义任何需要的标签，而且即使添加了（或删除了）新数据，大多数XML 应用程序也会按预期工作，输出不受影响。<strong>XML的优势之一，就是可以经常在不中断应用程序的情况进行扩展</strong>。</p><p>和JSON一样，XML以纯文本格式存储数据，这样就避免了在不同的计算机系统上交换数据时的不兼容问题。</p><p>这是博客的站点地图文件<code>sitemap.xml</code>的一部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">urlset</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loc</span>&gt;</span>https://kznep19.blog/2025/04/27/Maven%E7%9A%84%E4%BD%BF%E7%94%A8/<span class="hljs-tag">&lt;/<span class="hljs-name">loc</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">lastmod</span>&gt;</span>2025-04-28<span class="hljs-tag">&lt;/<span class="hljs-name">lastmod</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">changefreq</span>&gt;</span>monthly<span class="hljs-tag">&lt;/<span class="hljs-name">changefreq</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>0.6<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">urlset</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>第一行是XML声明</li><li><code>urlset</code>是指定该文档遵循 sitemaps.org 的 Sitemap 0.9标准。，表示这是一个网址列表。<code>xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"</code>指定该文档遵循sitemaps.org 的 Sitemap 0.9 标准。</li><li><code>&lt;loc&gt;</code>:页面URL</li><li><code>&lt;lastmod&gt;</code>:页面的最后修改时间</li><li><code>&lt;changefreq&gt;</code>:建议搜索引擎多久抓取一次</li><li><code>&lt;priority&gt;</code>:页面在站点中的相对重要性(0.0–1.0)</li></ul><h2 id="xml树结构">XML树结构</h2><p>XML 中的元素形成了一种树状结构：</p><p><img src="https://www.w3school.com.cn/i/xml/nodetree.png" /></p><p>从最上面的根元素开始，扩展到枝叶。</p><h2 id="语法">语法</h2><ol type="1"><li>XML 文档必须包含一个根元素，作为其他所有元素的父元素</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">subchild</span>&gt;</span>.....<span class="hljs-tag">&lt;/<span class="hljs-name">subchild</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>XML 标签区分大小写</li><li>一些符号不能直接写在元素中，使用<strong>实体引用</strong></li></ol><table><thead><tr><th>字符</th><th>替代写法</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code>（less than）</td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code>（greater than）</td></tr><tr><td><code>&amp;</code></td><td><code>&amp;amp;</code>（ampersand）</td></tr><tr><td><code>"</code></td><td><code>&amp;quot;</code>（双引号）</td></tr><tr><td><code>'</code></td><td><code>&amp;apos;</code>（单引号）</td></tr></tbody></table><ol start="4" type="1"><li>多个连续的空格不会被裁剪</li></ol><h2 id="元素">元素</h2><p>类似<code>&lt;lastmod&gt;2025-04-28&lt;/lastmod&gt;</code>被称为一个<strong>元素</strong>。元素的内容可以是文本内容，也可以是其他的子元素。</p><p><strong>空元素</strong>：形如<code>&lt;element&gt;&lt;/element&gt;</code>，可以使用自关闭标签记为<code>&lt;element /&gt;</code>。</p><p>元素的命名约定：</p><table><thead><tr><th>样式</th><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>小写</td><td><code>&lt;firstname&gt;</code></td><td>所有字母小写</td></tr><tr><td>大写</td><td><code>&lt;FIRSTNAME&gt;</code></td><td>所有字母大写</td></tr><tr><td>蛇形</td><td><code>&lt;first_name&gt;</code></td><td>下划线分隔单词（常用于 SQL 数据库）</td></tr><tr><td>帕斯卡</td><td><code>&lt;FirstName&gt;</code></td><td>每个单词的第一个字母大写（C 程序员常用）</td></tr><tr><td>驼峰</td><td><code>&lt;firstName&gt;</code></td><td>除第一个之外的每个单词首字母大写（常用于 JavaScript）</td></tr></tbody></table><h2 id="属性">属性</h2><p><strong>Attribute</strong></p><p>XML属性必须加引号：<code>&lt;person gender="female"&gt;</code>，单双都可。属性的扩展性很差。</p><p>数据本身应当存储为元素，元数据（用于描述数据的信息）应当存储为属性。</p><h2 id="命名空间">命名空间</h2><p><strong>Namespace</strong></p><p>当两个不同的文档使用相同的元素名称时，就会发生<strong>命名冲突</strong>。例如，table既可以作为桌子的名称，也可以作为表格的名称。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>木头餐桌<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>员工工资表<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就很难区分了。解决方法：<strong>名称前缀</strong></p><p>在xml中使用前缀，必须定义命名空间。命名空间可以通过元素开始标记中的<code>xmlns</code>属性来定义，也就是XML Namespace。</p><p><strong>语法</strong>：<code>xmlns:前缀="命名空间的唯一标识符（一般是 URL）"</code></p><p>其中“命名空间的唯一标识符”即为 URI ，最常见的URI是URL(UniformResource Locator)，也就是网址。加上名称前缀之后上面的例子变成:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a:table</span> <span class="hljs-attr">xmlns:a</span>=<span class="hljs-string">&quot;http://example.com/furniture&quot;</span>&gt;</span>木头餐桌<span class="hljs-tag">&lt;/<span class="hljs-name">a:table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b:table</span> <span class="hljs-attr">xmlns:b</span>=<span class="hljs-string">&quot;http://example.com/database&quot;</span>&gt;</span>员工工资表<span class="hljs-tag">&lt;/<span class="hljs-name">b:table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就能区分开来了。</p><p>然后回到开头的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">urlset</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这似乎不符合命名空间的语法，其实这里用的是<strong>默认命名空间</strong>，意思是：文档中<strong>所有没有前缀的元素</strong>（如<code>&lt;url&gt;</code>、<code>&lt;loc&gt;</code>）<strong>都属于这个命名空间</strong>。</p><h2 id="xmlhttprequest">XMLHttpRequest</h2><div class="note note-secondary">            <p><code>XMLHttpRequest</code>是浏览器中的一个 JavaScript对象，用于在网页与服务器之间交换数据，而无需刷新整个页面。</p>          </div><p><code>XMLHttpRequest</code>是 2000 年代早期的API，不过现在有使用起来更简洁方便的<code>fetch</code>。使用xhr发送GET请求的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建请求对象</span><br><span class="hljs-keyword">var</span> xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">//事件处理函数，每当xhr的对象的状态发生变化时调用</span><br>xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//请求已完成，且返回的状态码为200</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>       <span class="hljs-comment">// 更新网页</span><br>       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = xhttp.<span class="hljs-property">responseText</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//设置请求方式和请求地址以及是否异步</span><br>xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送请求</span><br>xhttp.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p><strong>执行顺序</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">请求已发送<br>（稍后）onreadystatechange 被触发，当状态变为 <span class="hljs-number">4</span> 且 <span class="hljs-built_in">status</span> 为 <span class="hljs-number">200</span> 时执行回调<br></code></pre></td></tr></table></figure><p>由于是异步方式，<code>xhttp.send();</code>一开始就会被执行，浏览器异步地等待响应，期间可以去做别的事情，当xhr状态发生变化的时候才会更新网页。</p><h2 id="xml-解析">XML 解析</h2><h3 id="dom">DOM</h3><p>将 XML 文档转换为XML DOM 对象 - 可通过 JavaScript 操作的对象。</p><p>JS使用<code>DOMParser</code>解析xml字符串实例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xmlString = <span class="hljs-string">&quot;&lt;note&gt;&lt;to&gt;Alice&lt;/to&gt;&lt;from&gt;Bob&lt;/from&gt;&lt;/note&gt;&quot;</span>;<br><span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();<br><span class="hljs-keyword">const</span> xmlDoc = parser.<span class="hljs-title function_">parseFromString</span>(xmlString, <span class="hljs-string">&quot;application/xml&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xmlDoc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;to&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">textContent</span>); <span class="hljs-comment">// 输出 &quot;Alice&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码必须放到浏览器中才能运行。</p><p>上面使用解析器将XML文件转换为XML DOM对象，对于XMLDOM对象也有可用的访问方法。例如<code>getElementsByTagName</code>，<code>getElementById</code>等。因为XMLDOM呈现树状结构，我们从根元素出发一定可以遍历所有子节点，获取这个XML文件的所有信息。</p><h3 id="sax">SAX</h3><p>DOM方式固然省事，但是内存开销太大，因为整个XML文件必须加载到内存中之后才能使用。SAX是另一种解析XML的方式，即<code>Simple API for XML</code>，它是一种基于<strong>事件流</strong>的间隙方式，解析时逐个读取XML文件的元素并触发相应事件。但是使用起来依然很麻烦。</p><h3 id="jackson">Jackson</h3><p>Jackson是一个第三方库，它主要用于Java对象和JSON之间的转化，也可以实现XML到JavaBean的转换。<ahref="https://github.com/FasterXML/jackson">仓库地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven的基本操作</title>
    <link href="/2025/04/27/Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/04/27/Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Maven解决了软件构建的两方面问题：一是软件是如何构建的，二是软件的依赖关系。</p><p>不同于ApacheAnt等早期工具，Maven设定了构建流程的标准，在此之外只需要指定例外情况。XML文件描述了正在构建的软件项目、它对其他外部模块和组件的依赖关系、构建顺序、目录和所需的插件。该文件通常有预设的目标任务，例如代码编译和打包。Maven从一个或多个代码仓库（例如Maven2 CentralRepository）动态地下载Java库与Maven插件，并将其存储在本地缓存区中。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zh.wikipedia.org/wiki/Apache_Maven">[1]</span></a></sup></p><p>GAVP：为每个项目在maven仓库中做一个标识，类似于人的名字。</p><ul><li>Groupid是公司项目:公司项目-业务线</li><li>ArtifactID:产品线名-模块名</li><li>Version:主版本号.次版本号.修订号</li><li>Packaging:打包方式，Java工程打jar包，Web工程打war包，pom代表不会打包，用来做继承的父工程</li></ul><p>创建 Maven项目时，jdk版本最好选择jdk17、jdk21这些长期稳定版本，不要使用最新版，因为很多插件都不支持。</p><p>Maven中的测试类，类名必须以test结尾，测试方法以test开头，否则无法被识别。</p><h1 id="不同阶段">不同阶段</h1><table><thead><tr><th>阶段（Lifecycle）</th><th>作用</th><th>常用命令</th></tr></thead><tbody><tr><td>clean</td><td>清理之前的构建产物，比如 <code>target/</code> 目录</td><td>mvn clean</td></tr><tr><td>validate</td><td>验证项目是否正确，准备编译</td><td>mvn validate</td></tr><tr><td>compile</td><td>编译主代码（src/main/java）</td><td>mvn compile</td></tr><tr><td>test</td><td>编译并运行单元测试（src/test/java）</td><td>mvn test</td></tr><tr><td>package</td><td>打包成 jar/war 文件，输出到 target/</td><td>mvn package</td></tr><tr><td>verify</td><td>验证打包结果，比如执行集成测试</td><td>mvn verify</td></tr><tr><td>install</td><td>安装到本地仓库</td><td>mvn install</td></tr><tr><td>site</td><td>生成项目文档网站（项目依赖、测试报告等）</td><td>mvn site</td></tr><tr><td>deploy</td><td>部署到远程仓库供别人使用</td><td>mvn deploy</td></tr></tbody></table><p>手动引入依赖的格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖范围">依赖范围</h1><p>在pom文件中使用<code>&lt;scope&gt;</code>标签，英语控制该依赖起作用的阶段。一共有三个阶段：编译、测试、运行。</p><ul><li>compile<ul><li>编译、测试、运行阶段都可用</li><li>适用于项目本身需要直接使用的库，比如<code>Spring Boot</code>、<code>Lombok</code></li></ul></li><li>provided<ul><li>编译、测试可用，但是运行不可用，也就是不会被打包</li><li>运行时由服务器等外部环境提供，如<code>Servlet API</code>可以由<code>Tomcat</code>提供，因此属于provided 范围</li></ul></li><li>runtime<ul><li>仅在运行和测试可用，编译不可用</li><li>适用于运行时所需要的库，比如数据库驱动、JDBC 适配器等。</li><li>代码中通常只使用接口（如<code>java.sql.Connection</code>），编译时无需具体的JDBC 实现。</li></ul></li><li>test<ul><li>仅在测试可用，例如 JUnit 等测试框架</li></ul></li><li>system<ul><li>类似<code>provided</code>，但是需要本地手动提供jar包，不会从Maven仓库下载，相比之下不如使用私有Maven 仓库进行管理。不推荐使用</li></ul></li><li>import<ul><li>仅用于<code>dependencyManagement</code>依赖管理，引入一个具体的POM作为依赖版本管理。例如：引入Spring Boot BOM</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖下载失败">依赖下载失败</h1><p>如果引入依赖后没有联网，依赖将下载失败，即使再次联网也不会开始下载，因为本地仓库中已经存在了<code>.lastUpdated</code>后缀的文件。Maven只要检测到这个文件就不会开始下载，需要手动删除。</p><h1 id="build标签">build标签</h1><h2 id="指定打包文件">指定打包文件</h2><p><code>pom.xml</code>文件中的<code>&lt;build&gt;</code>主要用于对构建相关的信息进行配置。</p><div class="note note-primary">            <p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤</p>          </div><p>如果需要在src/main/java中放入非java文件，并且要求能够被打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--设置资源所在目录--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置包含的资源类型--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以将java目录下的任意<code>.xml</code>文件打包。</p><h2 id="引入插件">引入插件</h2><p>使用标签<code>&lt;plugin&gt;</code></p><h1 id="依赖传递和依赖冲突">依赖传递和依赖冲突</h1><h2 id="传递">传递</h2><p>如果A依赖B，B又依赖C，那么A也间接依赖C，那么在执行项目A时，会自动把其他两个项目下载导入到jar包文件夹中。这就是<strong>依赖的传递性</strong>。</p><p>另一方面，依赖能否成功传递还取决于依赖范围：</p><ul><li><code>&lt;optional&gt;true&lt;/optional&gt;</code>手动终止依赖传递</li><li>非compile范围无法进行依赖传递</li><li>依赖冲突（传递的依赖已经存在）</li></ul><h2 id="冲突">冲突</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">项目A -&gt; 依赖B（B依赖X:1.0）<br>    └──&gt; 依赖C（D依赖X:2.0）<br></code></pre></td></tr></table></figure><p>这里B和C都依赖了X的不同的版本，出现依赖冲突。Maven的自动选择原则如下：</p><ul><li>短路优先（路径最短优先）哪个近用哪个</li><li>路径长度相同的情况下，声明优先，在<code>&lt;dependencies&gt;</code>中先声明的被使用</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><br>├── <span class="hljs-variable">B</span><br>│    └── <span class="hljs-built_in">C</span><span class="hljs-operator">:</span><span class="hljs-number">1.0</span><br>└── <span class="hljs-built_in">D</span><br>     └── <span class="hljs-built_in">C</span><span class="hljs-operator">:</span><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>如果B在D声明之前，则使用C1.0。</p><p>也可以手动排除依赖冲突：<code>&lt;exclusions&gt;</code></p><h1 id="工程继承">工程继承</h1><p>Maven 工程继承指的是在 Maven项目中让一个项目从另一个项目继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。</p><ul><li>对一个大型的项目进行了模块的拆分</li><li>每个项目下面又很多个模块，每一个模块都需要配置自己的依赖信息。</li></ul><p>父工程主要用来做依赖的管理或配置信息的管理，不需要写源代码，编译时父工程中的类不会被打包。对父工程进行的清理、编译等操作也会同步进行到子工程中，可以一键管理。</p><p>子工程应当在父工程目录下被创建，子工程的配置文件中会出现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>表明了父工程的坐标。子工程的GroupId和父工程自动保持一致。</p><p>父工程的<code>&lt;dependencies&gt;</code>会<strong>无条件</strong>地被子工程继承，所以一般在<code>&lt;properties&gt;</code>的下面加上<code>&lt;dependencyManagement&gt;</code>，然后在这个标签内部声明依赖，这样子工程不会默认继承它。如果需要继承，在子工程的配置文件中只需要复制groupId和artifactId就可以使用了，不用写版本号。</p><h1 id="工程聚合">工程聚合</h1><p>聚合是指<strong>将多个项目组织到一个父级项目中</strong>，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署的过程。</p><p>目标：<strong>一键操作、一键构建</strong>。</p><p>语法：在GAVP之后加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>子工程的相对路径<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如，如果子工程就在父工程的目录下，可以直接写<code>maven_son</code></p><h1 id="maven-私服">Maven 私服</h1><h2 id="简介">简介</h2><p>Maven私服是一种特殊的Maven远程仓库，它是架设在<strong>局域网</strong>内的仓库服务，用来代理位于外部的远程仓库。</p><blockquote><p>当然并不是说私服只能建立在局域网，很多公司会把私服直接部署到公网，方便员工居家办公。</p></blockquote><p>建立了Maven私服后，当局域网内的用户需要某个构建时，会按照如下的顺序进行请求和下载：</p><ol type="1"><li>请求本地仓库，若不存在则下一步</li><li>请求Maven私服，将所需构件下载到本地仓库，若不存在则下一步</li><li>请求外部的远程仓库，将所需构件下载并缓存到私服，若不存在则报错</li></ol><p>Maven用户既可以从私服下载构件，也可以上传构件。</p><p><strong>私服的优势</strong>：降低外网带宽压力；下载速度更快；便于部署第三方构件（有些构件无法从第三方仓库获得）；提高项目的稳定性，增强对项目的控制。</p><h2 id="sonatype-nexus">Sonatype Nexus</h2><p>使用最广泛的 Maven 私服产品是<strong>Nexus</strong>。Nexus RepositoryManager（通常简称 Nexus）是由一家叫 Sonatype的公司开发的，它本质上是一个 Maven 仓库管理器。</p><blockquote><p>Sonatype Nexus Repository是一款软件仓库管理器，既有开源许可版本，也有商业许可版本。它能够将多种编程语言的仓库整合在一起，使得可以通过一个服务器作为构建软件时的统一来源。开源版使用的是H2 数据库。<br />Tamás Cservenák 最初在 2005年 开发了Proximity，原因是他当时使用的是较慢的 ADSL互联网连接。 后来，他被Sonatype 公司聘请，开发了一个类似的产品，即Nexus。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Sonatype_Nexus_Repository">[2]</span></a></sup></p></blockquote><p>安装过程比较烦人，先进入https://www.sonatype.com/nexus-repository-oss填写信息下载，下载好之后解压。</p><p>按照网上的方法进入bin目录输入<code>nexus.exe /run</code>，报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E:\nexus-<span class="hljs-number">3.79</span>.<span class="hljs-number">1</span>-<span class="hljs-number">04</span>-win-x86_64\nexus-<span class="hljs-number">3.79</span>.<span class="hljs-number">1</span>-<span class="hljs-number">04</span>\bin&gt;nexus<span class="hljs-selector-class">.exe</span> /run<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Unrecognized cmd <span class="hljs-selector-tag">option</span> /run<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Invalid command <span class="hljs-selector-tag">line</span> arguments.<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Apache Commons Daemon procrun failed with exit value: <span class="hljs-number">1</span> (failed to parse command <span class="hljs-selector-tag">line</span> arguments).<br></code></pre></td></tr></table></figure><p>说明网上的方法失效了。再看一眼解压后的目录</p><p><img src="https://s21.ax1x.com/2025/04/28/pE7iUJ0.png" /></p><p>看看第一个文件。</p><p>嗯？有点怪，这不是安装脚本嘛。再翻翻官方文档<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://help.sonatype.com/en/sonatype-nexus-repository.html">[3]</span></a></sup></p><p><img src="https://s21.ax1x.com/2025/04/28/pE7AuJ1.png" /></p><div class="note note-primary">            <p>Nexus Repository 在 3.78.0 版本进行了大量构建方式的更改。 3.78.0及以后版本使用了上面列出的 //ES//、//SS//、//DS// 这种新格式。</p>          </div><p>总之很折腾，不建议使用最新版本，最好使用3.78.0之前的。</p><p>从这个链接下载历史版本：https://help.sonatype.com/en/download-archives---repository-manager-3.html</p><p>下载之前记得看一下自己的电脑上有没有对应的jdk版本。</p><p>成功启动之后通过localhost:8081访问。</p><p>后续利用Nexus搭建私服和Maven联动的内容到了后期才会用到，这里先歇一歇。</p><p>放几个参考链接。以后再来看：</p><p>https://www.easyblog.vip/detail/58</p><p>https://www.bilibili.com/video/BV1854y1F7Lt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9</p><p>https://wiki.eryajf.net/pages/1815.html#_1-%E5%88%9B%E5%BB%BA-blob-%E5%AD%98%E5%82%A8%E3%80%82</p><p>https://www.hangge.com/blog/cache/detail_2844.html</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://zh.wikipedia.org/wiki/Apache_Maven<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://en.wikipedia.org/wiki/Sonatype_Nexus_Repository<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://help.sonatype.com/en/sonatype-nexus-repository.html<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 背景图随日夜模式切换</title>
    <link href="/2025/04/26/%E7%99%BD%E5%A4%A9%E9%BB%91%E5%A4%9C%E8%83%8C%E6%99%AF%E5%9B%BE%E5%88%87%E6%8D%A2/"/>
    <url>/2025/04/26/%E7%99%BD%E5%A4%A9%E9%BB%91%E5%A4%9C%E8%83%8C%E6%99%AF%E5%9B%BE%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>2025/5/24 补充：</p><p>关于这项功能的实现，<ahref="https://4rozen.github.io/archives/Hexo/60191.html">这篇博客</a>提供了更好的实现思路，如果你想实现该功能的话推荐优先参考这个。</p><p>本文提供的是一种比较简陋的实现方式，因为没有配置预加载功能所以第一次切换背景时会看到明显的闪屏。</p><h1 id="获取当前模式">1. 获取当前模式</h1><p>要解决的第一件事是获取当前页面采用的模式。</p><p>按F12打开控制台，很容易发现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Color Toggle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-dark&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color-toggle-icon&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;light&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>class="iconfont icon-dark"</code>指的是当前显示的按钮图标，当鼠标悬停在上方时就会发生改变，所以我们需要的不是这个</li><li><code>id="color-toggle-icon"</code>可以通过唯一id获取这个对象</li><li><code>data="light"</code>记录的是当前所在的模式，正是我们需要的</li></ul><p>因此，要获取当前的模式，只需要在自定义js文件<code>backgroundize.js</code>中写入以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> dataValue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>); <span class="hljs-comment">// 获取data属性</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data属性值是：&#x27;</span>, dataValue);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>打开控制台看看效果：</p><p><img src="https://s21.ax1x.com/2025/04/26/pETiPpT.png" /></p><p>发现获取的data值和当前页面的实际模式刚好相反，这个问题不大，比较烦人的是每一次点击按钮控制台都会打印出两个完全相同的值。通过检查按钮的属性，发现这个click事件被<strong>重复绑定</strong>两次。</p><p>解决方法：定义一个全局变量作为标记，初始值为<code>undefined</code>，绑定一次之后赋值为<code>true</code>，因此以后不会重复绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听主题切换按钮点击事件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentMode</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查是否已初始化</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleColorToggle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getCurrentMode</span>());<br>    &#125;<br><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleColorToggle);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的效果：</p><figure><img src="https://s21.ax1x.com/2025/04/26/pETibU1.png"alt="backgroundize.js只被绑定一次" /><figcaption aria-hidden="true">backgroundize.js只被绑定一次</figcaption></figure><p>可以看出非用户自定义的文件也有被重复绑定的情况，原因暂时不太清楚。</p><h1 id="替换背景图">2. 替换背景图</h1><p>文章页的背景图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;web_bg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-image: url(<span class="hljs-symbol">&amp;quot;</span>/img/girl.webp<span class="hljs-symbol">&amp;quot;</span>);position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首页的背景图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;web_bg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-image: url(<span class="hljs-symbol">&amp;quot;</span>/img/miku.webp<span class="hljs-symbol">&amp;quot;</span>);position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意仅从html上已经无法区分这两张图片，而我的目标是只在文章页的时候启用切换。注意到文章页和首页的<code>&lt;head&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;article&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;website&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以可以从这里下手进行区分。完整的js代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 检查是否已初始化</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span>) &#123;<br><br>    <span class="hljs-comment">//为点击事件绑定切换背景的功能</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, setBackgroundImage);<br><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已初始化</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前日/夜模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> light:夜，dark:日（刚好反过来）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentMode</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置背景图片</span><br><span class="hljs-comment"> * 通过Open Graph meta判断当前页面是不是文章页</span><br><span class="hljs-comment"> * 如果是，则根据当前的模式替换背景图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setBackgroundImage</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">const</span> ogTypeMeta = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[property=&quot;og:type&quot;]&#x27;</span>);<br>    <span class="hljs-keyword">const</span> isPost = ogTypeMeta &amp;&amp; ogTypeMeta.<span class="hljs-property">content</span> === <span class="hljs-string">&#x27;article&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (isPost) &#123;<br>        <span class="hljs-keyword">const</span> bgDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;web_bg&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (bgDiv) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getCurrentMode</span>() === <span class="hljs-string">&#x27;light&#x27;</span>) bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/night.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-keyword">else</span> bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/girl.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-comment">//console.log(&quot;成功替换&quot;);</span><br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上面的代码只有当点击日夜切换按钮时才生效。</span><br><span class="hljs-comment"> * 如果在首页就切换为黑夜模式，进入文章页后会发现背景仍然是白色的</span><br><span class="hljs-comment"> * 所以这里利用DOMContentLoaded事件，每当一个页面的HTML结构加载完成时判断是否是文章页，是的话就根据模式替换背景</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 通过 Open Graph 协议判断</span><br>    <span class="hljs-keyword">const</span> ogTypeMeta = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[property=&quot;og:type&quot;]&#x27;</span>);<br>    <span class="hljs-keyword">const</span> isPost = ogTypeMeta &amp;&amp; ogTypeMeta.<span class="hljs-property">content</span> === <span class="hljs-string">&#x27;article&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (isPost) &#123; <span class="hljs-comment">// 判断进入文章页</span><br><br>        <span class="hljs-keyword">const</span> bgDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;web_bg&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (bgDiv) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getCurrentMode</span>() === <span class="hljs-string">&#x27;light&#x27;</span>) bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/night.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-keyword">else</span> bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/girl.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-comment">//console.log(&quot;成功替换&quot;);</span><br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后再加入css代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 明暗切换 */</span><br><span class="hljs-selector-id">#web_bg</span> &#123;<br>    <span class="hljs-attribute">transition</span>: background-image <span class="hljs-number">0.5s</span> ease-in-out <span class="hljs-meta">!important</span>;<br>&#125;<br><br><span class="hljs-comment">/* 由黑夜切换为白天的时间会长一点 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;<br>    <span class="hljs-selector-id">#web_bg</span> &#123;<br>        <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.8s</span> <span class="hljs-meta">!important</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这里采用的逻辑是只有检测到加载的页面是文章页时才执行北京替换的逻辑，所以使用了两处替换背景的功能：初次加载页面时、按下日夜切换按钮时。</p><h1 id="遗留问题">遗留问题</h1><p>上面的实现方式有一个缺陷：刚进入文章页时有概率先显示出<code>config.fluid.yml</code>中配置的原背景图，再渐变转换成预期的背景图，看起来比较突兀。因为我之前配置过预加载功能，所以干脆直接把原背景图换成和加载页面相同底色的图了。</p><p>另外，在文章页内第一次点击日夜切换按钮时，因为背景图只有在需要它的时候才会开始加载，所以第一次背景会闪烁一下然后突然出现背景图，后续再次切换模式的时候才会正常。要解决这个问题就要使用预加载，提前加载背景图片。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础</title>
    <link href="/2025/04/23/JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/23/JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>JS基础知识，先速通一遍，以后再慢慢补充细节</p><span id="more"></span><h1 id="引入方式">引入方式</h1><h2 id="内部脚本">内部脚本</h2><p>将JS代码定义在HTML中。可以在任意地方放置任意数量的js，但是一般会把脚本位于<code>&lt;body&gt;</code>元素的底部，可以改善显示速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello JavaScript&quot;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="外部脚本">外部脚本</h2><p>定义在外部js文件中，HTML文档通过以下格式引用，不能自闭合。外部js文件不需要<code>&lt;script&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="基本语法">基本语法</h1><ul><li>每行结尾的分号可有可无（但是建议加上）</li><li>输出语句<ul><li><code>window.alert()</code>弹出窗口（/əˈlɜːrt/ 意思是警示）</li><li><code>document.write()</code>写入HTML文档（开发很少用）</li><li><code>console.log()</code>输出到控制台</li></ul></li></ul><h1 id="变量">变量</h1><p>在 JavaScript 中定义变量的方法有三种，分别是</p><ol type="1"><li><code>let</code>（推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;初音ミク&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>let</code>定义的是可以<strong>更改值</strong>的变量</li><li>代码块内有效</li></ul><ol start="2" type="1"><li><code>const</code>（推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159</span>;<br></code></pre></td></tr></table></figure><ul><li><code>const</code>定义的是<strong>常量</strong>，<strong>不能重新赋值</strong></li><li>一旦赋值就不能改变</li><li>代码块内有效</li></ul><ol start="3" type="1"><li><code>var</code>⚠️（不推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><ul><li>旧语法（ES5之前），写老代码、或者兼容旧浏览器才用</li><li>允许修改</li><li>变量会提升（hoisting），且是函数作用域，容易出 bug</li><li>出代码块还可以访问，属于全局变量</li><li>可以重复定义，前两个都不行。例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-title function_">alert</span>(x);<br></code></pre></td></tr></table></figure><p>不报错。</p><h1 id="数据类型运算符流程控制语句">数据类型、运算符、流程控制语句</h1><h2 id="数据类型">数据类型</h2><ul><li><strong>原始类型（Primitive Types）</strong></li></ul><p>对应Java中的基本数据类型，但是分得没那么细</p><table><thead><tr><th>数据类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>number</code></td><td><code>42</code>, <code>3.14</code>, <code>NaN</code>,<code>Infinity</code></td><td>数字类型，包含整数和浮点数</td></tr><tr><td><code>string</code></td><td><code>"Hello"</code>, <code>'世界'</code></td><td>字符串，单双引号都可</td></tr><tr><td><code>boolean</code></td><td><code>true</code>, <code>false</code></td><td>布尔值</td></tr><tr><td><code>undefined</code></td><td><code>let x;</code> → <code>x === undefined</code></td><td>声明未赋值时的默认值</td></tr><tr><td><code>null</code></td><td><code>let x = null</code></td><td>表示“无”或“空值”</td></tr><tr><td><code>bigint</code></td><td><code>12345678901234567890n</code></td><td>大整数类型（ES2020+）</td></tr><tr><td><code>symbol</code></td><td><code>Symbol("id")</code></td><td>独一无二的标识符</td></tr></tbody></table><ul><li><strong>引用类型（Reference Types）</strong></li></ul><p>对应Java中的引用数据类型，但是少得多</p><table><thead><tr><th>数据类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>object</code></td><td><code>&#123; name: "Miku", age: 16 &#125;</code></td><td>普通对象，键值对结构</td></tr><tr><td><code>array</code></td><td><code>[1, 2, 3, "初音"]</code></td><td>数组，JS 中是一种对象类型</td></tr><tr><td><code>function</code></td><td><code>function greet() &#123;&#125;</code></td><td>函数也是对象</td></tr><tr><td><code>date</code></td><td><code>new Date()</code></td><td>日期对象</td></tr><tr><td><code>regexp</code></td><td><code>/abc/</code>, <code>new RegExp("abc")</code></td><td>正则表达式对象</td></tr></tbody></table><p>使用<code>typeof</code>运算符可以得到数据类型。</p><h2 id="运算符">运算符</h2><p>算术运算符，逻辑运算符同Java。</p><p>比较运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">==    <span class="hljs-comment">// 相等，会进行类型转换</span><br>===   <span class="hljs-comment">// 全等（值和类型都相等），不进行类型转换✅推荐</span><br>!=    <span class="hljs-comment">// 不等</span><br>!==   <span class="hljs-comment">// 全不等（值和类型都不相等）</span><br>&lt; &gt; &lt;= &gt;=<br></code></pre></td></tr></table></figure><p>赋值运算符： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">= **<br>+=   -=   *=   /=   %=   **=<br></code></pre></td></tr></table></figure></p><ul><li><code>**</code>：<strong>指数运算符ExponentiationOperator）</strong>，例如<code>2**3</code>表示2的三次方。它是<strong>左结合</strong>运算符，比如<code>2 ** 3 ** 2</code>的计算顺序是<code>2 ** (3 ** 2)</code>。</li><li><code>**=</code>是<strong>指数赋值运算符（Exponentiation assignmentoperator）</strong>，ES7加入。举个例子：<code>x **= y</code>，意思就是<code>x = x ** y;</code>，意思就是把x的y次方赋给x本身。例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br>a **= <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>就是把<code>a</code>的3次方赋值给<code>a</code>，结果为8。</p><h3 id="类型转换">类型转换</h3><h4 id="转换成字符串">转换成字符串</h4><p><code>.toString()</code></p><p>Boolean值、数字(number)和字符串(string)都是<strong>伪对象</strong>，它们实际上具有属性和方法，<code>.toString()</code>就是其中一种可供调用的方法。</p><p>另外number类型的<code>toString()</code>方法比较特殊，如果不传入任何参数，那么采用的是<strong>默认模式</strong>，返回的是数字的十进制表示。如果传入参数，即为<strong>基模式</strong>，可以用不同的基(radix)输出数字。</p><p>例如，以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">9</span>;<br><span class="hljs-title function_">alert</span>(x.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>得到的结果为<code>1001</code>，也就是十进制数字9的二进制表示。</p><h4 id="转换成数字">转换成数字</h4><p>转换为整数：<code>parseInt</code>转换为小数：<code>parseFloat()</code></p><p>从开头开始从左到右读取是数字的部分。如果开头就不是数字，则转换失败，返回<code>NaN</code>(Nota Number)。</p><p>字符串中包含的数字字面量会被正确转换为数字，例如"0xA"会被转换成数字10。但是"22.5"会被转换成22，因为小数点被当成无效字符处理了。<code>parseFloat()</code>会把遇到的第一个小数点当成小数点处理。</p><p><code>parseInt()</code>方法也有基模式，定义为<code>parseInt(string: string, radix?: number): number</code>，但是<code>parseFloat()</code>没有。</p><p>相比之下，Java使用<code>Integer.parseInt()</code><code>Float.parseFloat</code> <code>Double.parseDouble()</code><code>Long.parseLong</code>等方法进行转换，如果转换失败会抛出<code>NumberFormatException</code>异常。</p><h3 id="强制类型转换">强制类型转换</h3><p><strong>type casting</strong></p><p class="note note-info">cast有“铸造”之意，很贴合“强制转换”的意思</p><p><strong>ECMAScript 中可用的3种强制类型转换</strong>：</p><ul><li>Boolean(value) - 把给定的值转换成 Boolean 型；空字符串、数字0、undefined 或 null，返回 false。</li><li>Number(value) -把给定的值转换成数字（可以是整数或浮点数）；处理<strong>整个值</strong>。</li><li>String(value) - 把给定的值转换成字符串；</li></ul><h1 id="函数">函数</h1><p>使用<strong>function</strong>进行定义，语法为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">para1, para2,...</span>) &#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>形参不需要类型，因为js弱类型</li><li>返回值也不需要定义类型，有return就说明有返回值</li><li>调用的时候可以传递任意个数的参数</li></ul><p>函数作为形参时，使用lambda表达式会舒服很多。</p><h2 id="闭包closure">*闭包(closure)</h2><h3 id="引入">引入</h3><p>JS比较独特的一个特性。</p><div class="note note-secondary">            <p>JavaScript 变量属于 本地 或 全局 作用域。 全局变量能够通过 闭包实现局部（私有）。</p>          </div><ul><li>在网页中，全局变量属于<code>window</code>对象，全局变量能够被页面中（以及窗口中）的所有脚本使用和修改。</li><li>而局部变量只能用于其被定义的函数内部，对于其他函数和脚本代码来说它是不可见的。</li></ul><p>考虑下面这种情况：我们想做一个计数器用来计数函数被调用的次数。如果使用下面这种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始化计数器</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 递增计数器的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>  counter += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用三次 add()</span><br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><br><span class="hljs-comment">//此时计数器为3</span><br></code></pre></td></tr></table></figure><p>虽然能实现计数的功能，但是<strong>不够安全</strong>，因为作为全局变量的<code>counter</code>可以被任意函数随意更改。为了防止随意更改，考虑把它声明为局部变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params"></span>) &#123;counter += <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-title function_">plus</span>();     <br>    <span class="hljs-keyword">return</span> counter; <br>&#125;<br></code></pre></td></tr></table></figure><p>显然仍然存在问题，因为每次调用这个函数时都会给<code>counter</code>重新赋值为0，不能实现计数的功能，我们必须保证初始化函数之被调用一次</p><p>在Java中，我们可以使用权限修饰符<code>private</code>和<code>getter</code>解决安全性问题，但是JS中没有权限修饰符，怎么办？有没有什么东西可以实现类似的功能？</p><p>答案是有的，那就是闭包。</p><hr /><h3 id="使用">使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> counter += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> conterFunc = <span class="hljs-title function_">add</span>(); <span class="hljs-comment">// 获得内层函数</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><br><span class="hljs-comment">//控制台： 1  2  3  4</span><br></code></pre></td></tr></table></figure><ul><li><code>add</code>是外层函数，内部定义了一个内部匿名函数，并且<code>add</code>的返回值就是内部函数的引用，或者说句柄；</li><li><code>const conterFunc = add();</code>调用了一次外层函数，创建一个<code>counter</code>并初始化为0；</li><li>之后每次调用<code>conterFunc()</code>实际上调用的是内层函数，因为<code>counter</code>还是第一次创建好的那个，所以可以正常计数；</li><li>又因为<code>counter</code>是函数内部定义的局部变量，所以不会被外界访问到，足够安全。</li></ul><p><strong>注意</strong>：每次调用<code>add()</code>会生成新的独立包，相互独立互不影响，所以只在开头调用了一次。</p><p>闭包还可以把多参数的函数变成单参数的函数，例如平方和立方的计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 把x和n分配到外层函数和内层函数即可实现 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, n);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建两个新函数:</span><br><span class="hljs-keyword">let</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> pow3 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow2</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow3</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><h2 id="生成器generator">生成器(generator)</h2><p>ES6标准引入的新的数据类型。另外，</p><div class="note note-primary">            <p>生成器函数 是一种可以“暂停执行”的函数，通过 function* 定义，用 yield控制流程，返回的是一个 可迭代对象（iterator）。</p>          </div><ul><li><code>yield</code>: 返回一个值给外部，同时暂停函数的执行。</li><li><code>next()</code>: 一旦调用就执行到下一个<code>yield</code></li></ul><p>调用这个函数不会直接执行函数体内部的代码，而是返回一个<strong>生成器对象</strong>（generatorobject）。每次调用它都会重开一个生成器。</p><p>为了让生成器能往下跑，需要采用类似闭包的方法：先获取句柄</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">countUp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> i++; <span class="hljs-comment">// 返回i的值，然后i+1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">countUp</span>(); <span class="hljs-comment">// 先创建一个“可以暂停的执行器” </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">countUp</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h1 id="对象">对象</h1><ul><li>Array</li><li>String</li><li>JSON</li><li>BOM(Browser Object Model, 浏览器对象模型)</li><li>DOM(Document Object Model, 文档对象模型)</li></ul><h2 id="包装类对象">包装类对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123.</span>.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 不报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123.</span><span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p><strong>别用</strong></p><h2 id="date">Date</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">11</span>, <span class="hljs-number">24</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<br><span class="hljs-comment">//控制台输出：Mon Dec 24 2018 10:33:30 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>JavaScript 从 0 到 11 计算月份。 一月是 0。十二月是11。6个数字指定年、月、日、小时、分钟、秒：</p>          </div><h2 id="array">Array</h2><ul><li><strong>定义</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一般方式</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 简化的方式</span><br><span class="hljs-keyword">var</span> cars = [<span class="hljs-string">&quot;Saab&quot;</span>, <span class="hljs-string">&quot;Volvo&quot;</span>, <span class="hljs-string">&quot;BMW&quot;</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>访问</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr[index] = value;<br></code></pre></td></tr></table></figure><ul><li><strong>遍历</strong>：推荐<code>forEach</code>方法（相当于Java中的forEach+lambda表达式）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);<br>&#125;);<br></code></pre></td></tr></table></figure><p>JS数组长度可变，类型可变，可以存储任意类型的数据。没有赋值的位置记为undefined。</p><p><strong>属性</strong>：<code>length</code>，用法同Java</p><p><strong>方法</strong>：</p><ul><li><code>forEach</code>:遍历<strong>有值</strong>的元素，并调用传入的函数</li><li><code>push()</code>:将新的元素添加到数组的末尾，并返回新的长度</li><li><code>splice(start: number, deleteCount?: number): number[]</code>:从数组中删除元素，左闭右开。问号表示可选参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台：3 4</p><h2 id="string">String</h2><p><strong>创建</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 变量名 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><span class="hljs-keyword">var</span> 变量名 = <span class="hljs-string">&quot;...&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>属性</strong>：<code>length</code></p><p><strong>方法</strong>：</p><ul><li><code>charAt(index)</code>:返回字符串中 指定位置的字符。</li><li><code>indexOf(searchValue, fromIndex?)</code>:从fromIndex开始查找某个子字符串第一次出现的位置，找不到就返回-1。</li><li><code>trim()</code>:去除字符串两边的空格（不包括中间的空格）。</li><li><code>substring(startIndex, endIndex?)</code>:截取字符串的一部分，左闭右开。</li></ul><h3 id="对字符串做一些补充">对字符串做一些补充</h3><ol type="1"><li><strong>多行字符串</strong>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">`这是一个</span><br><span class="hljs-string">多行</span><br><span class="hljs-string">字符串</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>通过反引号的形式声明多行字符串，可以省去换行字符。</p><ol start="2" type="1"><li><strong>模板字符串</strong>：</li></ol><p>要把多个字符串连接起来，可以用+号连接；ES6新增了一种模板字符串，连接字符串更方便：（注意使用反引号包裹）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;sss&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">17</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`名字是：<span class="hljs-subst">$&#123;person.name&#125;</span>, 年龄是<span class="hljs-subst">$&#123;person.age&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="json">JSON</h2><p>基于 JavaScript 语言的轻量级的数据交换格式（JavaScript ObjectNotation）</p><p>意义：</p><div class="note note-success">            <p>当数据在浏览器与服务器之间进行交换时，这些数据只能是文本。</p><p>JSON 属于文本，并且我们能够把任何 JavaScript 对象转换为 JSON，然后将JSON 发送到服务器。</p><p>我们也能把从服务器接收到的任何 JSON 转换为 JavaScript 对象。</p><p>以这样的方式，我们能够把数据作为 JavaScript对象来处理，无需复杂的解析和转译。</p>          </div><p>虽然名字里有 JavaScript，但它是语言无关的格式，可以被几乎所有语言（如Python、Java、C#）支持。</p><hr /><p>先说说JS自定义对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 对象名 = &#123;<br>    属性名：属性值,<br>    ...<br>    函数名:<span class="hljs-keyword">function</span>(<span class="hljs-params">形参列表</span>)&#123;执行代码&#125;<br>    <span class="hljs-comment">// :function 可以省略</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>如何定义一个JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hưng&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;languages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Vietnamese&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Japanese&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Chinese&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;isStudent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;details&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Ho Chi Minh&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobbies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;music&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;anime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;games&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>把 JSON字符串转为对象</strong>：<code>const obj = JSON.parse(jsonStr);</code></li><li><strong>把对象转为 JSON字符串</strong>：<code>const jsonStr = JSON.stringify(obj);</code></li></ul><h1 id="面向对象编程">面向对象编程</h1><p>参看这位大佬的博客：</p><p><ahref="https://www.cnblogs.com/wangfupeng1988/p/3977924.html">深入理解javascript原型和闭包</a></p><h1 id="bom">BOM</h1><p>浏览器对象模型允许 JavaScript 与浏览器对话。</p><ul><li><code>window</code>:窗口对象，去除占位符后的净宽高为（IE&lt;=8不支持）<ul><li><code>innerWidth</code></li><li><code>innerHeight</code></li></ul></li><li><code>screen</code>:表示屏幕的信息（宽，高，位宽）</li><li><code>location</code>:当前页面的URL信息<ul><li><p><code>location.href</code>:当前页面的URL</p></li><li><p><code>setInterval</code>持续重复执行该函数。</p></li><li><p><code>setTimeout</code>在等待指定的毫秒数后执行函数。</p></li></ul></li></ul><p><strong>Cookie</strong></p><div class="note note-secondary">            <p>浏览器用来存储小块数据（最多约 4KB）的一种机制。它可以在用户浏览网页时，在本地保存数据，并在之后访问时自动携带到服务器。</p>          </div><p>我们登录了一个网站，关闭网页后第二天再来，不用重新登录了，就是因为Cookie。</p><h1 id="dom">DOM</h1><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document ObjectModel）。</p><p>HTML DOM 模型被结构化为对象树：</p><figure><img src="https://www.w3school.com.cn/i/ct_htmltree.gif"alt="https://www.w3school.com.cn/js/js_htmldom.asp" /><figcaptionaria-hidden="true">https://www.w3school.com.cn/js/js_htmldom.asp</figcaption></figure><p>通过<code>document</code>对象的方法可以找到对象树上的节点，常用的有：</p><ul><li><code>getElementById()</code></li><li><code>getElementsByTagName()</code></li></ul><h2 id="更新">更新</h2><p>获取对象后，可以对对象进行操作：</p><ul><li><code>innerHTML</code></li><li><code>innerText</code></li><li><code>textContent</code></li></ul><p>也可以修改css样式（和css的命名方式不一样）</p><ul><li><code>.style.color</code></li><li><code>.style.fontSize</code></li><li><code>.style.paddingTop</code></li></ul><p>格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id).<span class="hljs-property">style</span>.<span class="hljs-property">property</span> = newstyle<br></code></pre></td></tr></table></figure><h2 id="插入">插入</h2><ul><li><code>appendChild</code></li><li><code>insertBefore</code> ## 删除</li></ul><p>父节点调用<code>removeChild</code>删除子节点</p><h1 id="async">Async</h1><h2 id="回调">回调</h2><p>回调函数（Callback Function），将一个函数作为参数传递给另一个参数</p><h1 id="js事件">JS事件</h1><p>事件绑定的方式：</p><ul><li>通过HTML中的事件属性。例如<code>&lt;button onclick="displayDate()"&gt;试一试&lt;/button&gt;</code></li><li>通过DOM分配事件，例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>).<span class="hljs-property">onclick</span> = displayDate;<br>&lt;/script&gt; <br></code></pre></td></tr></table></figure><h2 id="事件监听">*事件监听</h2><div class="note note-secondary">            <p>在 JavaScript 中，事件监听（Event Listener） 是指你为一个 HTML元素绑定一个函数（监听器），当某个事件发生时（比如点击、键盘输入、鼠标悬停等），这个函数就会被自动调用。</p>          </div><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(event, <span class="hljs-keyword">function</span>, useCapture);<br></code></pre></td></tr></table></figure><ul><li>事件类型</li><li>事件发生时调用的函数</li><li>布尔值，指定事件是使用冒泡还是事件捕获，可选参数，默认是冒泡阶段（用得很少）</li></ul><p>可以向一个元素添加多个事件处理程序。</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid博客美化记录</title>
    <link href="/2025/04/20/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%962/"/>
    <url>/2025/04/20/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%962/</url>
    
    <content type="html"><![CDATA[<p>简单的博客美化记录 <span id="more"></span></p><h1 id="美化清单">美化清单</h1><ol type="1"><li><a href="#添加博客加载页面">添加博客加载页面</a></li><li><a href="#github状态和活跃曲线">Github状态和活跃曲线</a></li><li><a href="#mac风格代码块">mac风格代码块</a></li><li><a href="#艺术字签名">艺术字签名</a></li><li><a href="#更换图床">更换图床</a></li><li><a href="#遗留问题">遗留问题</a></li></ol><h1 id="添加博客加载页面">添加博客加载页面</h1><p>Fluid主题本身是不支持固定背景图的，强行固定会导致加载页面时明显观察到背景图“瞬移”，而且不适配移动端。</p><p>现在移动端我先不管了，这里通过添加加载页面的方式规避背景图瞬移的问题。</p><p>代码源自该<ahref="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-loading/fluid-loading/">实例</a></p><p>关于第一步，“在bodyBegin注入元素代码”，即把下面这段代码加到博客目录下的<code>\Blogs\node_modules\hexo-theme-fluid\layout\layout.ejs</code>的<code>&lt;body&gt;</code>开头的部分：</p><p><img src="https://i.imgur.com/SGhKbvj.png" /></p><p>剩下的CSS和js代码分别添加到自定义CSS和js文件中即可。</p><h1 id="github状态和活跃曲线">Github状态和活跃曲线</h1><p>项目地址：</p><ul><li><ahref="https://github.com/anuraghazra/github-readme-stats?tab=readme-ov-file">github-readme-stats</a></li><li><ahref="https://github.com/Ashutosh00710/github-readme-activity-graph">github-readme-activity-graph</a></li></ul><p>复制粘贴到关于页即可。</p><h1 id="mac风格代码块">mac风格代码块</h1><p>参考：<ahref="https://qingshaner.com/HexoFluid%E4%B8%BB%E9%A2%98%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/">HexoFluid主题代码块样式修改</a></p><h1 id="艺术字签名">艺术字签名</h1><p>参考链接</p><ul><li><ahref="https://mrna16.github.io/2024/11/14/%E3%80%90Hexo%E3%80%91Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/#%E6%A0%87%E7%AD%BE%E5%8F%98%E5%8C%96">【Hexo】Fluid主题美化</a></li><li><a href="https://4rozen.github.io/archives/Hexo/38001.html">使用 CSS和 JS 实现博客导航栏线条动画效果</a>（这个的讲解更详细）</li></ul><p>签名动画似乎与加载页面不兼容，我没有看到动画效果，所以把动画部分的代码去掉了。</p><p>对<code>sign.css</code>部分:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.svg</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: auto;<br>  &#125;<br>  <br>  <span class="hljs-selector-class">.svg</span> <span class="hljs-selector-tag">path</span> &#123;<br>    <span class="hljs-attribute">stroke</span>: white;<br>    <span class="hljs-attribute">stroke-width</span>: <span class="hljs-number">3pt</span>;<br>    <span class="hljs-attribute">stroke-linecap</span>: round;<br>    <span class="hljs-attribute">stroke-dasharray</span>: <span class="hljs-built_in">var</span>(--l);<br>    <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-built_in">var</span>(--l);<br>    <span class="hljs-attribute">fill</span>: none;<br>    <span class="hljs-attribute">fill-rule</span>: nonzero;<br>    <span class="hljs-attribute">animation</span>: stroke <span class="hljs-number">25s</span> forwards;<br>    -webkit-<span class="hljs-attribute">animation</span>: stroke <span class="hljs-number">25s</span> forwards;<br>  &#125;<br>  <br>  <span class="hljs-keyword">@keyframes</span> stroke &#123;<br>    <span class="hljs-selector-tag">to</span> &#123;<br>      <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>width</code>和<code>height</code>两个属性可以改为<code>100%</code>和<code>auto</code>，我经过尝试发现影响签名大小的主要还是<ahref="https://danmarshall.github.io/google-font-to-svg-path/">GoogleFont to SvgPath</a>的Size数值，所以不用纠结宽和高到底应该填多少了，直接自适应。这里Size取的是35。</p><p><code>sign.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  navbarBrand  =  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container a&#x27;</span>);<br><br>navbarBrand.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;object type=&quot;image/svg+xml&quot; data=&quot;/img/banyee&#x27;s Blog.svg&quot;&gt;&lt;/object&gt;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-comment">// const  paths  =  document.querySelector(&#x27;.container .navbar-brand .svg .g path&#x27;)</span><br><br><span class="hljs-comment">// const  len  =  paths.getTotalLength()</span><br><br><span class="hljs-comment">// paths.style.setProperty(&#x27;--l&#x27;, len)</span><br></code></pre></td></tr></table></figure><p>动画部分的代码已经被注释。另外，引入<code>.svg</code>文件时可以用上面的这种方法，先把svg文件下载到source目录下的一个img文件夹中，再引用，这样可以让代码看起来简洁一些。</p><h1 id="更换图床">更换图床</h1><p>之前用的一直是imgur，国外的老牌免费图床网站，稳定安全可靠。但是被墙了，至于为什么被墙啊俺也不知道</p><p>鉴于国内用户无法访问托管在imgur上的图片，所以我打算换个图床</p><p>一开始打算打算使用腾讯COS存储，主要是冲着访问速度快+长期稳定去的，跟着<ahref="https://cloud.tencent.com/developer/article/1834573">教程</a>走了几步，到了要绑定域名的时候</p><p><img src="https://i.imgur.com/5nHrB3T.png" /></p><p>本来想着来都来了，那就备案啊，然后备案需要实名认证。。。</p><p>这时候我才意识到貌似国内的域名都要备案之后才能使用。</p><p>然后我又尝试了SM.MS图床，这个图床的来历：</p><figure><img src="https://i.imgur.com/4RJjAug.png"alt="SM.MS诞生于互联网精神" /><figcaption aria-hidden="true">SM.MS诞生于互联网精神</figcaption></figure><p>然后我试着访问了主站</p><p><img src="https://i.imgur.com/BOutTZH.png" /></p><blockquote><p>"Due to network issues, users from China Mainland are unable toaccess SM.MS, we have added an alternate domain name smms.app"</p></blockquote><p>又被大陆墙了，而且这个图床已经关闭了注册功能</p><p>最后我转向了<ahref="https://imgse.com/page/about">路过图床</a>。这个图床也是蛮幽默的，注册时如果挂着VPN，会马上触发安全机制：</p><p><img src="https://i.imgur.com/bfFspUp.png" /></p><p>不过这个图床已经稳定运行了14年，最大支持10M的图片，同时具有全球 CDN加速以确保高速、稳定。暂时就先用着这个好了。</p><p>向路过图床上传图片的时候也要求关闭VPN代理，所以最好的办法就是直接在clash新建规则，检测到imgse关键词就走直连</p><p><img src="https://s21.ax1x.com/2025/04/21/pE5lxs0.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-Stream API详解</title>
    <link href="/2025/04/18/java11/"/>
    <url>/2025/04/18/java11/</url>
    
    <content type="html"><![CDATA[<p>参考：<ahref="https://www.bilibili.com/video/BV1Vi421C73n/?spm_id_from=333.1387.list.card_archive.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9">Java中的流、并行流</a></p><p>本博文为视频内容的简单梳理。</p><h1 id="目录">目录</h1><h1 id="引入">引入</h1><p>已知一个列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Person&gt; people = List.of(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>检查所有人的信息，找出年龄大于18岁的人。</p><p><strong>命令式编程</strong>，使用for循环依次检查每一个人的信息，将年龄超过十八岁的人添加到新的名单中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-comment">//创建新的列表用来存放结果</span><br>    List&lt;Person&gt; adults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(Person p : people) &#123;<br>        <span class="hljs-keyword">if</span>(p.getAge() &gt; <span class="hljs-number">18</span>) &#123;<br>            adults.add(p);<br>        &#125;<br>    &#125;<br>    System.out.println(adults);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>Stream API</strong>可以实现相同的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    List&lt;Person&gt; adults = people.stream()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<br>            .toList();<span class="hljs-comment">//或者.collect(Collectors.toList());</span><br>    System.out.println(adults);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码更加简洁。</p><p>Stream本身并不是数据结构，不会处理数据或改变数据源，它仅定义处理方式。不仅能够支持顺序处理，还能进行并行处理。</p><p><strong>Java的Stream只能使用一次</strong>，一旦你调用了终结操作（比如.forEach()、.collect() 等），这个流就被“消费掉”了，不能再用。</p><p><strong>三个步骤</strong>：</p><ul><li><strong>创建流</strong> Stream Creation</li><li><strong>中间操作</strong> Intermediate Operations<ul><li>中间操作是惰性执行的，只有遇到终端操作才会实际执行。</li></ul></li><li><strong>终端操作</strong> Terminal Operations<ul><li>整个流的实际处理部分，他会触发之前所有定义中的中间操作，生成最终结果。</li></ul></li></ul><p><img src="https://i.imgur.com/Pxty23E.png" /></p><p>下面从这三个方面进行分析。</p><h1 id="创建流">创建流</h1><p>对于任何实现了<code>Collection</code>接口的集合，可以通过<code>stream()</code>方法直接创建流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(array);<br><br>stream.forEach(System.out::println);<br><br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Stream&lt;String&gt; myStream = list.stream();<br>myStream.forEach(System.out::println);<br><br><span class="hljs-comment">//更直接的方法</span><br>Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure><hr /><p>采用上述方法创建的stream对象自诞生之初就是写死的，无法修改。想要<strong>动态创建流</strong>，需要使用<code>Stream.Builder</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建对象</span><br>Stream.Builder&lt;String&gt; builder = Stream.builder();<br><span class="hljs-comment">//添加元素</span><br><span class="hljs-comment">//添加后无法删除</span><br>builder.add(<span class="hljs-string">&quot;a&quot;</span>);<br>builder.add(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//也可根据条件动态添加</span><br><span class="hljs-keyword">if</span>(Math.random()&lt;<span class="hljs-number">0.5</span>)&#123;<br>    builder.add(<span class="hljs-string">&quot;c&quot;</span>);<br>&#125;<br><span class="hljs-comment">//通过build方法来创建stream对象</span><br>Stream&lt;String&gt; stream = builder.build();<br><span class="hljs-comment">//一旦调用了build就不能再添加元素，否则执行时报错</span><br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr /><p>使用Stream也可<strong>从文件创建流</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\develop\\code\\Practice\\chapter0\\hello_copy.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path))&#123;<br>        lines.forEach(System.out::println);<span class="hljs-comment">//输出到控制台</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Files.lines(path, StandardCharsets.UTF_8)</code>返回一个惰性读取的Stream，可以逐行读取文本文件内容。</li><li><code>try-with-resources</code>保证资源及时关闭</li></ul><hr /><p>StreamAPI也提供了<code>IntStream</code>等类用来方便地创建<strong>基本数据类型的流</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//通过boxed可以把基本数据类型的流转换为对象流：</span><br>Stream&lt;Integer&gt; integerStream = intStream.boxed();<br></code></pre></td></tr></table></figure><hr /><p>Stream.iterate可生成<strong>无限流</strong>（通常用limit限制生成的个数）：</p><p><strong>语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">iterate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T seed, <span class="hljs-keyword">final</span> UnaryOperator&lt;T&gt; f)</span><br></code></pre></td></tr></table></figure><ul><li><code>seed</code>:初始值</li><li><code>f</code>：作用于初始值的函数</li><li>返回值：一个新的Stream类型的序列</li></ul><p>增强型：<code>public static&lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</code>，其中<code>hasNext</code>是终止条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成一个等差数列</span><br>   Stream.iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr /><p><strong>并行流</strong>：把数据分成多个部分，并“同时”用多个线程来处理，从而加快处理速度。</p><ul><li>对于集合，调用<code>list.parallelStraem()</code>可以直接得到一个并行流。例如<code>List.of("a", "b", "c", "d", "e", "f").parallelStream().forEach(System.out::println);</code>，输出是<strong>乱序</strong>的</li><li>对于已有的Stream，可以调用<code>.parallel()</code>得到并行流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;Integer&gt; iterateStream = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">1</span>).limit(<span class="hljs-number">5</span>);<br>    iterateStream.parallel();<br>    iterateStream.forEach(System.out::println);<br>    <span class="hljs-comment">//这时的打印顺序也是乱的，因为forEach是并发的。</span><br>    <span class="hljs-comment">//forEachOrdered可以保证顺序。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="中间操作">中间操作</h1><p>中间操作用于对流中的元素进行处理，如筛选、排序等等。根据操作的性质可以分为以下几个类别：</p><ul><li><strong>筛选和切片</strong>(Filtering andSlicing):过滤或缩减流中的元素的数量</li><li><strong>映射</strong>(Mapping):转换流中的元素或提取元素的特定属性</li><li><strong>排序</strong>(Sorting)</li></ul><figure><img src="https://i.imgur.com/naZpiDN.png" alt="中间操作图解" /><figcaption aria-hidden="true">中间操作图解</figcaption></figure><h2 id="筛选和切片">筛选和切片</h2><p>例如开头处提到的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Person&gt; adults = people.stream()<br>        .filter(myperson -&gt; myperson.getAge() &gt; <span class="hljs-number">18</span>)<br>        .toList();<span class="hljs-comment">//或者.collect(Collectors.toList());</span><br></code></pre></td></tr></table></figure><p><strong>过滤器定义</strong>:</p><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></p><p>Predicate即<strong>判断条件函数</strong>，用lambda写出，返回布尔值。意思是:<em>给我一个叫myperson 的参数，判断这个人年龄是否大于 18，返回一个 true/false结果</em>。<code>myperson</code>的类型由前文自动推断出，所以省略。</p><p>这里等价于用更简洁的形式实现了<code>Predicate</code>接口的抽象方法<code>boolean test(T t);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;Person&gt; predicate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">return</span> person.getAge() &gt; <span class="hljs-number">18</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>可以用<code>.distinct()</code>为流中的元素<strong>去重</strong>，底层通过维护一个HashSet实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>    Stream.of(<span class="hljs-string">&quot;Origami&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>)<br>            .distinct()<br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是自定义的类的对象，需要确保正确地重写了<code>equals()``HashCode</code>方法，因为HashSet就是通过这两个方法判断元素是否相等。</p><hr /><p>Stream类中定义的<code>Stream&lt;T&gt; limit(long maxSize);</code>方法返回由此流的元素组成的截断长度不超过maxSize的流。</p><p>同样，<code>Stream&lt;T&gt; skip(long n);</code>跳过前n个元素。</p><p>limit和skip在有序的并行流中使用时可能会使性能变差，此时可以用<code>.unordered()</code> 提高效率；如果顺序必须保留，那最好使用顺序流<code>.sequential()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;Integer&gt; s1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    s1.limit(<span class="hljs-number">5</span>).forEach(System.out::print);<br><br>    Stream&lt;Integer&gt; s2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    s2.skip(<span class="hljs-number">5</span>).forEach(System.out::print);<br>    <span class="hljs-comment">//打印结果：12345678910</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射">映射</h2><p>映射本质上是一个数据转换的过程</p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends R&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p><code>T</code>是Stream中元素的类型，<code>R</code>新的流的元素类型</p><p>map能够通过提供的函数<code>Function</code>将流中的每个元素转换成新的元素，最后生成一个新元素构成的流。</p><p>map接受的是一个<strong>函数式接口</strong>。</p><figure><img src="https://i.imgur.com/Yk5xhTe.png"alt="利用映射层层提取数据的过程" /><figcaption aria-hidden="true">利用映射层层提取数据的过程</figcaption></figure><p>示例：利用映射获得Person列表中所有人的name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br><br>    Stream&lt;Person&gt; peopleStream = people.stream();<br>    <span class="hljs-comment">//peopleStream.map(myperson -&gt; myperson.getName()).forEach(System.out::println);</span><br>    <span class="hljs-comment">//方法引用的格式：类名或对象名::方法名</span><br>    peopleStream.map(Person::getName).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Neo<br>Blu<br>Alex<br>Bob<br>Kurumi<br>Kurumi<br></code></pre></td></tr></table></figure><hr /><p><code>map</code>结构适用于<strong>单层结构</strong>的流，进行元素<strong>一对一</strong>的转换。</p><p>对于嵌套的集合，数组等等，适合使用<code>flatMap</code>。</p><p><img src="https://i.imgur.com/sq8UWmE.png" /></p><p><strong>定义</strong>：<code>Stream.java</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p>示例：将嵌套List转换成的流扁平化为单层流打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test7</span><span class="hljs-params">()</span> &#123;<br>    List&lt;List&lt;Person&gt;&gt; peopleGroups = List.of(<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;neo&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Stan&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;USA&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Grace&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;UK&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">17</span>, <span class="hljs-string">&quot;UK&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>)<br>            )<br>    );<br><br>    Stream&lt;List&lt;Person&gt;&gt; peopleGroupStream = peopleGroups.stream();<br>    <span class="hljs-comment">//转换成单层流  扁平化  单一化</span><br>    Stream&lt;Person&gt; personStream = peopleGroupStream.flatMap(people -&gt; people.stream());<br>    personStream.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>流操作返回的是一个新的流，原始流在第一次操作后就会被标记为已操作，不能再次进行操作。实际应用中通常会采用<strong>链式操作</strong>:</p><p><img src="https://i.imgur.com/lZ0Yc3R.png" /></p><p>嵌套流 -&gt; 单层流 -&gt; 提取name属性 -&gt; 打印</p><hr /><p><code>mapToInt</code>可以将对象流转换为基础类型的流<code>IntStream</code>。</p><hr /><h2 id="排序">排序</h2><p>当流中的元素类型实现了<code>Comparable</code>接口时（自然排序），可直接调用<code>sorted()</code>。</p><p>定制排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test10</span><span class="hljs-params">()</span> &#123;<br>    Stream.of(<span class="hljs-string">&quot;blueberry&quot;</span>, <span class="hljs-string">&quot;greenberry&quot;</span>, <span class="hljs-string">&quot;redberry&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)<br>            .sorted(Comparator.comparingInt(String::length).reversed())<br>            .forEach(System.out::println);<br>            <span class="hljs-comment">//年龄降序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>Comparator.comparingInt(String::length).reversed()</code>:</p><ul><li><code>comparingInt</code>是Comparator的一个方法</li><li>相当于<code>Comparator.comparingInt(p -&gt; p.getAge())</code>，将Age作为排序的标准</li><li><code>comparingInt</code>和<code>reversed()</code>并列定义，但是前者返回的仍然是一个<code>Comparator&lt;T&gt;</code>对象，后者是一个Comparator的默认方法，只要是<code>Comparator&lt;T&gt;</code>的对象就可以调用它。</li></ul><hr /><p>中间操作只是定义了操作的规则，并不会立即执行，常常用变量保存和传递。</p><p>综合练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    List&lt;List&lt;Person&gt;&gt; peopleGroups = List.of(<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;neo&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Stan&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;USA&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Grace&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;UK&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;UK&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>)<br>            )<br>    );<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扁平化、去重、年龄大于18、映射到name、按照名字的长度排序</span><br><span class="hljs-comment">     */</span><br>    Stream&lt;String&gt; s= peopleGroups.stream()<br>            .flatMap(List::stream)<br>            .distinct()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<span class="hljs-comment">//筛选</span><br>            .map(Person::getName)<br>            .sorted(Comparator.comparing(String::length));<span class="hljs-comment">//映射为字符串类型的名字之后再按照字符串的长度排序;</span><br>    <br>    <span class="hljs-comment">//触发执行操作</span><br>    s.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="终端操作">终端操作</h1><p>终端操作是流处理的最终步骤，实弹发生，流中的元素被消费，流不能再被使用。</p><p>终端操作包括查找与匹配、聚合操作、归约操作、收集操作、迭代操作。</p><p><img src="https://i.imgur.com/mg7OIu4.png" /></p><h2 id="查找与匹配">查找与匹配</h2><p>属于短路操作(Short-circuitingOperations),也就是说这些操作在找到所需的元素后会立即返回结果,不会遍历整个流.</p><ul><li><code>anyMatch</code>:如果流中任意元素满足给定的条件则返回true</li><li><code>noneMatch</code>:与前者相反</li><li><code>allMatch</code>:所有的都满足才会返回true</li></ul><hr /><ul><li><code>Optional&lt;T&gt; findFirst();</code>找到流中的第一个元素,类型为<code>Optional</code>.因为返回的元素可能为空,这样做的话更加安全.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    Optional&lt;Person&gt; optionalPerson = people.stream().findFirst();<br>    <span class="hljs-comment">//ifPresent:如果值存在，就执行括号里的操作，否则什么也不做.</span><br>    optionalPerson.ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;<br></code></pre></td></tr></table></figure><ul><li><code>findAny</code>:返回任意一个元素</li></ul><h2 id="聚合操作">聚合操作</h2><ul><li><code>long count();</code>:计算元素的数量</li><li><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</code>:返回流中的最大元素,需要提供一个比较器.</li><li>同理还有<code>min</code></li></ul><hr /><ul><li><code>sum()</code>用于求和,只能处理基本数据类型的流,所以使用之前要进行流类型的转换.</li><li><code>average</code>同上</li></ul><p>本质上聚合操作是归约操作的一种特殊形式,适合快速简单的统计任务.归约操作reduce更加通用.</p><h2 id="归约操作">归约操作</h2><p>整型的reduce定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(<span class="hljs-type">int</span> identity, IntBinaryOperator op)</span>;<br></code></pre></td></tr></table></figure><p>Java提供的注解:</p><blockquote><p>对该流的元素执行归约操作，使用提供的标识值（identity）和一个关联的累积函数（accumulationfunction），并返回归约后的结果。其等价于以下代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> identity;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : <span class="hljs-built_in">this</span> stream)<br>    result = accumulator.applyAsInt(result, element)<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>即,先把 identity的值赋给结果,然后再使用累计函数对结果和流中的元素进行运算.<br />这种归约不一定按顺序执行（即它可以并行处理）。<br />identity必须是一个<strong>恒等元</strong>,也就是说累计函数作用在它身上之后的结果仍然等于它本身.例如:<br />加法的恒等元是0,因为 0 + x = x<br />乘法的恒等元是1,因为1 * x = x<br />此外，累积函数必须是<strong>可结合的</strong>（associative）函数,也就是符合结合律,计算顺序不影响结果.</p></blockquote><p><strong>形参</strong>:</p><ul><li><code>identity</code>:累积函数的恒等元</li><li><code>op</code>:一个可结合的,无副作用(函数在处理值时不应该修改外部状态)的,无状态的函数</li></ul><p><strong>返回值</strong>:归约的结果</p><p>对一个流中的所有元素求和,可以写为<code>int sum = integers.reduce(0, (a, b) -&gt; a+b);</code><br />或者更简洁一点<code>int sum = integers.reduce(0, Integer::sum);</code></p><p>虽然相比于在循环中直接修改一个运行中的总和变量，这种方式看起来有些绕远路，但归约（reduction）操作在并行化时表现得更加优雅，无需额外的同步（synchronization），并且大大降低了数据竞争（dataraces）的风险。</p><hr /><p>例:对流的所有元素的年龄求和,然后输出所有人名字的串接字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-comment">//计算年龄的和</span><br>    <span class="hljs-type">IntStream</span> <span class="hljs-variable">doubleStream</span> <span class="hljs-operator">=</span> people.stream().mapToInt(Person::getAge);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> doubleStream.reduce(<span class="hljs-number">0</span>, (a,b) -&gt; (a + b));<br>    System.out.println(sum);<br><br>    <span class="hljs-comment">//将所有人的名字串接起来</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>            .map(Person::getName)<br>            .reduce(<span class="hljs-string">&quot;&quot;</span>, (a, b) -&gt; a + b);<br>    System.out.println(joinedName);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">86<br>NeoBluAlexBobKurumi<br></code></pre></td></tr></table></figure><h2 id="收集操作">收集操作</h2><p>把流处理后的元素汇集到新的数据结构中, 比如列表, map, 集合等等.</p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; R <span class="hljs-title function_">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-built_in">super</span> T, A, R&gt; collector)</span>;<br></code></pre></td></tr></table></figure><p><code>Collectors.java</code>中提供了丰富的<strong>静态方法</strong>用作collector参数.如<code>toList</code>,<code>toMap</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//收集年龄大于18岁的人</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    List&lt;Person&gt; adults = people.stream()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<br>            .collect(Collectors.toList());<span class="hljs-comment">//使用Collectors提供的方法</span><br>    System.out.println(adults);<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>分组</strong>:<code>Collectors</code>类提供的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br> groupingBy(Function&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>&gt; classifier) &#123;<br>     <span class="hljs-keyword">return</span> groupingBy(classifier, toList());<br> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code>:流中元素的类型,例如<code>Person</code></li><li><code>K</code>:用于分组的键的类型</li><li><strong>形参</strong>:<code>classifier</code>,将输入元素映射到键的分类器函数</li><li><strong>返回值</strong>:实现分组操作的收集器,将<code>Stream&lt;T&gt;</code>收集成一个<code>Map&lt;K, List&lt;T&gt;&gt;</code>.<ul><li>key:由classifier生成</li><li>value:分到该组的<code>T</code>元素组成的列表</li></ul></li></ul><p>示例:根据国家分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    Map&lt;String, List&lt;Person&gt;&gt; collect = people.stream()<br>            .collect(Collectors.groupingBy(Person::getCountry));<br>    collect.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; = &quot;</span> + v));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code>在这里即<code>Person</code></li><li>这里的分类器是<code>(Person::getCountry)</code>,所以键的类型是<code>String</code></li><li>最终得到的Map泛型为<code>Map&lt;String, List&lt;Person&gt;&gt;</code></li></ul><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">USA = [Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;]<br>Japan = [Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;]<br>China = [Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;]<br>Germany = [Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;]<br></code></pre></td></tr></table></figure><hr /><p><strong>分区</strong>功能同理,调用<code>Collectors.partitioningBy</code>即可,不过这时传入的是一个条件判断式, map的第一个参数也变成了boolean变量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Person&gt;&gt; agePartition = people.stream()<br>                .collect(Collectors.partitioningBy(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>));<br>        agePartition.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; = &quot;</span> + v));<br></code></pre></td></tr></table></figure><hr /><p><code>Collectors</code>也提供了拼接字符串的方法<code>joining</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>        .map(Person::getName)<br>        .collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>System.out.println(joinedName);<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Neo,Blu,Alex,Bob,Kurumi<br></code></pre></td></tr></table></figure><p>也可以用<code>Collectors.joining</code>连接字符串.</p><hr /><p>使用<code>Collectors.summarizingInt</code>可以<strong>汇总</strong>指定的数据,返回类型为<code>IntSummaryStatistics</code>,使用<code>IntSummaryStatistics</code>的<code>get</code>方法可以快速获取最大值,最小值, 平均值等等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test7</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>            .map(Person::getName)<br>            .collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<span class="hljs-comment">//输出合并的字符串</span><br>    System.out.println(joinedName);<br><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> people.stream()<br>            .collect(Collectors.summarizingInt(Person::getAge));<br>    <span class="hljs-comment">//打印collect的所有属性(数量,和,最小值,平均值,最大值)</span><br>    System.out.println(collect);<br>    <span class="hljs-comment">//指定获取最大值</span><br>    System.out.println(collect.getMax());<br>    <span class="hljs-comment">//指定获取最小值</span><br>    System.out.println(collect.getMin());<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>自定义收集器</strong></p><p><code>Collector.of(...)</code>的五个参数结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Collector.of(<br>    Supplier&lt;R&gt; supplier,                         <span class="hljs-comment">// 创建中间结果容器</span><br>    BiConsumer&lt;R, T&gt; accumulator,                <span class="hljs-comment">// 如何添加元素</span><br>    BinaryOperator&lt;R&gt; combiner,                  <span class="hljs-comment">// 合并两个部分结果</span><br>    Function&lt;R, R&gt; finisher,                     <span class="hljs-comment">// 最终变换结果（可选）</span><br>    Collector.Characteristics... characteristics <span class="hljs-comment">// 特征标记</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customTest</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    ArrayList&lt;Person&gt; collect = people.stream()<span class="hljs-comment">//.parallel()</span><br>            .collect(Collector.of(<br>                    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-comment">//创建空容器</span><br>                    (list, person) -&gt; &#123;      <span class="hljs-comment">//累加器逻辑把一个 person 添加到当前线程维护的 list 里</span><br>                        System.out.println(<span class="hljs-string">&quot;Accumulator: &quot;</span> + person);<br>                        list.add(person);<br>                    &#125;,<br>                    (left, right) -&gt; &#123;       <span class="hljs-comment">//合并多个线程的中间结果,只在并行流起作用</span><br>                        System.out.println(<span class="hljs-string">&quot;Combiner: &quot;</span> + left);<br>                        left.addAll(right);<br>                        <span class="hljs-keyword">return</span> left;<br>                    &#125;,<br>                    Collector.Characteristics.IDENTITY_FINISH<span class="hljs-comment">//表示不需要变换,中间操作的结果就是最终结果</span><br>            ));<br>    System.out.println(collect);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Accumulator: Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;<br>[Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;, Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;, Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;]<br><br></code></pre></td></tr></table></figure><p>（这一块没看太懂，先放到这里以后再来看）</p><h1 id="并行流">并行流</h1><p>Parallel Streams</p><p>能够借助<strong>多核处理器</strong>的<strong>并行计算能力</strong>加速数据处理,特别适合大型数据集或计算密集型任务.</p><h2 id="工作原理">工作原理</h2><ul><li>并行流在开始时, Spliterator分割迭代器将数据分割成多个片段,分割过程通常采用递归的方式动态进行, 以此平衡子任务的工作负载,提高资源利用率.</li><li>然后Fork/Join框架将这些数据片段分配到多个线程和处理器核心上进行并行处理.</li><li>处理完成后, 结果将会被汇总合并,其核心是[任务的分解Fork]和[结果的合并Join]</li><li>无论是并行流还是顺序流.二者都提供相同的中间操作和终端操作,也就是说我们可以采用几乎相同的方式进行数据处理和结果收集</li></ul><figure><img src="https://i.imgur.com/MMyKgBt.png" alt="并行流的工作原理" /><figcaption aria-hidden="true">并行流的工作原理</figcaption></figure><h2 id="foreach-foreachordered">forEach &amp; forEachOrdered</h2><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; Example = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>    Example.parallelStream()  <span class="hljs-comment">//并行流</span><br>            .map(String::toLowerCase)  <span class="hljs-comment">//转换为小写</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出的字母是乱序的, 而且每次都不一样.</p><p>不像顺序流的执行是单线程的, 并行流采用多线程并发处理,不保证元素的处理顺序.用<code>forEachOrdered</code>可以保证元素的出现顺序,这归功于Spliterator和Fork/Join框架的协作:</p><ul><li><p>在处理并行流时, 对于有序的数据源,Spliterator会对数据源进行递归分割, 通过划分数据源的索引范围来实现.每次分割都会产生一个新的Spliterator实例,其内部维护了指向原数据的索引范围,这种分割机制可以让数据的出现顺序得以保持.</p></li><li><p>然后, Fork/Join框架接手, 将分配后的数据块分配给不同的子任务执行.对于forEachOrdered操作,框架依据Spliterator维护的顺序信息来调度方法的执行顺序. 所以,就算某个子任务提前完成了, 如果跟它关联的顺序还没到来, 系统将缓存该顺序,并暂停执行该方法, 直到所有前序的任务都已经完成.</p></li><li><p>上述机制确保了即使是并行处理也能保证原始的出现顺序,代价是牺牲了一些并行执行的效率.</p></li><li><p>对于<code>forEach</code>,Fork/Join会<strong>忽略顺序的信息</strong>, 能够提高执行效率.</p></li><li><p>forEach会在不同的线程上独立进行, 所以如果操作的是共享资源,必须确保这些操作是<strong>线程安全</strong>的(同步).所以<code>forEach</code>更适合执行无状态操作或资源独立的场景.</p></li></ul><p>一个关于多线程的测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 并行流的多线程</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>     List&lt;String&gt; Example = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>     Example.parallelStream().forEach(item -&gt; &#123;<br>         <span class="hljs-comment">//打印正在处理的元素和对应的线程</span><br>         System.out.println(<span class="hljs-string">&quot;Item: &quot;</span> + item + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());<br>     &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Item: E-&gt;Thread: main<br>Item: D-&gt;Thread: main<br>Item: G-&gt;Thread: main<br>Item: A-&gt;Thread: main<br>Item: F-&gt;Thread: ForkJoinPool.commonPool-worker-2<br>Item: B-&gt;Thread: ForkJoinPool.commonPool-worker-1<br>Item: C-&gt;Thread: ForkJoinPool.commonPool-worker-2<br></code></pre></td></tr></table></figure><ul><li><code>main</code>:主线程</li><li><code>ForkJoinPool.commonPool-worker-x</code>:后台线程池中的工作线程</li></ul><h2 id="collect收集">collect收集</h2><p>List使用<code>collect</code><strong>收集</strong>输出结果,最终合并得到的列表仍为<strong>有序</strong>(与第一个demo不同)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * List并行流为有序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; collect = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>).parallelStream()<br>            .map(String::toLowerCase)     <span class="hljs-comment">//转换为小写</span><br>            .collect(Collectors.toList());<span class="hljs-comment">//收集不同线程的结果,合并为列表</span><br>    System.out.println();<br>    System.out.println(collect);<span class="hljs-comment">//输出为[a, b, c, d, e, f, g]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>自定义收集器</strong>演示有序列表<code>List</code>在并行流的情况下合并后仍有序输出的过程:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; collect = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>).parallelStream()<br>            .map(String::toLowerCase)<br>            .collect(Collector.of(<br>                    () -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Supplier: new ArrayList&quot;</span> + <span class="hljs-string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    &#125;,<br>                    (list,item) -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Accumulator: &quot;</span> + item + <span class="hljs-string">&quot; Thread: &quot;</span> + Thread.currentThread().getName());<br>                        list.add(item);<br>                    &#125;,<br>                    (left, right) -&gt; &#123;<span class="hljs-comment">//并行流需要有效地合并不同线程的处理结果</span><br>                        System.out.println(<span class="hljs-string">&quot;Combiner: &quot;</span> + left + <span class="hljs-string">&quot; &quot;</span> + right + <span class="hljs-string">&quot; Thread: &quot;</span> + Thread.currentThread().getName());<br>                        left.addAll(right);<br>                        <span class="hljs-keyword">return</span> left;<br>                    &#125;,<br>                    Collector.Characteristics.IDENTITY_FINISH<br>            ));<br>    System.out.println(collect);<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>打印内容:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Supplier: new ArrayListThread: main<br>Accumulator: c Thread: main<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-1<br>Accumulator: b Thread: ForkJoinPool.commonPool-worker-1<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-2<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-1<br>Accumulator: e Thread: ForkJoinPool.commonPool-worker-2<br>Accumulator: d Thread: ForkJoinPool.commonPool-worker-1<br>Supplier: new ArrayListThread: main<br>Accumulator: a Thread: main<br>Combiner: [d] [e] Thread: ForkJoinPool.commonPool-worker-1<br>Combiner: [a] [b] Thread: main<br>Combiner: [c] [d, e] Thread: ForkJoinPool.commonPool-worker-1<br>Combiner: [a, b] [c, d, e] Thread: ForkJoinPool.commonPool-worker-1<br>[a, b, c, d, e]<br></code></pre></td></tr></table></figure><p>如果使用<code>Set</code>, 则结果仍然是无序的,这是由<strong>数据结构本身</strong>的特点决定的,Spliterator和Fork/Join框架的分割合并策略并没有什么不同.</p><h2 id="unordered-concurrent">UNORDERED &amp; CONCURRENT</h2><p><strong>UNORDERED</strong></p><p>即便Colector被标记为<code>UNORDERED</code>,如果数据源或流操作本身是有序的,系统的执行策略通常仍会保持这些元素的出现顺序.只有在特定场景下系统才会针对那些被标记为<code>UNORDERED</code>的流进行优化从而打破顺序的约束.</p><p><strong>CONCURRENT</strong></p><ul><li>在标准的并行流处理中, 每个线程处理数据的一个子集,维护自己的局部结果容器. 在所有的数据处理完成后,这些局部结果会通过Combiner函数合并成一个最终的结果.</li><li>使用CONCURRENT特性后, 所有线程将<strong>共享同一个结果容器</strong>,而不是维护独立的局部结果, 从而减少了合并的需要.这通常会带来性能上的提升, 特别是合并操作较为复杂时.这时只有一个结果容器,这个容器必须是线程安全的(例如ConcurrentHashMap).</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-FILE类与IO流</title>
    <link href="/2025/04/13/java10/"/>
    <url>/2025/04/13/java10/</url>
    
    <content type="html"><![CDATA[<h1 id="file类的使用">File类的使用</h1><p><strong>位置</strong>：<code>package java.io</code></p><p><strong>构造器</strong>：</p><ul><li><code>public File(String pathname)</code><ul><li><code>pathname</code>可以用绝对路径或相对路径</li></ul></li><li><code>public File(String parent, String child)</code><ul><li><code>parent</code>:父路径名字符串，如果为null则等效于上一种构造器</li><li><code>child</code>:子路径名字符串，如果它是绝对路径则直接忽略父路径名</li><li>如果二者都是相对路径，则把<code>child</code>添加在<code>parent</code>的后面</li></ul></li><li><code>public File(File parent, String child)</code></li></ul><h2 id="方法">方法</h2><p>见<code>File.java</code>（快捷键：<code>Ctrl + N</code>查找类，<code>Ctrl + F12</code>查找当前文件中的方法）。</p><p>例：输出一个目录下的所有文件名（递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printFileName</span><span class="hljs-params">(File file)</span> &#123;<br>    <span class="hljs-keyword">if</span>(file.isFile()) &#123;<br>        System.out.println(file.getName());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>        File[] files = file.listFiles();<span class="hljs-comment">//listFiles()返回当前目录下的所有文件+文件夹</span><br>        <span class="hljs-keyword">for</span> (File f : files) &#123;<br>            printFileName(f);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="io流">IO流</h1><p>IO流就是Java中用来“<strong>读</strong>”和“<strong>写</strong>”数据的通道。</p><ul><li>按数据方向分<ul><li>输入流：读取数据到程序中</li><li>输出流：写数据到外部设备</li></ul></li><li>按数据类型分：<ul><li>字节流：以字节（8bit）为单位，如<code>InputStream</code>，<code>OutputStream</code></li><li>字符流：以字符（长度不定）为单位，如<code>Reader</code>，<code>Writer</code></li></ul></li></ul><p><strong>节点流</strong>是直接与 <strong>数据源</strong> 或<strong>数据目的地</strong> 打交道的流，常用于最底层的 I/O 操作。</p><p><strong>处理流</strong>是“套接”在已有的流（通常是节点流）上，对数据进行<strong>加工处理</strong> 的流。</p><p><strong>注意</strong>：字符流专门用于<strong>处理文本内容</strong>，字节流用于处理<strong>所有类型的数据</strong>（包括文本、图片、视频、音频等）。</p><p>核心类结构图：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CSS">  ┌────────────┐            ┌────────────┐<br>  │ InputStream│ &lt;-------- │ FileInputStream │<br>  └────────────┘            └────────────┘<br>        ▲<br>        │<br><span class="hljs-selector-attr">[处理字节输入]</span><br><br>  ┌────────────┐            ┌────────────┐<br>  │ OutputStream│ &lt;--------│ FileOutputStream│<br>  └────────────┘            └────────────┘<br>        ▲<br>        │<br><span class="hljs-selector-attr">[处理字节输出]</span><br><br>  ┌────────┐             ┌───────────┐<br>  │ Reader │ &lt;--------- │ FileReader │<br>  └────────┘             └───────────┘<br>        ▲<br><span class="hljs-selector-attr">[处理字符输入]</span><br><br>  ┌────────┐             ┌───────────┐<br>  │ Writer │ &lt;--------- │ FileWriter │<br>  └────────┘             └───────────┘<br>        ▲<br><span class="hljs-selector-attr">[处理字符输出]</span><br><br></code></pre></td></tr></table></figure><p>左列：抽象基类<br />右列：节点流（文件流），直接连接数据源和数据目的地。</p><h2 id="filereaderfilewriter">FileReader、FileWriter</h2><p>一般步骤：</p><ol type="1"><li>创建读取或写出的File类实例</li><li>创建输入流或输出流</li><li>具体的读或写的过程<ol type="1"><li>read(char[] cbuffer):int</li><li>write(char[] cbuffer, 0, len):void</li></ol></li><li>关闭流资源</li></ol><p>注意： 1. 处理异常 2. 对于输入流，File类的实例对应的文件必须已经存在3.对于输出流，可以不存在，会自动创建并写入数据到此文件中；如果文件已经存在，则<code>FileWriter(File file, true/false)</code></p><h2id="fileinputstreamfileoutputstream">FileInputStream、FileOutputStream</h2><ol type="1"><li>创建读取或写出的File类对象</li><li>创建输入流或输出流</li><li>具体的读入或写出过程，仍然是read和write</li><li>关闭流资源</li></ol><h2 id="缓冲流">缓冲流</h2><p>4个处理流：</p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul><p>缓冲流的作用：<strong>提升文件读写的效率</strong>。</p><p>直接使用<code>FileInputStream</code>读取文件时，每次 .read()都会和磁盘打交道，这样效率会非常低。而<strong>缓冲流会一次性从底层流中读取大量数据存入内存缓冲区，之后就从内存中读取，提高了效率</strong>。</p><blockquote><p>磁盘 I/O 是非常慢的，如果你每次都去磁盘读 1 字节，CPU会一直等，效率很低。而一次性读取一个 8KB缓冲区，可以极大减少磁盘读取次数，提高程序运行效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将一个文件复制到另一个地方</span><br><span class="hljs-comment">//实际写的时候记得用try-catch</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Neuro.png&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\edge_download\\Neuro.png&quot;</span>);<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dest);<br><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-comment">//bis.read():</span><br>        <span class="hljs-comment">//如果8KB的缓冲区的数据还没读完：从缓冲区中读一个字节返回。</span><br>        <span class="hljs-comment">//如果已经读完了：就会调用底层的输入流（例如 FileInputStream）的 read(byte[] buffer) 方法；</span><br>        <span class="hljs-comment">// 一次性从磁盘中读很多字节（最多8KB），存入缓冲区；然后再从这个缓冲区中读一个字节返回过来。</span><br>        <span class="hljs-comment">//如果底层输入流返回 -1（即文件已经读完了），则 bis.read() 也返回 -1 表示 EOF。</span><br>        <span class="hljs-keyword">while</span>((len = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(len);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Done&quot;</span>);<br><br>        <span class="hljs-comment">//外层的流的关闭可以自动关闭内层的流</span><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BufferedInputStream</code><strong>原理</strong>：</p><ul><li>他有一个内部的<code>byte[]</code>缓冲区，默认大小8192字节</li><li>当调用<code>.read()</code>时，<strong>如果缓冲区有数据</strong>，就直接从缓冲区读；<strong>如果缓冲区空了</strong>，就从底层流中<strong>读取一大块</strong>（比如8192字节）放入缓冲区</li><li>类似地，<code>BufferedOutputStream</code>也是把数据先写入缓冲区，等缓冲区满了或调用<code>.flush()</code>时才真正写到文件。</li></ul><hr /><p>从文本文件读取文本到控制台（一次读一行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//一次性创建流+缓冲流</span><br>        br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br>        String Line;<span class="hljs-comment">//一次读取一行，直到文件结束</span><br>        <span class="hljs-keyword">while</span>( (Line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(Line);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>) br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转换流">转换流</h2><p>转换流（ConversionStreams）是连接<strong>字节流</strong>和<strong>字符流</strong>之间的桥梁，它们的作用是：</p><blockquote><p>将“字节”转换成“字符”，或相反地将“字符”转换成“字节”。</p></blockquote><p>如果能够确认文件的编码格式与你的程序使用的编码一致，那确实可以不显式使用转换流（InputStreamReader/ OutputStreamWriter），直接用字符流 FileReader /FileWriter也是没问题的。</p><table><thead><tr><th>类名</th><th>方向</th><th>用途</th></tr></thead><tbody><tr><td>InputStreamReader</td><td>字节 → 字符</td><td>把字节输入流转换成字符输入流（读文件）</td></tr><tr><td>OutputStreamWriter</td><td>字符 → 字节</td><td>把字符输出流转换成字节输出流（写文件）</td></tr></tbody></table><p>举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将gbk格式的文件转换为utf-8格式的文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;GB18030.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;GB18030_to_utf8.txt&quot;</span>);<br><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file1);<br>    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis,<span class="hljs-string">&quot;GB18030&quot;</span>);<span class="hljs-comment">//使用gbk格式解码</span><br><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file2);<br>    <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(fos,<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//把解码得到的字符以utf8输出为字节</span><br><br>    <span class="hljs-comment">//读写过程</span><br>    <span class="hljs-type">char</span>[] cBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span>((len = isr.read(cBuffer)) != -<span class="hljs-number">1</span>)&#123;<br>        osw.write(cBuffer,<span class="hljs-number">0</span>,len);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;OVER&quot;</span>);<br><br>    isr.close();<br>    osw.close();<span class="hljs-comment">//关闭缓冲流后，缓冲的数据才会被真正写入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<code>OutputStreamWriter</code><strong>也是带缓冲的流</strong>，只有当缓冲区满了或者调用<code>flush()</code>或者关闭流时，才会向硬盘中写入数据。<code>.write()</code>方法只是写到了它的缓冲区中，并不一定写到了磁盘中。<code>OutputStreamWriter.close()</code>方法会自动调用<code>flush()</code>方法，并且关闭底层的<code>FileOutputStream</code>。</p><p>但是<code>InputStreamReader</code><strong>本身不带缓冲区</strong>，它只是一个“编码解码器”，用来把字节流转换为字符流。<code>BufferedReader</code>才带有缓冲读取功能。如果要提高读取的效率，应该给转换流外面套上一层缓冲流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>英文字符不会出现乱码问题。</p><hr /><p><strong>在内存中的字符问题</strong>：内存中的长度与编程语言有关，Java的一个<code>char</code><strong>在内存中</strong>占用两个字节。在硬盘中占用多少字节取决于编码方式。</p><h2 id="对象流">对象流</h2><p>将内存中定义的变量保存在文件中。</p><p><code>ObjectInputStream</code>从字节流中中还原出对象</p><p><code>ObjectOutputStream</code>将对象转换成字节流</p><ul><li>ObjectOutputStream写入的内容<strong>不是纯文本格式</strong>，而是包含了<strong>Java序列化头信息 + 字符串内容</strong>的<strong>二进制数据</strong>。</li></ul><h3 id="对象的序列化过程">对象的序列化过程</h3><p>对象的<strong>序列化</strong>机制（ObjectSerialization）是指将对象转换成一连串字节的过程，以便：</p><ol type="1"><li>保存到磁盘（例如写入文件）；</li><li>通过网络传输；</li><li>缓存；</li><li>后续还原（反序列化）为原始对象。</li></ol><p>在内存中的对象不能直接写到硬盘或通过网络发送，必须先转成可传输的格式（字节流），这就是序列化的目的。</p><p><strong>反序列化</strong>：将字节流还原为对象</p><hr /><ul><li>序列化的对象的类必须实现接口。</li><li>要求自定义类声明一个全局常量<code>static final long serialVersionUID = xxxxxxL</code>用来唯一地标识当前的类;虽然系统会自动生成UID，但是因为容易变化所以不推荐。</li><li>要求自定义类的各个属性也是可以序列化的<ul><li>基本数据类型默认可序列化</li><li>引用数据类型也实现了接口Serializable</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>项</th><th>说明</th></tr></thead><tbody><tr><td><code>transient</code>关键字</td><td>修饰的字段不会被序列化</td></tr><tr><td>静态字段</td><td><code>static</code>修饰的变量不会被序列化（它属于类，不属于实例）</td></tr><tr><td>父类未实现<code>Serializable</code></td><td>则父类的字段不会被序列化</td></tr><tr><td><code>serialVersionUID</code></td><td>建议手动指定版本号，防止类结构变化导致反序列化失败</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-ArrayList源码简析</title>
    <link href="/2025/04/12/java9/"/>
    <url>/2025/04/12/java9/</url>
    
    <content type="html"><![CDATA[<h1 id="arraylist">ArrayList</h1><p><code>ArrayList</code>是 Java中基于数组实现的一个可变长度的动态数组，它实现了<code>List</code>接口。位置：<code>java.util.ArrayList</code></p><p>Java 8及之后的版本：</p><p><strong>底层数据结构</strong>：</p><p>创建一个Object数组，默认为空数组（懒汉式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// 实际存储元素的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;               <span class="hljs-comment">// 当前元素个数（不是数组长度）</span><br></code></pre></td></tr></table></figure><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 指定初始容量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认构造函数用于扩容为默认大小10，<strong>只有第一次添加元素时才扩容</strong>。</li><li>带参的构造函数用于自己指定初始大小。</li></ul><p><strong>添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>); <span class="hljs-comment">// 确保容量足够</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>size</code>表示添加元素之前已有的元素数量，<code>size+1</code>即添加之后所需要的最小容量</li><li><code>ensureCapacityInternal</code>用于判断是否需要扩容，如果需要扩容，那么<code>elementData</code>扩容为<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>，是原来的1.5倍，旧数组拷贝到新数组。</li></ul><p>扩容操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//如果第一次添加的元素数量和默认长度10做对比，取较大的数</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">//后续添加元素的时候使用下面这个判断</span><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//如果所需最小容量大于现有容量，则扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">// 扩容逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 扩容1.5倍</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//1.5倍仍然不够用的话就直接取元素的长度</span><br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//极端情况特殊处理</span><br>        newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">//拷贝旧数组到原数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    Objects.checkIndex(index, size);<span class="hljs-comment">//检查index是否越界，抛出异常</span><br>    <span class="hljs-keyword">final</span> Object[] es = elementData;<span class="hljs-comment">//为了写法更短、性能稍微好一点</span><br><br>    <span class="hljs-comment">//忽略编译器的泛型转换警告，将es强转为泛型类型E</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) es[index];<br>    fastRemove(es, index);<span class="hljs-comment">//将index+1及其后面的元素全部向前挪动一位，覆盖要删除的元素，最后一位记为null</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<span class="hljs-comment">//返回oldvalue</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>E是泛型类型参数，用来表示<code>ArrayList</code>中存储的元素的类型。</li></ul><p><strong>ArrayList的查找和（尾部）添加元素效率高，删除和插入操作效率低</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>源码剖析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(8)-泛型</title>
    <link href="/2025/04/12/java8/"/>
    <url>/2025/04/12/java8/</url>
    
    <content type="html"><![CDATA[<p>修改历史：</p><p>2025/4/12 初次发布</p><p>2025/4/22 补充静态泛型方法，完善了通配符部分的内容</p><h1 id="概述">概述</h1><p><strong>泛型</strong>（Generics）是Java提供的一种机制，<strong>让类、接口、方法在定义时可以指定类型参数</strong>，从而实现类型安全和代码复用。</p><p><code>HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p><p><code>ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();</code></p><p><code>ArrayList&lt;Person&gt; personList = new ArrayList&lt;&gt;();</code></p><p>都是使用泛型的例子。</p><h1 id="静态泛型方法">静态泛型方法</h1><p>静态方法的泛型和普通方法的泛型的写法不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型类，表示一对相同类型的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-comment">//构造器，传入两个相同类型的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-comment">//getter and setter</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:K不同于T</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的泛型方法用得泛型参数是<code>K</code>，这是因为<strong>泛型类型参数T是在类实例化时才确定的，而静态方法属于类本身，不依赖于实例化，所以它无法访问实例相关的泛型类型</strong>。因此需要另外设一个泛型参数<code>K</code>，可以把这个<code>K</code>看成是静态方法自己专用的类型参数，和类的<code>T</code>没有任何关系，只是刚好做的事相似而已。</p><p>而且，可以注意到静态方法的泛型参数<code>K</code>在声明中出现了两次，这是因为普通方法的<code>T</code>在类的声明中已经出现过，编译器知道它是什么；但是静态方法使用的<code>K</code><strong>从未出现</strong>，所以需要事先声明。第二次出现的<code>K</code>就是正常的使用了。</p><p>静态泛型方法的这种写法在普通方法中也可能出现，比如下边这个：</p><p><img src="https://s21.ax1x.com/2025/04/21/pE5lfxI.png" /></p><p>这句方法声明是 Java Stream API中的<code>map</code>方法，用于将一个流中的每个元素「映射」成另一个类型，返回一个新的流。</p><p>因为这里出现<strong>另一个类型</strong>，为了表示这个类型，需要预先声明<code>&lt;R&gt;</code>才行。</p><p>所以说在方法名前面出现的泛型参数的作用其实就是<strong>声明新参数</strong>，需要新参数了就写一下，防止后面调用的时候编译器不认识它报错，这在普通方法和静态方法中是一致的。</p><h1 id="擦拭法type-erasure">擦拭法(Type Erasure)</h1><p>见https://liaoxuefeng.com/books/java/generics/type-erasure/index.html</p><blockquote><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。编译器内部永远把所有类型T 视为 Object 处理，但是，在需要转型的时候，编译器会根据 T的类型自动为我们实行<strong>安全地强制转型</strong>。</p></blockquote><p>在不使用泛型的时候，一般使用<code>instanceOf</code> +强制转型来处理不同传入参数的情况，泛型使用的其实还是这个逻辑，只不过包装了一下方便用户编写代码。</p><h1 id="通配符">通配符</h1><h2 id="概述-1">概述</h2><p><strong>Java泛型的类型是严格的类型检查</strong>，并不允许不同类型的泛型直接相互赋值。例如，<code>ArrayList&lt;Object&gt;</code>和<code>ArrayList&lt;String&gt;</code>是两种完全不同的泛型类型，即使String是Object的子类。</p><p>解决方法：</p><ol type="1"><li>使用通配符(Wildcard):</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用通配符?，表示可以接受任何类型</span><br>List&lt;?&gt; list = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//创建一个泛型string的list1</span><br>List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">//将list1传给list</span><br>list1.add(<span class="hljs-string">&quot;AA&quot;</span>);<br>list = list1;<br><br><span class="hljs-comment">//这时list成功获取了list1中的元素</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//读取使用Object</span><br>System.out.println(obj);<br><br><span class="hljs-comment">//但是list不能写入数据（因为不能确定到底该放哪个类型），除了null</span><br>list.add(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><strong>上界通配符</strong>(Upper BoundsWildcards)：<code>List&lt;? extends T&gt; list</code>，list是某种<code>T</code>的子类的列表。这样传入的参数可以是T或者T的子类。<strong>可以读，不能写</strong>，因为编译器不知道list是哪个子类。<strong>读取安全但是写入不安全</strong></p><p><strong>下界通配符</strong>：<code>List&lt;? super T&gt; list</code>，list是<code>T</code>的某个父类的列表。方法参数接受所有泛型类型为T及其父类的类型。读出只能被视为为Object（因为不知道具体是哪个父类），可以写入T或其子类。写入安全但是读取受限</p><p>总之：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>作为另一个例子，看看<code>Collections</code>工具类中的<code>copy</code>方法是怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span><br></code></pre></td></tr></table></figure><p>这个方法的作用是把src列表的元素复制到dest列表中。</p><p>可以看到，源列表的泛型是上界通配符，因为我们要获取源列表的每一个元素，使用上界通配符的话源列表的每一个元素都不可能比<code>T</code>的等级“高”，可以安全地利用向上转型原则通过<code>T</code>来get它们。</p><p>与之相反，dest目标列表使用的是super，因为我们要对目标列表进行写入操作，使用super可以保证目标列表中的每一个元素都不会比<code>T</code>等级低，这样只要set一个<code>T</code>类型的元素就可以保证成功向上转型。</p><h2 id="pecs原则">PECS原则</h2><p><strong>Producer Extends Consumer Super</strong></p><p>生产者（源）用<code>extends</code>，消费者（目标）用<code>super</code>，就是上边说过的东西</p><h2 id="无限定通配符">无限定通配符</h2><p><strong>Unbounded Wildcard Type</strong></p><p><code>&lt;?&gt;</code></p><p>既没有extends，也没有super，也就是说既不能读也不能写，可以用于逻辑判断。</p><p><code>&lt;?&gt;</code>是等级最高的存在，可以保证顺利向上转型，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>    Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>    System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-集合框架知识梳理</title>
    <link href="/2025/04/10/java7/"/>
    <url>/2025/04/10/java7/</url>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025/04/10 初次发布</li><li>2025/04/30 重新树立了结构，增加常用方法总结</li><li>2025/05/03 增加“如何将列表转换成特定类型的数组”部分</li></ul><h1 id="collection">Collection</h1><p><strong>内存层面</strong>需要针对多个数据进行存储，可以考虑的<strong>容器</strong>有：数组、集合类。</p><p>数组初始化后的长度不可变，存储数据为单一类型，可包含重复元素，不适用于不可重复的场景；可用的属性和方法都极少；不便删除和插入元素。</p><p>Java中的集合框架（Java Collections Framework，简称JCF）是一个统一的架构，用于表示和操作一组对象。</p><p>Java集合框架体系：</p><ul><li><code>java.util.Collection</code>:存储一个一个的数据<ul><li>子接口：<strong>List</strong>，存储<strong>有序</strong>的、<strong>可重复</strong>的数据（动态数组）<ul><li><code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li></ul></li><li>子接口：<strong>Set</strong>，存储<strong>无序</strong>的、<strong>不可重复</strong>的数据（类似集合）<ul><li><code>HashSet</code>,<code>LinkedHashSet</code>,<code>TreeSet</code></li></ul></li></ul></li><li><code>java.util.Map</code>:存储一对一对的数据<ul><li><code>HashMap</code>,<code>LinkedHashMap</code>,<code>TreeMap</code>,<code>Hashtable</code>,<code>Properties</code></li></ul></li></ul><h1 id="list及其实现类">List及其实现类</h1><h2 id="增强for循环">增强for循环</h2><p><strong>作用</strong>：遍历数组，集合</p><p>集合：底层使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (集合或数组的类型 临时变量 : 集合或数组变量) &#123;<br>    操作临时变量的输出;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="list及其实现类的特点">List及其实现类的特点</h2><p>List存储有序的可重复的数据，动态数组，每增加一个对象容量就自动加一。</p><ul><li>ArrayList:List的<strong>主要实现类</strong>，底层使用Object[]数组存储，插入和删除数据时效率低</li><li>LinkedList:底层使用双向链表的方式存储，添加和查找数据时效率较低。适用于对集合中的数据进行频繁的删除和插入操作.</li><li>Vector: 古老，不用</li></ul><h3id="arraylist和普通数组的对比"><code>ArrayList</code>和普通数组的对比</h3><table><thead><tr><th>特性</th><th>ArrayList</th><th>普通数组 (Array[])</th></tr></thead><tbody><tr><td>长度</td><td>动态变化，可自动扩容</td><td>固定长度，创建后不可更改</td></tr><tr><td>添加元素</td><td>使用 <code>add()</code> 方法添加</td><td>需指定索引或使用循环添加</td></tr><tr><td>删除元素</td><td>使用 <code>remove()</code> 方法删除</td><td>不支持直接删除，需要移动元素</td></tr><tr><td>查找元素</td><td>使用 <code>get(index)</code> 获取元素</td><td>使用 <code>array[index]</code> 访问</td></tr><tr><td>是否支持泛型</td><td>支持，例如 <code>ArrayList&lt;Integer&gt;</code></td><td>不支持泛型</td></tr><tr><td>是否支持基本类型</td><td>不支持，只能存对象（可装箱）</td><td>支持基本类型和对象类型</td></tr><tr><td>是否线程安全</td><td>默认<strong>不是</strong>线程安全的</td><td>不是线程安全</td></tr><tr><td>使用场景</td><td>元素数量不确定、操作灵活</td><td>元素数量固定、结构简单</td></tr></tbody></table><hr /><h1id="collectionlistarraylist的对比">Collection、List、ArrayList的对比：</h1><table><thead><tr><th>特性</th><th>Collection</th><th>List</th><th>ArrayList</th></tr></thead><tbody><tr><td>类型</td><td>接口</td><td>接口（继承自 Collection）</td><td>类（实现了 List 接口）</td></tr><tr><td>是否可实例化</td><td>❌ 不能直接实例化</td><td>❌ 不能直接实例化</td><td>✅ 可以直接实例化</td></tr><tr><td>顺序性</td><td>❌ 不保证顺序（由子接口决定）</td><td>✅ 保证元素顺序</td><td>✅ 保证元素顺序</td></tr><tr><td>是否允许重复</td><td>❓ 由具体实现决定</td><td>✅ 允许重复元素</td><td>✅ 允许重复元素</td></tr><tr><td>随机访问效率</td><td>❌ 无此功能</td><td>✅ 有 <code>get(int)</code> 方法</td><td>✅ 快速随机访问（基于数组）</td></tr><tr><td>常见实现类</td><td>List、Set、Queue 等</td><td>ArrayList、LinkedList 等</td><td>自身是实现类</td></tr><tr><td>典型使用场景</td><td>操作所有集合的通用方法</td><td>操作有序集合（如列表）</td><td>频繁查询、随机访问</td></tr><tr><td>方法示例</td><td><code>add()</code>, <code>remove()</code>, <code>size()</code></td><td>加上 <code>get()</code>, <code>set()</code>,<code>indexOf()</code>等</td><td>同 List，同时还有优化的内部实现</td></tr></tbody></table><h1 id="set">Set</h1><h2 id="实现类">实现类</h2><p><code>Set</code>接口是<code>Collection</code>接口的子接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <br></code></pre></td></tr></table></figure><p>它存储<strong>无序的不可重复的数据</strong>。常用实现类：</p><ul><li><code>HashSet</code>:<strong>主要实现类</strong>，底层使用<code>HashMap</code>，即数组+单向链表+红黑树<ul><li><code>LinkedHashSet</code>:<code>HashSet</code>的子类；在现有的结构的基础上又添加了一组双向链表，用于记录添加元素的先后顺序，便于频繁的查询操作。</li></ul></li><li><code>TreeSet</code>:底层使用红黑树存储。可以按照添加元素的指定的属性大小顺序进行自动排序，从而进行有序遍历。<ul><li>底层：红黑树。可以按照指定的大小顺序自动排序。</li><li>要求TreeSet中的元素必须是<strong>同一个类型</strong>，否则类型转换错误。</li><li>处理对象比较方法，排序的标准就是自然排序或定制排序对应方法的返回值。如果是零则认为是相等，不添加新元素。</li><li>不需要重写<code>hashCode()</code>和<code>equals()</code>方法。</li></ul></li></ul><p><strong>常用方法</strong>：<code>Collection</code>中常用的方法，<strong>无新增方法</strong>。</p><p>主要作用：<strong>去除重复数据</strong>。</p><h2 id="重写两个方法">重写两个方法</h2><p>添加到HashSet/LinkedHashSet中的元素的要求：元素所在的类要重写两个方法：<code>equal()</code>和<code>hashCode()</code>。</p><p><code>hashmap</code>中依据<code>key</code>的<code>hash</code>值来确定<code>value</code>存储位置（hash值就是数组的索引），所以一定要重写<code>hashCode</code>方法；</p><p>而重写<code>equals</code>方法，是为了解决<code>hash</code>冲突：我们在重写<code>hashcode()</code>方法时已经尽量保证了哈希值不会重复，如果发现两个不同的<code>key</code>的<code>hash</code>值相同，那么就会调用<code>equals</code>方法，继续比较<code>key</code>值是否相同。</p><p>在存储时：如果<code>equals</code>结果相同，说明是同一个键，那么就覆盖更新<code>value</code>值；如果键不同，但是哈希值相同，就用<code>List</code>把他们都存储在同一个位置。在取出时：如果<code>equals</code>结果相同就直接返回当前<code>value</code>值，如果不同就遍历<code>List</code>中下一个元素。即要<code>key</code>与<code>hash</code><strong>同时匹配</strong>才会认为是同一个<code>key</code>。</p><p>JDK中用于判断是否是同一个key的源码:<code>if(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123;ops;&#125;</code></p><h1 id="map">Map</h1><h2 id="map及其实现类对比">Map及其实现类对比</h2><p><code>java.util.Map</code>:存储一对一对的<strong>键值对</strong>.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">               ┌──────────────┐<br>               │   Map接口    │<br>               └─────┬────────┘<br>                     │<br>        ┌────────────┴─────────────┐<br>        │                          │<br>  ┌─────▼─────┐              ┌─────▼─────┐<br>  │ HashMap   │              │ SortedMap │（接口）<br>  └─────┬─────┘              └─────┬─────┘<br>        │                          │<br>┌───────▼────────┐           ┌─────▼─────┐<br>│ LinkedHashMap  │           │ TreeMap   │<br>└────────────────┘           └───────────┘<br><br>┌──────────────┐<br>│ Hashtable    │（古老的线程安全实现）<br>└─────┬────────┘<br>      │<br>┌─────▼─────┐<br>│Properties │（子类，专用于配置文件）<br>└───────────┘<br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>HashMap</th><th>LinkedHashMap</th><th>TreeMap</th><th>Hashtable</th><th>Properties</th></tr></thead><tbody><tr><td>所属接口</td><td>Map</td><td>Map</td><td>Map, SortedMap, NavigableMap</td><td>Map</td><td>Hashtable</td></tr><tr><td>是否线程安全</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>是否允许 null 键</td><td>是（最多一个）</td><td>是（最多一个）</td><td>否（键不能为 null）</td><td>否</td><td>否</td></tr><tr><td>是否有序</td><td>否</td><td>有插入顺序</td><td>有自然顺序或指定 Comparator</td><td>否</td><td>否</td></tr><tr><td>底层结构</td><td>哈希表</td><td>哈希表 + 双向链表</td><td>红黑树</td><td>哈希表</td><td>哈希表</td></tr><tr><td>性能</td><td>查询快，一般推荐</td><td>查询快，顺序操作性能略低</td><td>查询较慢，适合排序需求</td><td>查询快，但并发性能不佳</td><td>主要用于配置文件加载</td></tr><tr><td>用途</td><td>通用 Map 容器</td><td>保留插入顺序的 Map</td><td>需要排序的 Map</td><td>早期线程安全 Map，已过时</td><td>存储配置信息（key/value 字符串）</td></tr></tbody></table><h2 id="hashmap">HashMap</h2><p><code>HashSet</code>就是基于<code>HashMap</code>实现的。两者的对比如下：</p><table><thead><tr><th>特性</th><th><code>HashSet</code></th><th><code>HashMap</code></th></tr></thead><tbody><tr><td>存储结构</td><td>只存储元素（作为键）</td><td>存储键值对（key-value）</td></tr><tr><td>是否允许重复</td><td>❌ 不允许重复元素</td><td>✅ 键不允许重复，值可以重复</td></tr><tr><td>内部实现</td><td>基于 <code>HashMap</code> 实现</td><td>使用数组+链表（或红黑树）实现</td></tr><tr><td>查找效率</td><td>O(1)</td><td>O(1)</td></tr><tr><td>底层结构</td><td>实际是 <code>HashMap&lt;E, Object&gt;</code></td><td>实际是 <code>HashMap&lt;K, V&gt;</code></td></tr></tbody></table><p><code>HashSet</code>中只存储元素（值），而不是键值对。</p><p>为了实现这一点，它把元素作为<code>HashMap</code>的键，用一个统一的对象（比如<code>PRESENT</code>）作为值。</p><p>所以其实每次你往<code>HashSet</code>添加一个元素时，它是在底层的<code>HashMap</code>中添加了一条键值对：<code>map.put(element, PRESENT);</code></p><hr /><ul><li>HashMap中的key用Set来存放，无序而且不允许重复，所以同一个Map对象所对应的类<strong>需要重写hashCode和equals</strong>。</li><li>HashMap中的Value可重复、无序。<strong>不强制重写任何方法</strong>。</li><li>每一个键值对构成一个<strong>entry</strong>，所有的entry构成了一个Set集合</li></ul><h2 id="treemap">TreeMap</h2><ul><li>底层使用红黑树，按照<strong>key</strong>指定的大小顺序排序。</li><li>需要考虑使用对象排序</li><li>必须是<strong>同一个类型</strong>的对象</li></ul><h2 id="properties">Properties</h2><ul><li>Hashtable的子类</li><li>键和值都是String类型，用来处理属性文件</li></ul><h1 id="queue">Queue</h1><p>队列(Queue)实现了一个先进先出的有序表。Queue只有两个操作：</p><ul><li>把元素添加到末尾</li><li>从头部取出元素</li></ul><p>接口<code>Queue</code>定义了以下几个方法：</p><ul><li><code>size(): int</code>:返回队列中的元素的数量</li><li><code>add(E e)</code>:添加元素到队尾，添加失败的话抛出<code>IllegalStateException</code></li><li><code>offer(E e): boolean</code>:添加元素到队尾，添加失败返回<code>false</code>。<strong>更安全，推荐</strong></li><li><code>remove(): E</code>:获取并移除队首元素，如果队列为空则抛异常<code>NoSuchElementException</code></li><li><code>poll(): E</code>:获取并移除队首元素，如果为空返回<code>null</code>。<strong>更安全，推荐</strong></li><li><code>element(): E</code>:获取但不移除队首元素，队列为空抛异常<code>NoSuchElementException</code></li><li><code>peek(): E</code>:获取但不移除队首元素，队列为空返回<code>null</code>。<strong>更安全，推荐</strong></li></ul><h2 id="linkedlist">LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure><p><code>LinkedList</code>是最常用的实现类，底层使用双向链表的方式存储，添加和查找数据时效率较低。适用于对集合中的数据进行频繁的删除和插入操作。</p><p>注意<code>LinkedList</code>同时实现了<code>Queue</code>和<code>List</code>接口，使用时该用哪个用哪个。</p><h2 id="priorityqueue">PriorityQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br></code></pre></td></tr></table></figure><p>一个优先队列，元素的顺序按照<strong>优先级的大小</strong>排列，它并不遵循严格的先进先出。所谓优先级的大小，指的是它会根据提供的比较器对队列中的元素进行排序，或者使用自然排序（空构造器的情况）。</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>上面的声明使用了空的构造器，这种情况下队列中的元素按照<strong>自然排序</strong>。也可以使用一个lambda表达式重写比较方法实现定制排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b - a);<br><br>    pq.offer(<span class="hljs-number">5</span>);<br>    pq.offer(<span class="hljs-number">1</span>);<br>    pq.offer(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        System.out.println(pq.poll());  <span class="hljs-comment">// 输出顺序：5, 3, 1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deque">Deque</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, SequencedCollection&lt;E&gt;<br></code></pre></td></tr></table></figure><div class="note note-secondary">            <p><code>Deque</code>是一个支持在队列两端插入和删除操作的线性集合。它的名字"deque"是"doubleendedqueue"（双端队列）的简称。大部分<code>Deque</code>的实现对包含的元素的数量没有固定限制，但是这个接口也支持有容量限制的队列和无限容量队列。</p>          </div><h3 id="实现类-1">实现类</h3><table><thead><tr><th>实现类名称</th><th>说明</th></tr></thead><tbody><tr><td><code>ArrayDeque</code></td><td>常用，基于数组，效率高，适合栈/队列操作</td></tr><tr><td><code>LinkedList</code></td><td>也实现了 <code>Deque</code>，但效率略低</td></tr><tr><td><code>LinkedBlockingDeque</code></td><td>线程安全，可设置容量限制（在并发场景使用）</td></tr></tbody></table><p>这里又出现了<code>LinkedList</code>。所以说使用<code>LinkedList</code>的时候最好使用它的接口来引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;String&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="方法">方法</h3><p><strong>添加元素的方法</strong>：</p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>addFirst(e)</code></td><td>添加到队头（栈顶）</td><td>✅</td><td>❌（无）</td></tr><tr><td><code>offerFirst(e)</code></td><td>添加到队头（栈顶）</td><td>❌</td><td>✅</td></tr><tr><td><code>addLast(e)</code></td><td>添加到队尾（队列尾部）</td><td>✅</td><td>❌（无）</td></tr><tr><td><code>offerLast(e)</code></td><td>添加到队尾（队列尾部）</td><td>❌</td><td>✅</td></tr><tr><td><code>add(e)</code></td><td>默认添加到队尾（等同 <code>addLast</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>offer(e)</code></td><td>默认添加到队尾（等同 <code>offerLast</code>）</td><td>❌</td><td>✅</td></tr><tr><td><code>push(e)</code></td><td><strong>栈操作</strong>，添加到头部（等同<code>addFirst</code>）</td><td>✅</td><td>❌</td></tr></tbody></table><p><strong>删除元素的方法</strong></p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>removeFirst()</code></td><td>删除并返回队头元素</td><td>✅</td><td>❌</td></tr><tr><td><code>pollFirst()</code></td><td>删除并返回队头元素</td><td>❌</td><td>✅</td></tr><tr><td><code>removeLast()</code></td><td>删除并返回队尾元素</td><td>✅</td><td>❌</td></tr><tr><td><code>pollLast()</code></td><td>删除并返回队尾元素</td><td>❌</td><td>✅</td></tr><tr><td><code>remove()</code></td><td>默认删除队头（等同 <code>removeFirst</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>poll()</code></td><td>默认删除队头（等同 <code>pollFirst</code>）</td><td>❌</td><td>✅</td></tr><tr><td><code>pop()</code></td><td><strong>栈操作</strong>，删除头部（等同<code>removeFirst</code>）</td><td>✅</td><td>❌</td></tr></tbody></table><p><strong>查看元素的方法</strong></p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>getFirst()</code></td><td>获取队头元素</td><td>✅</td><td>❌</td></tr><tr><td><code>peekFirst()</code></td><td>获取队头元素</td><td>❌</td><td>✅</td></tr><tr><td><code>getLast()</code></td><td>获取队尾元素</td><td>✅</td><td>❌</td></tr><tr><td><code>peekLast()</code></td><td>获取队尾元素</td><td>❌</td><td>✅</td></tr><tr><td><code>element()</code></td><td>默认获取队头（等同 <code>getFirst</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>peek()</code></td><td>默认获取队头（等同 <code>peekFirst</code>）</td><td>❌</td><td>✅</td></tr></tbody></table><p><strong>其他方法</strong></p><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>isEmpty()</code></td><td>判断队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回当前元素数量</td></tr><tr><td><code>contains(Object)</code></td><td>判断队列中是否包含指定元素</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr><tr><td><code>iterator()</code></td><td>从头到尾遍历</td></tr><tr><td><code>descendingIterator()</code></td><td>从尾到头遍历</td></tr></tbody></table><h2 id="stack">Stack</h2><p>Stack(栈)的特点：后进先出，相当于把队列的一端堵死，只留一个出口。</p><p>使用Deque可以实现后进先出的栈操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// push “压入” 栈操作添加到头部</span><br>    stack.push(<span class="hljs-string">&quot;A&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;B&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;C&quot;</span>);<br><br>    <span class="hljs-comment">// pop “弹出” 栈操作删除头部</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        System.out.println(stack.pop()); <span class="hljs-comment">// 输出顺序：C B A</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们把Deque作为Stack使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p><h1 id="iterator">Iterator</h1><p>Iterator,获取迭代器的对象：<code>Iterator itr = 集合.iterator();</code></p><p>遍历集合的所有元素：<code>itr.hasNext()</code>+<code>itr.next()</code></p><figure><img src="https://i.imgur.com/uRaHFI0.png" alt="迭代器图解" /><figcaption aria-hidden="true">迭代器图解</figcaption></figure><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种<strong>集合</strong>类型，而不必关心它们内部的存储结构。</p><h1 id="集合框架常用方法总结">集合框架常用方法总结</h1><h2 id="collection接口">Collection接口</h2><p><code>Collection</code>接口作为集合框架最上层的接口，所有的集合数据类型都可以使用其中定义的方法。如下：</p><table><thead><tr><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向集合中添加一个元素</td></tr><tr><td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td>将指定集合中的所有元素添加进来</td></tr><tr><td><code>void clear()</code></td><td>清空集合中所有元素</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>判断集合中是否包含某个元素</td></tr><tr><td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td><td>判断集合是否包含另一个集合中的所有元素</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>Iterator&lt;E&gt; iterator()</code></td><td>返回一个迭代器，用于遍历集合元素</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除集合中首次出现的指定元素</td></tr><tr><td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td><td>删除集合中与指定集合中相同的所有元素</td></tr><tr><td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td><td>仅保留集合中也包含在指定集合中的元素（交集）</td></tr><tr><td><code>int size()</code></td><td>返回集合中元素的数量</td></tr><tr><td><code>Object[] toArray()</code></td><td>返回一个包含集合中所有元素的数组</td></tr><tr><td><code>&lt;T&gt; T[] toArray(T[] a)</code></td><td>返回一个包含集合中所有元素的指定类型数组</td></tr></tbody></table><h2 id="list接口">List接口</h2><p><img src="https://s21.ax1x.com/2025/04/30/pEHswkT.png" /></p><p><code>List</code>作为一个接口，也是Collection的子接口。<code>Collection</code>定义的所有方法都可以继续使用，除此之外还有一些特有的方法：</p><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td><code>void add(int index, E element)</code></td><td>在指定索引插入元素</td></tr><tr><td><code>E get(int index)</code></td><td>获取指定索引的元素</td></tr><tr><td><code>E set(int index, E element)</code></td><td>替换指定索引位置的元素</td></tr><tr><td><code>E remove(int index)</code></td><td>删除指定索引处的元素</td></tr><tr><td><code>int indexOf(Object o)</code></td><td>返回元素首次出现的索引</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>返回元素最后一次出现的索引</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator()</code></td><td>获取支持双向遍历的迭代器</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator(int index)</code></td><td>从指定索引开始的 ListIterator</td></tr><tr><td><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td><td>获取子列表 <code>[from, to)</code></td></tr></tbody></table><h2 id="set接口">Set接口</h2><p><code>Set</code>接口也是<code>Collection</code>的子接口,但是它<strong>没有额外定义新的方法</strong>。</p><p><img src="https://s21.ax1x.com/2025/04/30/pEHsNmq.png" /></p><h2 id="map接口">Map接口</h2><p><code>Map</code>专门用于存储键值对，它与<code>Collection</code>接口无直接关联，常用方法如下：</p><table><thead><tr><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td><code>V put(K key, V value)</code></td><td>将指定的键值对插入到 Map 中（若键已存在则更新值，返回旧值）</td></tr><tr><td><code>V get(Object key)</code></td><td>根据键获取对应的值</td></tr><tr><td><code>V remove(Object key)</code></td><td>根据键移除键值对，返回被删除的值</td></tr><tr><td><code>boolean containsKey(Object key)</code></td><td>判断是否包含指定键</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>判断是否包含指定值</td></tr><tr><td><code>int size()</code></td><td>返回键值对数量</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断 Map 是否为空</td></tr><tr><td><code>void clear()</code></td><td>清空 Map 中所有内容</td></tr><tr><td><code>Set&lt;K&gt; keySet()</code></td><td>返回所有键的集合</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>返回所有值的集合</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>返回所有键值对的集合（每个 Entry 是一个键值对）</td></tr><tr><td><code>V putIfAbsent(K key, V value)</code></td><td>如果键不存在，则插入键值对（JDK 1.8+）</td></tr></tbody></table><h1id="如何将列表转换成特定类型的数组">如何将列表转换成特定类型的数组</h1><h2 id="引入">引入</h2><p>先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ListNode&gt; TempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>...<br>ListNode[] lists = TempList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><code>lists</code>是一个用于存放<code>ListNode</code>数据的数组，<code>Templist</code>是一个存放<code>ListNode</code>元素的列表。最后一行代码实现了从<code>TempList</code>列表向数组的转化。这里的关键是<code>toArray</code>方法，实际上<code>List</code>接口中定义了两个<code>toArray</code>抽象方法，一个空参一个有参，定义分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray();<br>&lt;T&gt; T[] toArray(T[] a);<br></code></pre></td></tr></table></figure><p>为了搞清楚这两个方法如何使用，需要先介绍一下<code>runtime type</code>（运行时类型）和<code>compile type</code>（编译时类型）。</p><h2 id="编译时类型和运行时类型">编译时类型和运行时类型</h2><p>运行时类型，指的是对象在程序运行的过程中真实的类型。之所以强调“真实”，是因为Java中的多态使得编译器认为的类型和程序运行时的类型可能不一样，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><p>所谓<em>编译看左边，运行看右边</em>，<code>a</code>的编译时类型是<code>Animal</code>，运行时类型是<code>Dog</code>。</p><h2 id="java标准库提供的注释">Java标准库提供的注释</h2><p>先看空参方法<code>Object[] toArray();</code>：</p><blockquote><p>按照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。</p><p>返回的数组是“安全的”，意思就是说它不包含任何对原列表的引用，是完全独立于原列表的。你可以放心地修改它，不用担心会对原列表产生任何影响。</p><p>这个方法是基于数组的 API 和基于集合的 API 之间的桥梁。</p></blockquote><p><code>返回值</code>:一个以正确的顺序包含列表中的所有元素的<code>Object</code>数组</p><p>这个方法的返回值类型固定为<code>Object[]</code>，在实际应用中需要手动强转成我们需要的类型，很不方便。于是就有了后面这个带参数的方法</p><hr /><p><code>&lt;T&gt; T[] toArray(T[] a);</code></p><blockquote><p>照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。返回数组的运行时类型与指定数组相同。如果该列表可以装入指定的数组中，则直接把它放进数组并返回；否则，会分配一个具有与指定数组相同运行时类型的新数组，其大小等于列表的大小。</p><p>如果指定的数组比原列表需要的空间还大，那么空缺位置会被赋值为<code>null</code>。（<em>仅当</em>调用者确认原列表中不包含任何<code>null</code>元素时，这个特性才有助于判断列表的长度）</p><p>就像<code>toArray()</code>方法一样，该方法是基于数组的 API和基于集合的 API之间的桥梁。此外，该方法允许对输出数组的运行时类型进行精确的控制，在某些情况下或许可以节省内存开销。</p><p>假设<code>x</code>是一个已知只包含字符串的列表。以下代码可以用于将列表转存到新分配的String数组中：</p><p><code>String[] y = x.toArray(new String[0]);</code></p><p>注意<code>toArray(new Object[0])</code>与上面的<code>toArray()</code>完全相同。</p></blockquote><p><code>参数</code>: <code>a</code>-指定数组，如果足够大，原列表的元素将被直接存入该数组；否则，会分配一个与之相同运行类型的新数组。</p><p><code>返回值</code>: 一个包含列表元素的数组</p><p><code>抛出</code>: <code>ArrayStoreException</code> -如果指定数组的运行时类型不是每一个列表元素的父类型<br /><code>NullPointerException</code> - 如果指定数组是<code>null</code></p><hr /><p>Java标准库中给出的解释已经非常详细了。对于开头处的语句<code>ListNode[] lists = TempList.toArray(new ListNode[0]);</code>，形参<code>new ListNode[0]</code>的主要作用是<strong>确定返回数组的运行时类型</strong>，它作为我们给出的指定数组，其容量为0，显然是不够用的，所以会分配一个运行时类型为<code>ListNode[]</code>的新数组，其容量等于列表的大小。然后，把返回的数组赋给相同类型的数组<code>lists</code>就没有任何问题了。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>サマータイムレコード じん　歌詞</title>
    <link href="/2025/04/08/summertimerecord/"/>
    <url>/2025/04/08/summertimerecord/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>これぞ夏</p><p>作詞/作曲/編曲/Guitar：じん</p><p>昨日も今日も晴天で<br />入道雲を見ていた</p><p>怠いくらいの快晴だ<br />徐々に目を閉じて</p><p>「それ」はどうも簡単に<br />思い出せやしない様で</p><p>年を取った現状に<br />浸ってたんだよ</p><p>大人ぶった作戦で<br />不思議な合図立てて</p><p>「行こうか、今日も戦争だ」<br />立ち向かって　手を取った</p><p>理不尽なんて当然で<br />一人ぼっち　強いられて</p><p>迷った僕は<br />憂鬱になりそうになってさ</p><p>背高草を分けて<br />滲む太陽睨んで</p><p>君はさ、こう言ったんだ<br />「孤独だから、おいでよ」</p><p>騒がしさがノックして<br />生まれた　感情さえも</p><p>頭に浮かんでは萎んだ</p><p>「幻なのかな？」</p><p>秘密基地に集まって<br />「楽しいね」って単純に</p><p>あの頃を思い出して<br />話をしよう</p><p>飛行機雲飛んで行って<br />「眩しいね」って泣いていた</p><p>君はどんな顔だっけ</p><p>なぜだろう</p><p>思い出せないな</p><hr /><p>痛いくらいに現実は　足早に駆け抜けた</p><p>選んだ今日は平凡で　崩れそうになる日々さ</p><p>昨日も今日も延長戦　大人だって　臆病だ</p><p>今になってなんとなく　気付けたみたいだよ</p><p>廻るセカイのイデア　枯れる太陽　炎天下</p><p>陽炎が揺らいだ　「忘れないで、さぁ、進もう」</p><p>もどかしさ何度でも　明日を夢に見ていた</p><p>戻らない、先のある世界へ　「僕たちで変えよう」 　「思い出して、終わたって　秘密基地も、冒険も」</p><p>あの日に迷い込んだ　話の事も</p><p>一人ぼっちが集まった　子供たちの作戦が　また今日も廻り出した</p><p>「また、何処かで。」</p><p>「涼しいね」って言い合った　夏空は透明だ</p><p>泣かない様に、吸い込んで　「さようなら」しよう</p><p>秘密基地に集まって　笑い合った夏の日に</p><p>「また何処かで思い出して　出逢えるかな」って</p><p>何度でも　描こう</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-常用类与基础API</title>
    <link href="/2025/04/08/java6/"/>
    <url>/2025/04/08/java6/</url>
    
    <content type="html"><![CDATA[<h1 id="string">String</h1><p>特性：不可变，创建后不能改变内容，任何修改其实是创建了新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>String s1 = "hello";</code>使用<strong>字面量</strong>，在常量池里创建一个对象。如果有同样的字面量，会复用，效率更高</p><p><code>String s2 = new String("hello");</code>使用new在堆内存里创建一个对象，</p><p><code>s1==s2</code>判断为<code>false</code>,<code>s1.equals(s2)</code>判断为<code>true</code></p><h2 id="string的连接操作">String的连接操作</h2><p>常量+常量 = 常量池中的常量</p><p>常量+变量 = 堆空间中该字符串对象的地址</p><p><code>intern()</code>返回字符串常量池中对应的地址。</p><p><code>concat()</code>必然返回一个新对象</p><h2 id="常用方法">常用方法</h2><p><code>getBytes()</code>：将字符串转换成字节数组，储存的数字与编码有关，需要指定编码方式使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>utf-8或gbk都向下兼容ascii。</p><p><strong>解码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, 字符集名称);<br></code></pre></td></tr></table></figure><hr /><p><code>indexOf</code>:查找某个字符或子字符串在字符串中<strong>第一次</strong>出现的位置。没有找到则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s, <span class="hljs-type">int</span> fromIndex);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> fromIndex);<br></code></pre></td></tr></table></figure><p>记录某个字符串在另一个字符串中出现的次数：（复杂度大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">getSubStringCount</span><span class="hljs-params">(String str,String subStr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(subStr);<span class="hljs-comment">//第一次出现的索引</span><br><br>    <span class="hljs-keyword">while</span>(index != -<span class="hljs-number">1</span>) &#123;<br>        count++;<br>        index = str.indexOf(subStr, index+subStr.length());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="stringstringbufferstringbuilder">String,StringBuffer,StringBuilder</h2><p>String:不可变的字符序列；</p><p>StringBuffer:可变的字符序列；线程安全，效率低</p><p>StringBuilder:可变的字符序列；线程不安全，效率高</p><p>以上三者底层均为byte[].</p><p>增:append</p><p>删:delete(int start, int end)<br />deleteCharAt(int index)</p><p>改:replace(int start, int end, String str) setCharAt(int index, charc)</p><p>查:charAt(inr index)</p><p>插:insert(int index, xx)</p><p>长度:length()</p><h1 id="日期时间api">日期时间API</h1><p>旧API</p><ol type="1"><li>currentTimeMillis():与1970.1.1日0时0分0秒之间的毫秒数</li><li>Date()类</li><li>Calendar抽象类</li></ol><p><strong>新API</strong>：</p><p>最常用的API：</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDate</code></td><td>表示日期（如：2025-04-09），不含时间和时区</td></tr><tr><td><code>LocalTime</code></td><td>表示时间（如：12:30:45），不含日期和时区</td></tr><tr><td><code>LocalDateTime</code></td><td>表示日期和时间（如：2025-04-09T12:30:45），不含时区</td></tr><tr><td><code>ZonedDateTime</code></td><td>表示带时区的日期和时间（如：2025-04-09T12:30:45+09:00[Asia/Tokyo]）</td></tr><tr><td><code>Instant</code></td><td>表示时间戳，精确到纳秒（从1970-01-01T00:00:00Z开始）（重写为ISO-8601标准的字符串）</td></tr><tr><td><code>Duration</code></td><td>表示两个时间之间的间隔（单位：秒、纳秒）</td></tr><tr><td><code>Period</code></td><td>表示两个日期之间的间隔（单位：年、月、日）</td></tr><tr><td><code>DateTimeFormatter</code></td><td>用于格式化和解析日期时间</td></tr></tbody></table><h1 id="自定义类的对象的排序">自定义类的对象的排序</h1><h2 id="自然排序实现comparable接口">1.自然排序：实现Comparable接口</h2><ol type="1"><li>定义一个类实现<code>Comparable</code>接口这个泛型接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>实现<code>public int compareTo(T o);</code>方法，指明比较的标准</li><li>创建实例，调用<code>Arrays.sort</code>或<code>compareTo</code>比较大小。</li></ol><p>实现compareTo方法之后，<code>Arrays.sort(arr)</code>的比较标准也会改变。</p><blockquote><p><code>Arrays.sort()</code> 会自动使用元素类中定义的<code>compareTo()</code>方法，所以当你重写了这个方法，排序逻辑自然也随之改变了。</p></blockquote><p>实例：让Person对象按照名字排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person[] ps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>    String name;<br>    <span class="hljs-type">int</span> score;<br>    Person(String name, <span class="hljs-type">int</span> score) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-comment">//实现 compareTo 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person other)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定制排序">2.定制排序</h2><p>适用情况：</p><ul><li>元素类型没有实现Comparable接口，而且不方便修改代码</li><li>实现了接口，但是以后不想用这个比较方法，又不能影响已有的使用</li></ul><ol type="1"><li>创建一个实现Comparator接口的实现类A</li><li>类A要重写compare方法</li><li>创建实现类A的实例，并传入<code>Arrays.sort(arr,类A的实例)</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>もうじき夏が終わるから n-buna &amp;初音ミク　歌詞</title>
    <link href="/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/"/>
    <url>/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>もうじき夏が終わるから</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>朝　小説を読んだ</p><p>君を待っていた</p><p>夜になって気が付いた</p><p>花火の音</p><p>花揺ら歌い今日藍を飛ばせ</p><p>貴方に聞こえないように消えて</p><p>それを言えない僕じゃ言えないよ</p><p>今に夏が終わってくから</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>陽の落ちる街を歩いていた</p><p>今日もまた</p><p>朝　ラジオを聞いた君を待っていた</p><p>夜になって気が付いたことを覚えている</p><p>昨日もピアノを弾いた</p><p>朝を待っている</p><p>唄を歌っている</p><p>花詩　誓い　今日藍を飛ばせ</p><p>貴方に聞こえないように叫べ</p><p>夢を見れない僕花咲いた</p><p>終わる夏よ止まってしまえ</p><p>アベリア　始発　終電車　<ruby>緑青<rt>ろくしょう</rt></ruby></p><p>蝉の鳴く街を歩いていた</p><p>今日もまた</p><p>朝、今日も駅の裏</p><p>人が立っていた</p><p>夜の藍に花が咲く</p><p>絵をえがいていた</p><p>帰ってピアノを弾いた</p><p>夜になっていた</p><p>君を待っていた</p><p>花詩　誓い　明日藍を飛ばせ</p><p>貴方が居たくない今日を叫べ</p><p>夢が言えないことに気がついた</p><p>浅い夏よ　終わってくれよ</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>夜が明けた街を歩いていた</p><p>今日もまた</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-面向对象-高级</title>
    <link href="/2025/04/01/java4/"/>
    <url>/2025/04/01/java4/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字static">关键字static</h1><p><strong>作用</strong>：使得类的某一个成员变量被这个类的所有实例所共享（类变量、静态变量），使得我们不需要创建对象就可以调用某个方法（类方法）。</p><p>静态变量：</p><ul><li>在内存空间中只有一份，被类的多个变量共享。</li><li>在JDK8之前，静态变量存储在方法区(MethodArea)；JDK8及以后，由于永久代(PermGen)被移除，静态变量存储在元空间(Metaspace)。</li><li>在类加载时就被初始化，分配内存，只加载一次，整个程序运行期间一直存在，直到类被卸载。</li></ul><table><thead><tr><th>类别</th><th>存储位置</th><th>生命周期</th><th>归属</th></tr></thead><tbody><tr><td>静态变量（static 变量）</td><td>方法区（JDK 8+ 为元空间）</td><td>类加载时分配，类卸载时释放</td><td>属于类，所有对象共享</td></tr><tr><td>实例变量</td><td>堆（Heap）</td><td>对象创建时分配，垃圾回收时释放</td><td>属于对象，每个对象都有独立副本</td></tr><tr><td>局部变量</td><td>栈（Stack）</td><td>方法执行时分配，方法结束后释放</td><td>属于方法，只能在当前方法中访问</td></tr></tbody></table><p>类方法：</p><ul><li>随着类的加载而加载</li><li>静态方法内可以调用静态的属性或静态的方法，不可以调用非静态的结构。</li><li><code>static</code>修饰的方法内不能使用<code>this</code>和<code>super</code>，因为<code>static</code>是属于<strong>类</strong>的，而<code>this</code>和<code>super</code>代表的是当前对象和当前对象的父类部分，他们都需要依赖于<strong>对象</strong>。同理，就算对象是一个空指针，也能正常调用静态的属性和方法，因为<code>static</code>不依赖于对象。</li></ul><p>什么时候需要<code>static</code>？</p><ul><li>当前的多个实例需要共享此成员变量</li><li>一些常量，比如PI</li></ul><p>什么时候要用静态方法？</p><ul><li>方法内要操作的变量都是静态变量时</li><li>工具类中的方法，比如<code>Arrays</code>，<code>Math</code>类</li></ul><h1 id="单例设计模式">单例设计模式</h1><p>单例(Singleton)设计模式，即每个类只能存在一个实例（即只能通过特定方法获取实例，不可随意创建），并提供一个全局访问点来获取该实例。</p><h2 id="饿汉式eager">饿汉式(Eager)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 提前创建实例</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-comment">//使用getter方法获取当前实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>线程安全，在类加载时就创建实例，但是占用了一定内存，生命周期过长。</li><li>适用于实例创建开销小且使用频繁的场景。</li></ul><h2 id="懒汉式lazy">懒汉式(Lazy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 只有在需要时才创建</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>延迟加载，在需要使用的时候再创建</li><li>线程不安全，如果多个线程同时调用<code>getInstance()</code>，可能会创建多个实例。</li></ul><h1 id="类的成员代码块">类的成员：代码块</h1><p>Java的代码块可以分为<strong>普通代码块、构造代码块、静态代码块、同步代码块</strong>。</p><table><thead><tr><th>代码块类型</th><th>关键字</th><th>触发时机</th><th>执行次数</th><th>作用</th></tr></thead><tbody><tr><td>普通代码块</td><td><code>&#123;&#125;</code></td><td>代码运行到该块时</td><td>多次</td><td>限定变量作用域，提高可读性</td></tr><tr><td>构造代码块</td><td><code>&#123;&#125;</code>（类中，不在方法内）</td><td>每次创建对象时</td><td>每次创建对象时执行</td><td>初始化对象公共属性，避免构造方法重复代码</td></tr><tr><td>静态代码块</td><td><code>static &#123;&#125;</code></td><td>类加载时</td><td>只执行一次</td><td>初始化静态变量，执行类级别的初始化</td></tr><tr><td>同步代码块</td><td><code>synchronized &#123;&#125;</code></td><td>代码执行时</td><td>多次</td><td>线程同步，保证线程安全</td></tr></tbody></table><p>普通代码块也可以放在类内方法外，这时用于初始化属性。执行顺序是静态代码块-普通代码块-构造器-其余方法。</p><p>代码块的加载顺序<strong>先于</strong>构造器，功能大差不差，初始化的操作在构造器里也可以实现。</p><h1 id="类的属性赋值">类的属性赋值</h1><p><img src="https://i.imgur.com/0g6owHM.png" /></p><h1 id="关键字final">关键字final</h1><p><code>final</code>可用来修饰类、方法、变量。</p><ol type="1"><li><code>final</code>修饰类；表示此类不能被继承。例如：<code>String</code><code>StringBuilder</code></li><li><code>final</code>修饰方法：表示此方法不能被重写。例如：<code>getClass()</code></li><li><code>final</code>修饰变量：成员变量或局部变量。此时变量其实就变成了常量，一旦赋值就不可更改。</li></ol><p><code>final</code>修饰成员变量可以显式赋值、构造器赋值、代码块赋值。</p><p><code>final</code>修饰局部变量：一旦赋值就不可更改。形参/方法内的局部变量。</p><p><code>final</code>与<code>static</code>搭配：成员变量称之为<strong>全局常量</strong>，例如<code>Math.PI</code></p><h1 id="abstract-class">Abstract Class</h1><p>抽象类是 Java中的一种特殊类，<strong>不能被实例化</strong>，通常用作<strong>基类</strong>，用于定义通用的行为和结构。它可以包含<strong>抽象方法</strong>（没有方法体的方法）和<strong>具体方法</strong>（有方法体的方法）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法（无方法体）</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 具体方法（有方法体）</span><br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>abstract</code>关键字。</li><li>抽象类其实是包含构造器的，因为子类对象实例化时，需要调用父类的构造器。</li><li>抽象类中可以没有抽象方法。</li><li>子类必须重写抽象类中的所有抽象方法之后才能实例化，否则子类仍然是抽象类。</li></ul><p><strong>使用场景</strong>：</p><ul><li>定义统一的接口，让不同的子类提供具体的实现。抽象类中只提供通用的逻辑，至于扩展特定的功能则交给子类的重写(Implement)。</li></ul><h1 id="接口">接口</h1><h2 id="概述">概述</h2><p>接口(interface)的本质是一组方法的规范。关键字：<code>interface</code>，</p><p>接口内部的说明：</p><ul><li>属性：不能包含实例变量，但可以有用<code>public static final</code>修饰（默认自带）。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">// 等价于 public static final int MAX_AGE = 100;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法：声明抽象方法，修饰为<code>public abstract</code>（可以省略，默认自带）。</li><li><strong>不能有构造器</strong>（接口<strong>不能被实例化</strong>）。</li></ul><p><strong>接口与类的关系</strong>：使用<code>implements</code>关键字让一个类实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则</strong>：</p><ol type="1"><li>类必须实现接口中的<strong>所有</strong>方法，否则必须将类定义为<code>abstract</code>。</li><li>一个类可以实现<strong>多个接口</strong>（不像继承，Java只能单继承）。</li><li>类可以同时继承和实现：<code>class A extends SuperA implements B,C&#123;&#125;</code></li></ol><p>接口与接口可以多继承，类只能单继承。</p><h2 id="接口的多态性">接口的多态性</h2><p><code>接口名 变量名 = new 实现类</code> 非常常用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//多态</span><br>        a.eat();<br>        a.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区分抽象类和接口</strong>：</p><ul><li>共性：都可以声明抽象方法，都不能实例化</li><li>不同：抽象类一定有构造器，接口没有构造器；</li></ul><p>接口中声明的静态方法（java8引入）只能被接口调用，不能被其实现类调用。</p><p>从java8开始，接口可以有<code>default</code>方法，允许提供默认实现。默认方法可以被实现类继承，可以被实现类重写，不过在多实现时要注意重名问题（接口冲突），接口冲突时必须重写该方法。</p><p>java9允许接口定义<strong>私有方法</strong>，只在内部使用。</p><h1 id="类的成员内部类">类的成员：内部类</h1><h2 id="概述-1">概述</h2><p><strong>内部类(innerClass)</strong>：某个类A的内部还有一个部分需要一个完整的结构B来描述，B只为A服务，不在其他地方使用。A称为外部类，B称为内部类。</p><p>举例：<code>Thread</code>类内部的<code>State</code>类，表示线程的生命周期。</p><h2 id="分类">分类</h2><h3 id="成员内部类member-inner-class">1.成员内部类(Member InnerClass)</h3><ul><li>直接声明在外部类的里面，和成员变量一个位置。<ul><li>使用static修饰的：静态成员内部类</li><li>不使用static修饰的：非静态的成员内部类</li></ul></li><li>从类的角度看：<ul><li>内部可以声明类应有的结构</li><li>此内部类可以声明父类，实现接口</li><li>可以使用final修饰</li><li>也可以使用abstract</li></ul></li><li>从外部类的成员的角度：<ul><li>内部可以调用外部的结构</li><li>可以使用4种权限修饰符</li><li>可以使用static</li></ul></li></ul><h3 id="局部内部类local-inner-class">2.局部内部类(Local InnerClass)</h3><ul><li>声明在方法内部内、构造器内或代码块内的内部类<ul><li>匿名的成员内部类</li><li>非匿名的成员内部类</li></ul></li></ul><p><mark>匿名内部类的创建</mark></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()&#123;<span class="hljs-comment">//创建一个继承于Object的匿名子类</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>            &#125;<br>        &#125;.test();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以无错误无警告地运行。</p><h1 id="枚举类">枚举类</h1><h2 id="概述-2">概述</h2><p>枚举属于<strong>引用数据类型</strong>，关键词：<code>enum</code>，枚举里面定义的是已经生成且固定下来的对象，实际上枚举中的每一个枚举值都是一个<code>public static final</code>实例。</p><blockquote><p>当我们使用“enum”定义枚举类型时，实质上我们定义出来的类型继承自java.lang.Enum类型，而枚举的成员其实就是我们定义的枚举类型的一个实例（Instance），他们都被预设为final，所以我们无法改变他们，他们也是static成员，所以我们可以通过类型名称直接使用他们，当然最重要的，他们都是公开的（public）。</p></blockquote><h2 id="enum的比较">enum的比较</h2><p>一般来说引用数据类型的中比较要使用<code>.equals()</code>，但是<code>enum</code>类型是例外，也可以使用<code>==</code>，这是因为每个枚举类型的常量在JVM中只有唯一的一个实例，所以两种比较方法都完全正确。</p><h2 id="enum类型">enum类型</h2><p><code>enum</code>定义的类型与一般的<code>class</code>没有任何区别，<code>enum</code>就是<code>class</code>。有以下特点：</p><ul><li><code>enum</code>继承自<code>java.lang.Enum</code>，<strong>不可以显式地定义其父类</strong>，而且无法被继承；</li><li>无法使用<code>new</code>创建新的枚举，因为枚举类型在编译时就已经固定下来。</li></ul><p>使用<code>enum</code>关键词创建的枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>与下面这种写法基本等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span> &#123; <span class="hljs-comment">// 继承自Enum，标记为final class</span><br>    <span class="hljs-comment">// 每个实例均为全局唯一:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">GREEN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-comment">// private构造方法，确保外部无法调用new操作符:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然每一个枚举的值都是<code>enum</code>类的一个实例。既然是实例，就应当可以调用方法；实际上<code>Enum.java</code>中已经提供了一些用于枚举值的方法。</p><h2 id="enum的常用方法">enum的常用方法</h2><p><code>name()</code>:返回常量名，定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ordinal()</code>:返回定义的常量的定义的顺序（整型），从0开始计数。</p><p><code>values()</code>:数组变量，储存枚举类所有对象的信息。</p><h2 id="枚举类实现接口的操作">枚举类实现接口的操作</h2><ol type="1"><li>枚举类实现接口，在枚举类中实现所需方法，通过枚举类的对象调用的是<strong>同一个</strong>方法（与普通类一样）</li><li>让每一个枚举类的对象<strong>分别</strong>重写方法，匿名的内部类。</li></ol><h1 id="注解annotation">注解(Annotation)</h1><p>常见的Java内置注解：</p><p><code>@override</code>用于检查重写方法是否写对。</p><p><code>@Deprecated</code>表示某个类或方法已经<strong>不推荐使用</strong>，调用时会有警告提示。调用被它标记的类或方法时会出现删除线。</p><p><code>@SuppressWarnings</code>告诉编译器<strong>忽略特定类型的警告</strong>。</p><p>框架 = 注解 + 反射 + 设计模式</p><p>元注解：注解的注解</p><h1 id="包装类">包装类</h1><p>包装类是为每种基本数据类型提供的一个形式封装，让基本数据类型可以像引用数据类型一样使用。</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr></tbody></table><p>包装类和对应的基本数据类型的内存地址也不一样：</p><p><img src="https://i.imgur.com/DIlCOZj.png" /></p><p><code>xxx.valueOf(...)</code><strong>手动</strong>将基本数据类型转化为引用数据类型，返回一个引用数据类型的新实例。</p><ul><li><p>已经创建的包装类的值可以修改吗？<strong>不可以</strong>，例如<code>Interger</code>是不可变对象，一旦被创建，值不可修改。</p></li><li><p><strong>装箱</strong>：Boxing，将一个基本数据类型转换为对应的包装类对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(a);  <span class="hljs-comment">// 手动装箱</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>自动装箱</strong>：Autoboxing，Java5引入，直接把基本类型赋给包装类变量，Java编译器会自动帮你调用装箱的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">// 自动装箱：相当于 Integer.valueOf(a)</span><br></code></pre></td></tr></table></figure></p></li></ul><h1 id="string数据类型转换">String数据类型转换</h1><h2 id="基本数据类型包装类string">基本数据类型、包装类——&gt;String</h2><ol type="1"><li>直接调用<code>String xxx = String.valueOf(...);</code></li><li>也可以<code>String = xxx + "";</code></li></ol><h2 id="string基本数据类型包装类">String——&gt;基本数据类型、包装类</h2><p>调用包装类的静态方法<code>pasrsexxx</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><h1 id="常量池机制">常量池机制</h1><p>例如：自动装箱使用的<code>valueOf()</code>方法有缓存机制，<code>Integer</code>缓存-128~127，超出这个范围才会新建对象。</p><p>Java 中的“常量池(ConstantPool)”是一种<strong>优化内存使用和执行效率的机制</strong>。它的本质是一个用于存放常量（字面量、符号引用等）的特殊内存区域，目的是为了重用相同的值，避免重复创建对象。</p><h1 id="idea常用快捷键">IDEA常用快捷键</h1><table><thead><tr><th>功能说明</th><th>快捷键</th></tr></thead><tbody><tr><td>智能提示 - <em>edit</em></td><td><code>Alt + Enter</code></td></tr><tr><td>提示代码模板 - <em>insert live template</em></td><td><code>Ctrl + J</code></td></tr><tr><td>使用 xx 块环绕 - <em>surround with...</em></td><td><code>Ctrl + Alt + T</code></td></tr><tr><td>调出生成 getter/setter/构造器等结构</td><td><code>Alt + Insert</code></td></tr><tr><td>自动生成返回值变量 - <em>introduce variable</em></td><td><code>Ctrl + Alt + V</code></td></tr><tr><td>复制指定行的代码 - <em>duplicate line</em></td><td><code>Ctrl + D</code></td></tr><tr><td>删除指定行的代码 - <em>delete line</em></td><td><code>Ctrl + Y</code></td></tr><tr><td>切换到下一行代码空位 - <em>start new line</em></td><td><code>Shift + Enter</code></td></tr><tr><td>切换到上一行代码空位 - <em>start new line before current</em></td><td><code>Ctrl + Alt + Enter</code></td></tr><tr><td>向上移动代码 - <em>move statement up</em></td><td><code>Ctrl + Shift + ↑</code></td></tr><tr><td>向下移动代码 - <em>move statement down</em></td><td><code>Ctrl + Shift + ↓</code></td></tr><tr><td>向上移动行 - <em>move line up</em></td><td><code>Alt + Shift + ↑</code></td></tr><tr><td>向下移动行 - <em>move line down</em></td><td><code>Alt + Shift + ↓</code></td></tr><tr><td>查看方法参数提示 - <em>parameter info</em></td><td><code>Ctrl + P</code></td></tr><tr><td>重写父类的方法</td><td><code>Ctrl + O</code></td></tr><tr><td>实现接口的方法</td><td><code>Ctrl + I</code></td></tr><tr><td>查看继承树</td><td><code>Ctrl + H</code></td></tr><tr><td>类的UML关系图</td><td><code>Ctrl + Alt + U</code></td></tr><tr><td>定位某行、列</td><td><code>Ctrl + G</code></td></tr><tr><td>搜索</td><td><code>Ctrl + F</code></td></tr><tr><td>查找替换</td><td><code>Ctrl + R</code></td></tr><tr><td>全项目搜索文本</td><td><code>Ctrl + Shift + F</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-面向对象-中级</title>
    <link href="/2025/03/30/java3/"/>
    <url>/2025/03/30/java3/</url>
    
    <content type="html"><![CDATA[<h1 id="this关键词">this关键词</h1><p>用<code>this</code>关键词可用来避免形参名和属性名<strong>重名</strong>的问题。简单来说，<strong>哪个对象调用，<code>this</code>就指向这个对象</strong>。</p><p><code>this</code>还可以用来<strong>调用构造器</strong>（即构造方法重载）：</p><ul><li>必须是构造方法的<strong>第一行</strong></li><li>在一个构造器中最多声明一个<code>this(形参列表)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">This</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;Unknown&quot;</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//此处this调用了This()构造器</span><br>        <span class="hljs-comment">//等价于：this.name = &quot;Unknown&quot;;this.age=0;</span><br>        System.out.println(<span class="hljs-string">&quot;This is the default constructor&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//以下为this调用属性：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name: &quot;</span> + name + <span class="hljs-string">&quot;, age: &quot;</span> + age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Getter</code>和<code>Setter</code>方法的快速调用：<code>alt + Insert</code>。</p><h1 id="面向对象的继承性">面向对象的继承性</h1><p>继承(inheritance)，关键词：<code>extends</code>，子类(subclass)继承父类(superclass)的属性和方法。</p><h2 id="优势">优势</h2><ol type="1"><li>减少代码冗余，提高代码的复用性</li><li>更利于功能的扩展</li><li>为多态的使用创造了前提</li><li>描述事物之间的所属关系，父类更为通用</li><li>继承不影响父类的封装性</li></ol><h2 id="语法">语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Java中声明的类，如果没有显式的声明其父类，则默认继承于<code>java.lang.object</code></li><li>Java只支持单继承，不支持多继承，一个子类只能有一个父类</li></ul><h2 id="protected-权限修饰符">protected 权限修饰符</h2><p>声明为 protected 的成员可以被以下范围访问：</p><ol type="1"><li>同一个类 ✅（当然可以访问）</li><li>同一个包中的其他类 ✅（包内可以访问）</li><li>子类（无论是否在同一个包） ✅（继承后可以访问）</li><li>不同包中的非子类 ❌（不能访问）</li></ol><p>应用场景：</p><ul><li>用于子类的继承，子类可以访问<code>protected</code>的方法和变量。</li></ul><h1 id="方法的重写">方法的重写</h1><p>方法重写(override)指的是子类对从父类继承的方法进行重新实现，提供不同的功能。</p><ul><li>必须发生在父类和子类之间</li><li>方法名和参数列表必须相同</li><li>子类的访问权限不能比父类更严格，不能重写<code>private</code>方法</li><li>只能重写非static方法，static方法不能被重写</li><li>可使用<code>@Override</code>注解</li><li>关于返回值类型：<br />父类void，则重写必须void;<br />父类基本数据类型，则子类重写必须相同数据类型；<br />父类引用数据类型，则子类的返回值数据类型可以相同或是其子类</li></ul><p>区分方法的重载与重写：</p><table><thead><tr><th>特性</th><th>方法重写（Override）</th><th>方法重载（Overload）</th></tr></thead><tbody><tr><td><strong>发生范围</strong></td><td>子类和父类</td><td>同一个类</td></tr><tr><td><strong>方法名</strong></td><td>必须相同</td><td>必须相同</td></tr><tr><td><strong>参数列表</strong></td><td>必须相同</td><td>必须不同（参数个数或类型不同）</td></tr><tr><td><strong>返回值类型</strong></td><td>必须兼容（可以是协变返回类型）</td><td>可以不同</td></tr><tr><td><strong>访问修饰符</strong></td><td>不能比父类更严格</td><td>没有限制</td></tr><tr><td><strong>关键字</strong></td><td>可以使用 <code>@Override</code></td><td>不需要 <code>@Override</code></td></tr></tbody></table><ul><li>关键词<code>super</code>可以在存在重写的情况下调用父类中的方法，或是用来区分子类和父类中同名的属性。</li><li>子类不会继承父类的构造器，<code>super(形参列表)</code>可以调用父类的构造器，放在构造器的<strong>首行</strong>。</li><li>子类构造器默认隐式调用父类的无参构造器，<code>super()</code>，</li><li>若父类为有参构造器，则子类必须也显式调用父类的有参构造器</li><li>子类中使用<code>this</code>调用同一类中的其他构造器，用<code>super</code>调用父类的构造器，<strong>二者不能共存</strong></li></ul><h1 id="面向对象的多态性">面向对象的多态性</h1><p>多态性(Polymorphism)的使用前提： 1. 要有类的继承关系 2.要有方法的<strong>重写</strong></p><p>多态性适用于方法，不适用于属性。</p><p>缺陷：父类引用的子类无法调用子类特有的方法。</p><p>如果要判断某个对象是否属于某个类的实例，可以用<code>instanceof</code>关键字：<code>A instanceof B</code>，直接用于条件判断。</p><p>多态可以通过向下转型提取出子类，从而可以调用子类的方法。在向下转型之前，可以使用<code>instanceof</code>进行判断，避免出现异常。</p><p>多态的好处：减少了大量的重载的方法的定义；开闭原则</p><h1 id="object类">Object类</h1><p><code>java.lang.Object</code>是类层次结构的根类，是所有其他类的父类。</p><p><img src="https://i.imgur.com/aJ69aSq.png" /></p><p>重点方法：<code>equals()</code> <code>toStriung()</code><br />了解方法：<code>clone()</code> <code>finalize()</code><br />其他：<code>getClass()</code> <code>hashCode()</code><code>notify()</code> <code>wait()</code></p><h2 id="equals">equals()</h2><ul><li>自定义的类，在没有重写Object和equals()方法的情况下，调用的就是Object中声明的equals()，即比较两个引用对象的<strong>地址</strong>是否相同</li><li>对于<code>String</code> <code>File</code><code>Date</code>和包装类等，都重写了Object中的equals()方法，用于比较两个对象的实体<strong>内容</strong>是否相等。</li><li>通常需要重写equals()，以便按照值（内容）进行比较，可用IDEA自动生成。</li></ul><p><strong>IDEA自动生成的格式</strong>：</p><p>以Customer类为例:</p><table><thead><tr><th>Customer</th></tr></thead><tbody><tr><td>- name: String</td></tr><tr><td>- age: int</td></tr><tr><td>- acct: Account</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span> <span class="hljs-comment">//注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若对象为空，或者不属于同一个类，则直接false</span><br>    <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (Customer) o;<span class="hljs-comment">//在确定同类的情况下，向下转型</span><br>    <span class="hljs-keyword">return</span> age == customer.age &amp;&amp; Objects.equals(name, customer.name) &amp;&amp; Objects.equals(acct, customer.acct);<br>    <span class="hljs-comment">//如果两个对象的所有属性全部相同，则返回true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分和equals">区分<code>==</code>和<code>equals()</code></h3><p><code>==</code>：运算符</p><ol type="1"><li>适用范围：基本数据类型，引用数据类型</li><li>基本数据类型：判断数据值是否相等</li><li>引用数据类型：比较两个引用变量地址值是否相等</li></ol><p><code>equals()</code>：</p><ol type="1"><li>只能用于引用数据类型</li><li>具体使用：见上</li></ol><h2 id="tostring">toString()</h2><p>Object类中toString的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中的使用场景：</p><ul><li><code>System.out.println()</code>打印的其实就是对象的<code>toString()</code></li></ul><p>子类使用说明：</p><ul><li>自定义的类没有重写该方法的情况下，默认返回的是对象的地址值。</li><li><code>String</code> <code>File</code><code>Date</code>等Object的子类都重写了该方法，调用时返回当前对象的实体内容。</li></ul><p>开发使用说明：</p><ul><li>习惯上，自定义的类会重写toString。</li></ul><p>仍以Customer类为例，自动生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&quot;, acct=&quot;</span> + acct +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(2) 面向对象-基础</title>
    <link href="/2025/03/28/java2/"/>
    <url>/2025/03/28/java2/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的基本概念">面向对象的基本概念</h1><p>类（class）和对象（object）是面向对象的核心概念。</p><p><strong>类</strong>：具有相同特征的一大类事物</p><p><strong>对象</strong>：实际存在的该类事物的每个个体，也被称为实例（instance）。</p><p>面向对象内容的三大主线：</p><ul><li>Java类及类的成员：属性，方法，构造器；代码块、内部类。</li><li>面向对象的特征：封装、继承、多态、（抽象）</li><li>其他关键词的使用：this,super,package,import,static,final,interface,abstract等</li></ul><p>类，是一组相关<strong>属性</strong>和<strong>行为</strong>的集合，属性(field)即成员变量，行为即方法(method)。</p><h1 id="内存结构">内存结构</h1><ul><li>栈（stack）：方法内定义的变量，储存在栈中</li><li>堆（heap）：new创建的结构</li></ul><p>例如：</p><p>创建单个对象：</p><p><img src="https://i.imgur.com/Q9v6R16.png" /></p><p>创建多个对象：</p><p><img src="https://i.imgur.com/IdTtXZe.png" /></p><h1 id="类的成员属性">类的成员：属性</h1><p>Field:字段/域/成员变量</p><blockquote><p>Java中，一个类包含的变量被称为字段（Field）或成员变量。当这些变量通过getter/setter 方法暴露时，我们称其为“属性”（Property）。</p></blockquote><p>实例变量：类的对象拥有的变量，每个对象都有自己的一份。</p><p><strong>变量的分类</strong>：</p><p>按照数据类型来分：基本数据类型、引用数据类型</p><p>按照声明的位置来分：</p><ul><li>在方法体外，类体内声明的变量为<strong>成员变量</strong></li><li>在方法体内部等位置声明的变量为<strong>局部变量</strong></li></ul><p><img src="https://i.imgur.com/xx6LrzF.png" /></p><p>成员变量和局部变量在内存中分配的位置不同：</p><ul><li>成员变量（属性）存储在堆空间</li><li>局部变量存储在栈空间</li></ul><p><strong>生命周期</strong>：</p><ul><li>属性在对象创建时分配，销毁时释放。</li><li>局部变量随着方法对应的栈帧入栈，出栈而消亡。</li></ul><p><strong>是否有默认值</strong>：属性都有默认值，局部变量都没有默认值，必须先赋值再调用。</p><p>声明变量时，<code>static</code>关键字用<strong>于静态变量</strong>，访问时不需要创建对象，所有对象访问的是同一个变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 静态变量</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Example.num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 直接用类名访问</span><br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        System.out.println(obj1.num); <span class="hljs-comment">// 20</span><br>        System.out.println(obj2.num); <span class="hljs-comment">// 20（所有对象访问的是同一个变量）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态变量在程序运行期间一直存在，类加载时分配，程序结束时释放。</p><h1 id="类的成员方法">类的成员：方法</h1><p>作用：类似C语言的函数，简化代码。</p><p>Java的方法<strong>不能独立存在</strong>，必须定义在类里。</p><h2 id="声明的格式">1.声明的格式</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">权限修饰符 <span class="hljs-selector-attr">[其他修饰符]</span> 返回值类型 方法名(形参列表) <span class="hljs-selector-attr">[throws 异常类型]</span> &#123; <span class="hljs-comment">//方法头</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>权限修饰符</strong>：private  缺省  protected  public</p></blockquote><blockquote><p>形参列表的格式：(类型1 形参1,类型2 形参2, ...)</p></blockquote><h2id="对象调用方法时的内存分配情况">2.对象调用方法时的内存分配情况</h2><p>在 Java 中，当对象调用方法时，内存主要分为三个区域：</p><ol type="1"><li>堆（Heap） - 存放对象实例和实例变量。</li><li>栈（Stack） -存放方法调用时的局部变量、方法执行环境（方法帧）。</li><li>方法区（Method Area） -存放类的字节码信息、静态变量、方法元信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name; <span class="hljs-comment">// 实例变量（存放在堆内存）</span><br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 局部变量（存放在栈内存）</span><br>        System.out.println(greeting);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/***************************************************/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 创建对象，存入堆</span><br>        p1.sayHello(); <span class="hljs-comment">// 调用方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 方法调用遵循“先入后出”的栈规则</span><br><span class="hljs-comment">* main入栈-sayHello入栈-sayHello出栈-main出栈-程序结束，JVM退出</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol type="1"><li>对象 (<code>Person</code>) 创建在堆内存，实例变量(<code>name</code>) 也存放在堆。</li><li>方法调用时，会创建<strong>栈帧</strong>，局部变量存入栈内存，方法执行完后自动释放。</li><li>类的字节码信息存储在方法区，所有对象共享。</li><li><code>p1</code> 变量存放在栈内存，指向堆中的 <code>Person</code>对象。</li></ol><h1 id="对象数组">对象数组</h1><p>当数组的元素是引用类型的类(class)时，称之为对象数组。</p><p>创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名[] 数组名 = <span class="hljs-keyword">new</span> 类名[数组大小];<br></code></pre></td></tr></table></figure><h1 id="方法的应用">方法的应用</h1><h2 id="方法的重载">1.方法的重载</h2><p>方法重载（MethodOverloading）指的是在<strong>同一个类</strong>中，<strong>多个方法的名字相同，但参数列表不同</strong>（参数的类型、个数或顺序不同）。</p><p>方法的重载与形参名、权限修饰符、返回值的类型都没有关系。</p><p>编译器如何确定调用的是哪一个具体的方法？：先通过方法名，再通过形参列表。</p><p>坑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<br>System.out.println(arr);<br></code></pre></td></tr></table></figure><p>打印出来的结果是<code>abcdef</code>，而不是地址值。</p><h2 id="可变个数形参的方法">2.可变个数形参的方法</h2><p>在 Java 中，<strong>可变参数</strong>（Varargs，VariableArguments）允许一个方法接受<strong>可变数量的参数</strong>，使代码更加灵活。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">返回值类型 方法名(数据类型... 变量名) &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数在方法内部被当作<strong>数组</strong>处理，如<code>int... numbers</code>实际上等价于<code>int[] numbers</code>。</li><li>可变参数必须是方法的最后一个参数。</li><li>一个方法只能有一个可变参数。</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Varargs2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">overload2</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">overload2</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> test.concat(<span class="hljs-string">&quot;=&quot;</span>,<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        System.out.println(info);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">overload2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concat</span><span class="hljs-params">(String operator,String ... strs)</span>&#123;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">//拼接字符串时使用 StringBuilder可以避免频繁创建新的对象，性能更好</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;<br>                result.append(strs[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.append(operator).append(strs[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法的值传递机制">3.方法的值传递机制</h2><p>Java中方法的参数传递机制是<strong>按值传递(pass byvalue)</strong></p><p>方法体内声明的变量为局部变量，存储在栈空间。</p><ul><li>对于基本数据类型的变量来说，传递的是此变量保存的数据值。</li><li>对于引用型数据变量来说，传递的是此变量保存的地址值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 方法的值传递机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/29 15:45</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValue</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">method</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.change(num);<br>        System.out.println(<span class="hljs-string">&quot;num = &quot;</span> + num);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">method</span> &#123;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span> <span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        m ++;<br>        System.out.println(<span class="hljs-string">&quot;m: &quot;</span> + m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">m: <span class="hljs-number">11</span><br>num = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></p><p>图例：</p><p><img src="https://i.imgur.com/upVuJnq.png" /></p><h2 id="递归方法">4.递归方法</h2><p><strong>递归(Recursion)</strong>是指<strong>一个方法在其内部调用自己</strong>，直到满足某个终止条件（基准条件），否则会无限递归，导致<code>StackOverflowError</code>。</p><p>递归示例：计算阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">compute</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算一个数的阶乘（递归）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 输入一个整数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回输入值的阶乘结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//终止条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：递归的内存耗用较多，占用大量的系统堆栈，需要<strong>慎用</strong>，高性能情况下尽量避免使用递归，不如循环迭代。</p><h1 id="package和import">package和import</h1><p>用于<strong>定义类的所属包</strong>，必须写在<strong>Java文件的第一行</strong>（除了注释）。</p><ul><li>package命名全部小写</li><li>通常使用公司域名的倒置</li></ul><p>例：<strong>MVC(Model-Vie-Controller)</strong>软件架构模式：</p><table><thead><tr><th>组件</th><th>作用</th><th>示例（以 Java Web 应用为例）</th></tr></thead><tbody><tr><td><strong>Model（模型）</strong></td><td>处理 <strong>数据和业务逻辑</strong>，与数据库交互</td><td>Java Bean、DAO（数据访问对象）</td></tr><tr><td><strong>View（视图）</strong></td><td>负责 <strong>用户界面</strong>，展示数据</td><td>HTML、JSP、Thymeleaf、前端框架（Vue、React）</td></tr><tr><td><strong>Controller（控制器）</strong></td><td>负责 <strong>接收用户请求</strong>，调用 Model 处理数据，并返回View</td><td>Servlet、Spring Controller</td></tr></tbody></table><ul><li><code>import</code>用于引入其他包中的类，以便可以直接使用类名，而不必写完整路径。</li><li>在同一个包中的类不需要导入。</li><li>如果使用不同的包下的同名的类，需要使用类的全名的方式指明是哪个类例如：</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java.util.<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>java.sql.<span class="hljs-type">date1</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.sql.Date(<span class="hljs-number">121212L</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="面向对象的封装性">面向对象的封装性</h1><p>面向对象编程(OOP)的三大特性：<strong>封装、继承、多态</strong>。</p><h2 id="含义">含义</h2><p><strong>封装(Encapsulation)</strong>，指的是<strong>将对象的状态（属性）和行为（方法）封装在一起，并隐藏对象的内部实现细节</strong>，只向外界暴露必要的接口，以提高代码的<strong>安全性</strong>和<strong>可维护性</strong>。</p><p><code>高内聚、低耦合</code></p><h2 id="数据封装的方法">数据封装的方法</h2><p><strong>权限修饰符</strong>：<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code>，这体现了Java的封装性。我们可以用4种权限修饰符来修饰类和类的内部成员</p><p><strong>作用</strong>：体现被调用时的可见性的大小。声明为<code>private</code>的变量只能通过暴露的方法间接访问(赋值或取值)。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getnum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>四种权限修饰符的总结</strong>(按照可见性从小到大)：</p><table><thead><tr><th>访问修饰符</th><th>同包访问</th><th>跨包访问</th><th>子类访问</th><th>适用场景</th></tr></thead><tbody><tr><td><code>private</code></td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>适用于 <strong>完全封装</strong>，只能内部访问</td></tr><tr><td><code>default</code>（无修饰符）</td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>❌ 不能访问</td><td>适用于 <strong>包内使用</strong></td></tr><tr><td><code>protected</code></td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>✅ 继承后可访问</td><td>适用于 <strong>子类继承但不暴露给外部</strong></td></tr><tr><td><code>public</code></td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>适用于 <strong>完全公开</strong></td></tr></tbody></table><p><strong>封装性的体现</strong>：</p><ol type="1"><li>私有化类的属性，提供公共的get和set方法，对此属性进行获取或修改。</li><li>将类中不需要对外暴露的方法设置为private。</li><li>单例模式中构造器为private，避免在类的外部创建实例。</li></ol><h1 id="类的成员构造器">类的成员：构造器</h1><p>构造器（Constructor）是<strong>用于创建对象</strong>的特殊方法，它在创建对象时会自动调用，一般用于<strong>初始化对象的属性</strong>。</p><p>构造器的声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">权限修饰符 类名(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建类以后，在没有显式声明构造器的情况下，系统会默认提供一个构造器。且权限修饰符与类相同。</p><p>构造器可以重载。</p><hr /><p><strong>问1：main方法的public权限修饰符能不能换成private？</strong></p><ul><li><code>main</code>方法是 Java 程序的入口点，Java虚拟机（JVM）在执行程序时会调用<code>main</code>方法。如果<code>main</code>方法是<code>private</code>，JVM就无法访问它，导致程序启动失败。</li><li>同理，也不能是<code>protected</code>或缺省，否则JVM无法调用。</li></ul><p><strong>问2：为什么main方法必须是static?</strong></p><ul><li><code>main</code>方法是程序的入口，JVM在启动程序时不会自动创建类的对象，而是直接调用<code>main</code>方法。如果<code>main</code>不是<code>static</code>，那么JVM需要创建该类的对象，但没有默认构造方法可调用，因此会报错。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-基本常识</title>
    <link href="/2025/03/22/java1/"/>
    <url>/2025/03/22/java1/</url>
    
    <content type="html"><![CDATA[<p>学习顺序：javase、mysql、jdbc、javaweb、mybatis、springmvc、spring，这几样基本上就是学习java的骨架了。</p><h1 id="变量与运算符">变量与运算符</h1><h2 id="标识符的命名规范">标识符的命名规范</h2><ul><li>包名：多单词组成时所有字母都小写 xxxyyyzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写 XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写age,name,bookName</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接XXX_YYY_ZZZ</li></ul><h2 id="变量">变量</h2><p>变量（variable）定义：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p><p>构成：数据类型 变量名 = 变量值，例如：<code>int age = 10;</code></p><p>java的变量按照数据类型分为：</p><pre><code class="hljs">基本数据类型（8种）：      整型：byte \ short \ int \ long      浮点型：float \ double      字符型：char      布尔型：boolean  引用数据类型（6种）：    类（class）      数组（array）      接口（interface）      枚举（enum）      注解（annotation）      记录（record）</code></pre><p>变量都有其<strong>作用域</strong>，只在其作用域内有效。</p><h3 id="整型">整型</h3><p>byte  short  int  long 分别占用1，2，4，8字节（有正负）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1</td><td><code>-128</code> ~ <code>127</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td>2</td><td><code>-32,768</code> ~ <code>32,767</code></td><td><code>0</code></td></tr><tr><td><code>int</code></td><td>4</td><td><code>-2,147,483,648</code> ~ <code>2,147,483,647</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td>8</td><td><code>-9,223,372,036,854,775,808</code> ~<code>9,223,372,036,854,775,807</code></td><td><code>0L</code></td></tr></tbody></table><ul><li>定义<code>long</code>类型的变量，赋值时需要以“l”或“L”作为后缀。</li><li>Java程序中变量通常声明为<code>int</code>。</li><li>整数常量<strong>默认为int类型</strong>。</li></ul><h3 id="浮点型">浮点型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>精度</th></tr></thead><tbody><tr><td><code>float</code></td><td>4</td><td><code>±1.4E-45</code> ~ <code>±3.4028235E+38</code></td><td><code>0.0f</code></td><td>约 7 位</td></tr><tr><td><code>double</code></td><td>8</td><td><code>±4.9E-324</code> ~ <code>±1.7976931348623157E+308</code></td><td><code>0.0d</code></td><td>约 15~16 位</td></tr></tbody></table><ul><li>定义<code>float</code>类型的变量，赋值时需要以“f”或“F”作为后缀。</li><li>float的表示范围大于long，但是精度不高。</li><li>Java的浮点型常量<strong>默认为double型</strong>。</li><li>float、double不适用于不容许舍入误差的金融计算领域。如果需要精确数字计算或保留特定位数的精度，需要使用BigDecimal类。</li><li><code>IEEE 754标准</code>仍然不能实现“每一个十进制小数都对应一个二进制小数”，0.1+0.2不等于0.3</li></ul><h3 id="字符型">字符型</h3><ul><li>占用两个字节</li></ul><p>字符型变量的三种表现形式：</p><ol type="1"><li>单引号<code>''</code>适用于<strong>单个字符</strong></li><li>直接使用Unicode值表示。例如<code>char c8 = '\u0043';</code></li><li>使用转义字符''将后面的字符转变为字符型常量。</li><li>ASCII码</li></ol><h3 id="布尔型">布尔型</h3><ul><li>只有两个值：true、false，常常用在流程控制语句。</li><li>可以认为占4个字节（一般不谈布尔类型占用的空间大小）。具体来说：编译时不谈几个字节，但是JVM给boolean类型分配内存空间时，boolean类型的变量占据一个槽位（slot，等于4个字节）。</li></ul><h3 id="基本数据类型间的运算规则">基本数据类型间的运算规则</h3><ol type="1"><li><strong>自动类型提升</strong>：</li></ol><p>规则：容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。容量指可表示数据范围的大小。</p><p>byte---&gt;short---&gt;int---&gt;long---&gt;float---&gt;double</p><ul><li>特殊情况1：容量小于int做运算结果用int类型，否则报错，而且实际的开发中也基本用不上byte和short。</li><li>特殊情况2：char类型运算结果也用int类型，同上。</li></ul><ol start="2" type="1"><li><strong>强制类型转换</strong></li></ol><p>规则：大范围类型转换为小范围类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)d1;<br><br></code></pre></td></tr></table></figure><h3 id="string类">String类</h3><ol type="1"><li>String类属于引用数据类型，俗称字符串。</li><li>可以使用一对双引号进行赋值。</li></ol><p>String与基本数据类型间的运算：</p><ol type="1"><li>这里可以包含布尔变量在内共8种。</li><li>只能做连接运算，用+。</li></ol><h2 id="运算符">运算符</h2><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td>只有两个操作数都为 <code>true</code> 时，结果才为<code>true</code></td><td><code>true &amp;&amp; false</code> → <code>false</code></td></tr><tr><td><code>\|\|</code></td><td>逻辑或（OR）</td><td>只要有一个操作数为 <code>true</code>，结果就为<code>true</code></td><td><code>true \|\| false</code> → <code>true</code></td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）</td><td>取反运算，将 <code>true</code> 变 <code>false</code>，反之亦然</td><td><code>!true</code> → <code>false</code></td></tr><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>与 <code>&amp;&amp;</code>类似，但<strong>不会发生短路</strong></td><td><code>true &amp; false</code> → <code>false</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>与 <code>\|\|</code> 类似，但<strong>不会发生短路</strong></td><td><code>true \| false</code> → <code>true</code></td></tr><tr><td><code>^</code></td><td>逻辑异或（XOR）</td><td>只有两个操作数不相同时，结果才为 <code>true</code></td><td><code>true ^ false</code> → <code>true</code></td></tr></tbody></table><ul><li>逻辑运算符针对的是布尔型变量，结果也是布尔型。</li><li><code>&amp;&amp;</code>和<code>||</code><strong>具有短路特性</strong>，即在某些情况下可以<strong>提前确定最终结果</strong>，从而跳过后续运算，提高效率并避免不必要的计算。例如，<code>A &amp;&amp; B</code>只有当<code>A</code>为<code>true</code>时，才会计算<code>B</code>，如果<code>A</code>为<code>false</code>，那么结果必然为<code>false</code>，所以<code>B</code>会被直接跳过。对于<code>||</code>则反过来，如果<code>A</code>为<code>true</code>，那么不会计算<code>B</code>。</li></ul><h3 id="位运算符">位运算符</h3><p>难点、非重点</p><table style="width:100%;"><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>两个位都为 <code>1</code>，结果才为 <code>1</code></td><td><code>5 &amp; 3</code> → <code>101 &amp; 011 = 001</code> →<code>1</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>只要有一个位为 <code>1</code>，结果就是 <code>1</code></td><td><code>5 \| 3</code> → <code>101 \| 011 = 111</code> →<code>7</code></td></tr><tr><td><code>^</code></td><td>按位异或（XOR）</td><td>两个位不同则为 <code>1</code>，相同则为 <code>0</code></td><td><code>5 ^ 3</code> → <code>101 ^ 011 = 110</code> →<code>6</code></td></tr><tr><td><code>~</code></td><td>按位取反（NOT）</td><td>0 变 1，1 变 0（取反补码）</td><td><code>~5</code> → <code>~00000101</code> → <code>11111010</code>（即<code>-6</code>）</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移（Left Shift）</td><td>将二进制位左移 <code>n</code> 位，右侧补 <code>0</code></td><td><code>5 &lt;&lt; 2</code> → <code>101</code> → <code>10100</code> →<code>20</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移（Arithmetic Right Shift）</td><td>保持符号位，左侧补 <code>1</code> 或 <code>0</code></td><td><code>-5 &gt;&gt; 2</code> → <code>11111011</code> →<code>11111110</code> → <code>-2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移（Logical Right Shift）</td><td>左侧统一补 <code>0</code>，不保持符号位</td><td><code>-5 &gt;&gt;&gt; 2</code> → <code>11111011</code> →<code>00111110</code>（即 <code>1073741822</code>）</td></tr></tbody></table><p><strong>案例</strong>：如何交换两个int变量的值？String呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>        <span class="hljs-comment">//声明一个临时变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> m;<br>        m = n;<br>        n = temp;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件运算符">条件运算符</h3><p>(条件表达式) ? 表达式1 : 表达式2</p><p>条件表达式的结果是布尔类型。</p><h1 id="流程控制">流程控制</h1><h2 id="if-else">if-else</h2><p>与C语言相同，不赘述。</p><p>如何从键盘获取不同类型的变量：使用Scanner类。Scanner类中提供了获取不同类型变量的方法，除了char，需要使用<code>scan.next().charAt(0)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//提供（或创建）一个Scanner类的实例，这里创建了一个Scanner对象sc，用于接收用户的输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">//调用Scanner类中的方法，获取指定类型的变量，这里使用nextLine()读取整行文本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine();<br><br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + s);<br><br>        <span class="hljs-comment">//关闭资源，调用Scanner类的close()</span><br>        scan.close();<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><h2 id="获取随机数">获取随机数</h2><p>可以使用Java提供的API：Math类的random()（不用额外导包），返回一个[0.0,1.0)范围内的double随机数。</p><p>进一步的可以得到其他范围的随机数，例如[0,100]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><p>获取一个[a,b]范围的随机数：<code>(int)(Math.random() * (b - a + 1)) + a;</code></p><h2 id="switch-case">switch-case</h2><p>语法格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">//执行语句1</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">//执行语句2</span><br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//执行语句</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>switch中的表达式只能是特定的数据类型：byte  short  char  int 枚举(JDK5.0新增)  String(JDK7.0新增)</li><li>开发中使用switch-case时，通常case匹配的情况都有限。</li><li>default的位置是灵活的。</li></ul><h2 id="循环语句">循环语句</h2><p>共三种：for,while,do-while</p><p>循环的4个要素：</p><ol type="1"><li>初始化条件</li><li>循环条件</li><li>循环体</li><li>迭代部分</li></ol><h3 id="for循环">for循环</h3><p>for(1;2;4){<br />3<br />}</p><p>迭代部分含有多条语句时，可以用逗号连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输入两个正整数m和n，求最大公约数和最小公倍数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> m&lt;n?m:n;<br><br>        <span class="hljs-comment">//最大公约数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=min;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span> &amp;&amp; m%i==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最大公约数&quot;</span>+i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最小公倍数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> m&gt;n?m:n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=max;i&lt;=m*n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%m==<span class="hljs-number">0</span> &amp;&amp; i%n==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最小公倍数为&quot;</span> + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们可以在循环结构中使用break，用于跳出循环结构。</li><li>循环条件不满足/循环体中执行了break</li></ul><h3 id="while循环">while循环</h3><p>1 while(2){<br />3<br />4<br />}</p><p>练习：猜数字小游戏 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        随机生成一个1到100以内的整数，用户输入一个整数，记录猜了几次才正确</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>)+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//记录尝试的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//创建对象sc</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//输入数字</span><br>        System.out.println(<span class="hljs-string">&quot;Please enter a number between 1 and 100&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yourNumber</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">while</span>(yourNumber != randomNumber)&#123;<br>            <span class="hljs-keyword">if</span>(yourNumber &gt; randomNumber)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is greater than random number&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is less than random number&quot;</span>);<br>            &#125;<br>            guessNumber++;<br>            <span class="hljs-comment">//重新输入数字</span><br>            System.out.println(<span class="hljs-string">&quot;Please try again&quot;</span>);<br>            yourNumber = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//结束游戏</span><br>        System.out.println(<span class="hljs-string">&quot;congratulations!you have tried &quot;</span> + guessNumber + <span class="hljs-string">&quot; guesses&quot;</span>);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="do-while-循环">do-while 循环</h3><p>1<br />do{<br />3<br />4<br />}while(2);</p><p>执行过程：1 - 3 - 4 - 2 - 3 - 4 - ··· - 2</p><p>至少会执行一次循环体，用得相对来说比较少。</p><h3 id="无限循环结构">“无限”循环结构</h3><p>格式： while(true) 或 for(;;)，中途使用break跳出循环。</p><p>示例：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：九九乘法表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                System.out.print(i + <span class="hljs-string">&quot;*&quot;</span> + j + <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：找出100000以内的所有质数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)&#123;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<br>                <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)&#123;<br>                    isFlag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFlag)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;time spend: &quot;</span> + (endTime - startTime));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：<code>time spend: 35</code>，注意这里的Math.sqrt(i)可以大大提升运算速度，因为一个数的因数关于它的算术平方根对称。</p><h1 id="数组">数组</h1><h2 id="基础知识">基础知识</h2><p>多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，通过编号统一管理。</p><p>Java中的<strong>容器</strong>：数组、集合框架：在<strong>内存</strong>中对多个数据的存储。</p><p>数组属于<strong>引用数据类型</strong>，声明格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//如果已知初始值：</span><br><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">//如果未知初始值，需要动态创建：</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">//后续赋值时，直接引用元素，例如</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br>arr[<span class="hljs-number">3</span>] = <span class="hljs-number">40</span>;<br>arr[<span class="hljs-number">4</span>] = <span class="hljs-number">50</span>;<br><br></code></pre></td></tr></table></figure></p><ul><li>数组一旦初始化完成，其长度确定，并且无法更改。</li><li>内存中一整块连续的空间。</li><li>数组长度可以使用arr.length获取</li></ul><p><strong>数组元素的默认初始化值</strong></p><ul><li>整型：<code>0</code></li><li>浮点型：<code>0.0</code></li><li>字符型：<code>0</code>（对应<code>'\u0000'</code>）</li><li>boolean型：<code>false</code></li><li>引用数据类型：<code>null</code></li></ul><h2 id="算法案例">算法案例</h2><h3 id="生成回行数">生成回行数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiralMatrix</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入一个数字: &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.close();<br>        <br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-comment">// 从左到右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) matrix[top][i] = num++;<br>            top++;<br>            <br>            <span class="hljs-comment">// 从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) matrix[i][right] = num++;<br>            right--;<br>            <br>            <span class="hljs-comment">// 从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) matrix[bottom][i] = num++;<br>            bottom--;<br>            <br>            <span class="hljs-comment">// 从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) matrix[i][left] = num++;<br>            left++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 打印结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%3d &quot;</span>, matrix[i][j]);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数组的扩容">数组的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 现有数组 int[] arr = new int []&#123;1,2,3,4,5&#125;</span><br><span class="hljs-comment"> * 将数组的长度扩容1倍，将10，20，30添加到数组中，如何操作？</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/26 21:52</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">expansion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>        <span class="hljs-comment">//扩容1倍容量</span><br>        <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [arr.length*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">//复制到新的数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            newArr[i] = arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//添加新的数字</span><br>        newArr[arr.length] = <span class="hljs-number">10</span>;<br>        newArr[arr.length+<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>        newArr[arr.length+<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-comment">//将新的数组地址赋值给原有的数组变量</span><br>        arr = newArr;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newArr.length; i++) &#123;<br>            System.out.print(newArr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><ol type="1"><li>线性查找：遍历数组返回索引 复杂度：O(N)</li><li>二分法查找（适用于<strong>有序</strong>数组）复杂度：O(log₂N)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dichotomy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否找到了</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//默认的首索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//默认的尾索引</span><br><br>        <span class="hljs-keyword">while</span> (head &lt;= end) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> head + (end - head) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span>(target == arr[mid]) &#123;<br>                System.out.println(<span class="hljs-string">&quot;found it, the index is &quot;</span> + mid);<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;<br>                head = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;not found&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序算法">排序算法</h3><ol type="1"><li>时间复杂度：分析关键字的比较次数和记录移动的次数，记为<spanclass="math inline">\(O(n)\)</span></li><li>空间复杂度：分析排序算法中需要多少辅助内存，记为<spanclass="math inline">\(S(n)\)</span></li><li>稳定性：若两个值相等的A和B在排序后的前后顺序不变，则这种排序算法是稳定的</li></ol><p><strong>冒泡排序</strong>：</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bubbling</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>,<span class="hljs-number">55</span>,<span class="hljs-number">43</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">//打印初始数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">//打印排序后的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><p>时间复杂度： <span class="math inline">\(O(n\log(n))\)</span></p><h2 id="arrays工具类">Arrays工具类</h2><p><strong>判断两个数组是否相等</strong></p><p>位置：java.util</p><p>boolean equals(int[] a,int[] b):比较两个数组的元素是否<strong>依次相等</strong>。相等时返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEquals</span> <span class="hljs-operator">=</span> Arrays.equals(arr1,arr2);<br></code></pre></td></tr></table></figure><p><strong>输出数组信息</strong></p><p><code>System.out.println(Arrays.toString(arr1));</code></p><p><strong>填充</strong></p><p>将数组中的所有元素填充为指定的数值，例如：<code>Arrays.fill(arr1,22);</code></p><p><strong>排序</strong></p><p><code>Arrays.sort(arr3);</code>，使用快速排序算法</p><p>数组的索引，表示数组元素距离首地址的偏移量，第一个元素地址与首地址相同，偏移量为0，索引是0</p><p>案例：</p><blockquote><p>输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></blockquote><p><strong>卡丹算法</strong>(Kadane's Algorithm)，用<code>currentSum</code>记录以当前位置为结尾的子数组的最大和，<code>maxSum</code>记录所有子数组中的最大和。遍历数组，对于数组中的每个元素，最大子数组和只有两种可能：</p><ol type="1"><li><code>nums[i]</code>自己构成一个子数组，最大子数组和就是它自己</li><li><code>nums[i]</code>与前面的最大子数组和相加之后，得到的结果才是最大子数组和</li></ol><p>所以，<code>currentSum</code>每次都取以上两种情况中最大的一个。之后，更新<code>maxSum</code>，记录下这个最大值即可。实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，</span><br><span class="hljs-comment"> * 求所有子数组的和的最大值。要求时间复杂度为O(n)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/27 21:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建数组</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//子数组和的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//当前的子数组的和</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<span class="hljs-comment">//注意i从1开始计数，而不是0</span><br>            currentSum  = Math.max(currentSum + nums[i], nums[i]);<br>            maxSum = Math.max(maxSum, currentSum);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;maxSum is &quot;</span> + maxSum);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>卡丹算法只需要对数组进行一次遍历，因此时间复杂度是<spanclass="math inline">\(O(n)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Hexo博客绑定域名出现ERR_SSL_UNRECOGNIZED_NAME_ALERTu错误</title>
    <link href="/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近为这个博客网站新绑定了一个域名。因为我先前没有学过计算机网络相关的知识，遇到ERR_SSL_UNRECOGNIZED_NAME_ALERTu的报错的时候反应了半天才明白要去申请一个SSL证书，在此记录一下这次绑定域名的操作流程。</p><h1 id="参考链接">参考链接</h1><p>1.<ahref="https://cps.ninja/2016/10/09/customize-your-blog-domain/">为Github 上的 Hexo 博客绑定个性域名</a></p><p>2.<ahref="https://www.littlelittleblack.com/Hexo/20200508-self-server-url.html">在自架服务器上搭建Hexo博客并绑定域名</a></p><h1 id="操作流程">操作流程</h1><p>我最开始看的是第一个链接，在namesilo上购买一个域名，然后直接使用namesilo进行DNS解析。第一个链接里有一点没有说清楚：A记录的IP地址应当是<code>username.github.io</code>的IP地址，而不是github的地址。对此，github的<ahref="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">官方文档</a>中有详细的说明：</p><p><img src="https://i.imgur.com/ZMUsLHh.png" /></p><p>向DNS解析中加入4个A记录即可。</p><p>当然也可以通过ping的方式获取IP地址。按<code>win</code>+<code>R</code>输入<code>cmd</code>，再输入<code>ping username.github.io</code>，看一下返回的IP即可：</p><p><img src="https://i.imgur.com/OEH8zEM.png" /></p><p>这次返回的是<code>185.199.109.153</code>.</p><h1 id="踩坑">踩坑</h1><p>我按照链接1的步骤操作完成之后，发现新绑定域名后的博客仍无法打开，报错：</p><p><strong>嗯… 无法访问此页面 https://kznep19.blog/上的网页似乎有问题，或者可能已永久移动到新的 Web 地址。ERR_SSL_UNRECOGNIZED_NAME_ALERTu</strong></p><p>向浏览器中输入<code>username.github.io</code>，发现原来的地址也无法访问了。起初我以为是namesilo自带的DNS解析功能无法正常使用（因为namesilo的名声似乎不是很好），所以我仿照链接2将NDS解析转移到国内的DNSPod网站上，发现仍然是同样的报错，说明问题不在这里。</p><p>注意<code>ERR_SSL_UNRECOGNIZED_NAME_ALERTu</code>，对此ChatGPT的回答如下：</p><blockquote><p>ERR_SSL_UNRECOGNIZED_NAME_ALERT 是一个与 SSL/TLS连接相关的错误，通常出现在客户端和服务器进行加密通信时。这种错误表示客户端在请求时提供的主机名（如网址）没有在服务器的证书中正确匹配，或者服务器没有正确配置SSL/TLS 证书。</p></blockquote><p>“没有正确配置 SSL/TLS证书”，我查找资料的过程中没有见到说绑定域名需要单独配置SSL证书的教程。直到我看到了<ahref="https://github.com/lss233/chatgpt-mirai-qq-bot/issues/1146">这个网站</a>，里面提到</p><blockquote><p>浏览器报错 ERR_SSL_UNRECOGNIZED_NAME_ALERT<br />其意为 “错误 SSL 无法识别的名称警报"。应该因为你还未部署SSL证书💦。SSL证书是此服务必须的，去申请一个即可 🙏。</p></blockquote><p>于是我在<ahref="https://ohttps.com/monitor/dashboard">OHTTPS</a>中为这个域名免费申请了一个SSL证书，很快网站就能正常访问了，至此问题终于得到解决。</p><p>另外，不管是OHTTPS还是DNSPod提供的SSL证书发放服务，其免费证书的有效期都只有三个月，快到期的时候要不要忘了更换证书。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾记录</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>エルマ-ヨルシカ</title>
    <link href="/2025/01/07/Elma/"/>
    <url>/2025/01/07/Elma/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>朝日の差す木漏れ日　僕とエルマ</p><p>まだ　まだ眠いかい</p><p>初夏の初め近づく五月の森</p><hr /><p>歩きだした顔には花の雫</p><p>ほら　涙みたいだ</p><p>このまま欠伸をしよう</p><p>なんならまた椅子にでも座ろう</p><hr /><p>許せないことなんてないんだよ</p><p>君は優しくなんてなれる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ夜の深さも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>辛いことも苦しいことも何も見えないならわからないし</p><p>塞いだ目閉じたままで逃げた</p><p>月明かりの道を歩く</p><hr /><p>狭い部屋も冷たい夜も</p><p>眠い昼も　寂しい朝も</p><p>さよならの言葉越しに君の顔を見てる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ空の青さだけ見たままで</p><hr /><p>ただ君と終わりも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少女A</title>
    <link href="/2025/01/05/%E5%B0%91%E5%A5%B3A/"/>
    <url>/2025/01/05/%E5%B0%91%E5%A5%B3A/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>作詞：椎名もた（ぽわぽわP）</p><p>作曲：椎名もた（ぽわぽわP）</p><p>唄：鏡音リン</p><p>中文翻譯：https://home.gamer.com.tw/artwork.php?sn=5816671</p><hr /><p>僕の命ってったって　誰の命っつったって</p><p>即使說這是我的生命　即使說這是他人的生命</p><p>時々　公平に　裁かれるもんなんでしょ</p><p>偶爾　也會被公平地　受到裁決對吧</p><p>暗い空にやってきた　鬱を連れてやってきた</p><p>我抵達了漆黑的天空　並帶來了憂愁</p><p>時々雨　総計に　頼り切りだ　どうしよう</p><p>偶爾下起了雨　我總是　依賴著它　該怎麼辦呢</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>言葉を書く　曖昧に　言葉を書く　曖昧に</p><p>曖昧地　書寫著話語　曖昧地　書寫著話語</p><p>伝わりきらんないから　君だけをさ　信じて</p><p>因為根本無法全數傳達出去啊　所以我只　相信你一人</p><p>捨ててきた夢をあつめて</p><p>我開始收集起之前我所捨棄的夢想</p><p>ちょっと　ちょっと　間違えたから</p><p>因為這其中有些　有些　錯誤啊</p><p>ああ　「時に　時に　躓いたって、」</p><p>啊啊　「即使偶爾　偶爾　受到挫折、」　也還是</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　言い寄らないで</p><p>好冷好冷好冷好冷　別如此求愛啊</p><p>ああ　君の君の君の声が</p><p>啊啊　你的你的你的聲音十分</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い　傷つけないで</p><p>遙遠遙遠遙遠遙遠　別傷害我啊</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために？</p><p>我也希望我能保有自我？</p><p>契り集め持ってきた　契り集め持ってきた</p><p>我收集起來各種約定　我收集起來各種約定</p><p>あの日の間違いを　飲み込むのが苦るしくて</p><p>要理解那一天的誤會　實在是過於痛苦</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>「子供だましの花ふたつ、」</p><p>「欺騙小孩的兩束花、」</p><p>きっと　きっと　諦めたから？</p><p>一定　一定是因為　我放棄了？</p><p>ああ　遠い夢を追いかけてさ</p><p>啊啊　我追趕著遙遠的夢想　但夢想卻十分</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い　追いつけないよ</p><p>快速快速快速快速　我根本無法追上啊</p><p>捨てきれず残した思いが</p><p>我無法完全捨棄並遺留下來的感受讓人十分</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い　許されないの？</p><p>憎恨憎恨憎恨憎恨　不被他人原諒嗎？</p><p>ああ　夢を夢を見てたはずが</p><p>啊啊　我本應該正在做夢　但卻感到了</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い　近づかないで</p><p>恐懼恐懼恐懼恐懼　別靠近我啊</p><p>合言葉を繰り返すだけ</p><p>我只是不斷重複著暗語而已</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　お願いだから</p><p>好冷好冷好冷好冷　拜託你</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために…</p><p>我也希望我能保有自我…</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雨とカプチーノ - ヨルシカ</title>
    <link href="/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>灰色に白んだ言葉はカプチーノみたいな色してる</p><p>言い訳はいいよ　窓辺に置いてきて</p><p>数え切れないよ</p><hr /><p>灰色に白んだ心はカプチーノみたいな色をしてる</p><p>言い訳はいいよ　<ruby>呷<rt>あお</rt></ruby>ろうカプチーノ</p><p><ruby>戯<rt>おど</rt></ruby>けた振りをして</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないような思い出を</p><p>どうか、どうか、どうか君が溢れないように</p><hr /><p><ruby>波<rt>なみ</rt></ruby>待つ海岸　<ruby>紅<rt>くれない</rt></ruby>夕差す日</p><p>窓に反射して</p><p>八月のヴィスビー　<ruby>潮騒<rt>しおさい</rt></ruby></p><p>待ちぼうけ　海風一つで</p><hr /><p>夏泳いだ花の白さ、<ruby>宵<rt>よい</rt></ruby>の雨</p><p>流れる夜に溺れ</p><p>誰も褪せないような花一つ</p><p>どうか、どうか、どうか胸の内側に挿して</p><hr /><p>ずっとおかしいんだ</p><p>生き方一つを教えてほしいだけ</p><p>払えるものなんて僕にはもうないけど</p><p>何も答えられないなら言葉一つでもいいよ</p><p>わからないよ</p><p>本当にわからないんだよ</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないように書く詩を</p><p>どうか、どうか、どうか今も忘れないように</p><p>また一つ夏が終わって、花一つを胸に抱いて、</p><p>流れる<ruby>目蓋<rt>まぶた</rt></ruby>の裏で</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないようにこの詩を</p><p>どうか、どうか君が溢れないように</p><hr />]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神様のダンス - ヨルシカ</title>
    <link href="/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>忘れるなんて酷いだろ</p><p>幸せになんてなるものか</p><p>色のない何かが咲いた</p><p>君のいない夏に咲いた</p><hr /><p>人に笑われたくないから</p><p>怯えるように下を向く</p><p>心より大事な何かが</p><p>あってたまるものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>君を染め抜いた</p><p>見えないように僕を追い越して</p><p>行かないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、心まで醜い僕らだ</p><p>世界は僕らのものだ</p><hr /><p>音楽だけでいいんだろ</p><p>他人に合わせて歩くなよ</p><p>教えてくれたのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p><hr /><p>名もない花が綺麗のだ</p><p>どうでもいいことばっかだ</p><p>君の口癖が感染ってる</p><p>喉の真下には君がいる</p><hr /><p>言葉も生活も愛想も</p><p>全て捨ててこそ音楽だ</p><p>その価値も知らないあんたに</p><p>わかって堪るものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>僕を染め抜いた</p><p>いつか時間が全て追い抜いて</p><p>消えないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>世界の全部が欲しい</p><p>なぁ心まで醜いあんたの、想い出全部をくれよ</p><p>価値観だって自由なら</p><p>人を傷付けていいだろ</p><p>教えなかったのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も見てない場所で生きる真似をしてるのさ</p><p>酷い顔で踊るのさ</p><p>胸も痛いままで</p><hr /><p>神様僕たちなんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、言葉が世界だと云うなら、世界は僕らのものだ</p><p>忘れるなんて酷いだろ</p><p>幸せになんてなれるかよ</p><p>僕を歪めたのはあんたじゃないか</p><hr /><p>そうだった、僕はこのまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>レプリカント - ヨルシカ</title>
    <link href="/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>レプリカント - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>君は映画をずっと観ている<br />在空无一人的劇場之中</p><p>誰一人もない劇場で<br />你一个人独自看着電影</p><p>今思えばチープなセットで<br />那是部現在看来布景廉价</p><p>人のよく死ぬSF映画<br />常有人死去的科幻電影</p><p>いつか世界が真面になって<br />如果将来世界能變得積極美好</p><p>人の寿命さえ随分伸びて<br />人的寿命也无限延長</p><p>死ねない世界になればいいのにね<br />可以不用經歷死亡就好了</p><p>そしたら心以外は偽物だ<br />這樣一来 除了真心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>神様だって作品なんだから<br />因為神明也不過是个作品罷了</p><p>僕ら皆レプリカだ<br />我們全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時に<br />届時</p><hr /><p>僕は映画をずっと観ている<br />我一直在看着一部電影</p><p>つまらないほどに薄い映画<br />一部庸俗到无聊的電影</p><p>席を立ってからやっと気付く<br />起身离席時我才終于發現</p><p>これは僕を描いたドラマだ<br />劇情所講述的正是我自己的故事啊</p><p>いつか僕らは大人になって<br />我們終将長大成人</p><p>手に入れるものも大きくなった<br />所獲之物也日益重大</p><p>次は愛でも買えればいいのにね<br />接下来要是連愛也能買到就好了呢</p><p>あんたの価値観なんて偽物だ<br />你的価値観全都是虚假的</p><p>思い出だって偽物だ<br />連回憶也全都是虚假的</p><p>心は腦の信号なんだから<br />因為心思不過是大腦傳輸的信号罷了</p><p>愛も皆レプリカだ<br />所有的愛也全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>思い出ばかりが募って<br />只有回憶靜靜堆積</p><p>その時に<br />届時</p><hr /><p>満たされるならそれで良かった<br />只要能感到滿足就好</p><p>歌を歌うのに理由も無いは<br />歌唱并不需要理由</p><p>他人の為に生きられない<br />我不会為他人而活</p><p>さよなら以外全部塵<br />离别以外 全部如塵</p><p>人を呪う歌を描きたい<br />想譜寫出詛咒他人的歌</p><p>それで誰かを殺せればいいぜ<br />若是能借此取人性命就好了</p><p>夏の匂いに胸が詰まっていた<br />夏日的气息郁結滿懷</p><p>僕らの心以外は偽物だ<br />除了我們的心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>この世の全部は主観なんだから<br />因為世界全凭主觀而存在啊</p><p>君も皆レプリカだ<br />你也同樣是複製品</p><p>さよならだって投げ出して<br />豁出一切道别离开</p><p>このまま遠く逃げ出して<br />就這樣逃向遠方</p><p>言葉で全部表して<br />用語言来表述一切</p><p>心も愛も書き足して<br />添注上真心与愛</p><p>それでも空は酷く青いんだから<br />因為即便如此 天空仍是无可比擬的蔚藍</p><p>それはきっと魔法だから<br />那一定是魔法</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時にやっとわかる<br />届時才終于明白</p><p>僕もその青さがわかる<br />我也懂得那份蔚藍</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁相环CD4046使用心得</title>
    <link href="/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://i.imgur.com/ZpUo6qu.jpg" alt="成品" /><figcaption aria-hidden="true">成品</figcaption></figure><h1 id="前言">前言</h1><p>最近在忙着做校队招新的题目，要求是用锁相环CD4046B做一个倍频器，倍频系数为1，2，4，8，16，32，64。这个题最烦人的地方在于覆盖的频率范围很大，输入信号范围是1kHz~100kHz，这样来算输出最大要达到6.4MHz，然而以CD4046B来说这根本不可能，因为这款锁相环上集成的VCO的输出频率最大也就1MHz左右：</p><p><img src="https://i.imgur.com/51pBwa3.png" /></p><p>如你所见，输出最大频率的典型值为<strong>1.4MHz</strong>，这也基本符合我实测的结果。总之这题做满100kHz的64倍频基本是没戏了，但是听说有个组做到了7MHz？搞不懂是什么情况。（再吐槽一句，TI的CD4046B的数据手册真的太古老了啊，赶紧更新一下吧）</p><h1 id="引脚说明">引脚说明</h1><p><img src="https://i.imgur.com/Z91APjn.png" /></p><p>见上图。</p><ul><li>3；鉴相器输入</li><li>4：VCO输出</li><li>6、7之间的<spanclass="math inline">\(C_1\)</span>是VCO的起振电容</li><li>12脚<spanclass="math inline">\(R_2\)</span>决定了输出频率是否叠加一个偏置。如果不接，那么输出无偏置，频率就可以达到比较低的范围；如果接上电阻，频率范围整体会往上移动。</li><li>11脚<spanclass="math inline">\(R_1\)</span>也影响了输出频率·范围，R1越小输出频率越大，我这里取的是10k欧。</li><li>5脚禁止端，低电平使能器件。</li><li>13，鉴相器2的输出，它接入环路滤波器的输入端。</li><li>9，VCO的输入，这个输入电压应当尽可能平稳，这样VCO才会有稳定的输出。</li></ul><p>我这次在调试电路过程中动的最多的就是C1和引脚，4。通过调整C1的值来获得不同的频率输出范围；将3、4直接连接来测试锁相环的功能；确定锁相环能正常工作后再把3、4断开，接入分频器。</p><h1 id="频率范围">频率范围</h1><p>CD4046B的输出频率与供电电压有关，供电电压越大，能够输出的频率也越大，但是不能超过15V。根据我的测试，在5V供电，R2不接，R1=10k欧，C1=100pF的情况下，VCO的输出频率最多只有大约700kHZ。想达到1MHz以上的频率必须增大电压到10V，但是这又会产生一问题：锁相环是10V电平输入输出，而分频器是5V电平，两种电平并不互容，必须进行<strong>电平转换</strong>。这是我们组在昨天得到的结论，然后今天我自己花了半个上午的时间才总算是调好了。为了能够覆盖从1kHz~1MHz的频率范围，我切换了三个电容：</p><table><thead><tr><th>100pF</th><th>4.7nF</th><th>3.3nF</th></tr></thead><tbody><tr><td>41k~1.2M</td><td>2k~40k</td><td>1k~29k</td></tr></tbody></table><p>注意这里的频率应当是<strong>倍频后最终输出的频率</strong>。</p><h1 id="电平转换">电平转换</h1><p>这里的电平转换，具体来说：</p><ul><li>锁相环VCO输出的10V方波要被转换为5V方波</li><li>分频器输出的5V方波要被转换为10V方波</li></ul><p>LTspice仿真结果如下：</p><p><img src="https://i.imgur.com/3vQpjKX.png" /></p><p>高电平转低电平用的是左边那个电路，其实就是一个反相器。需要注意的是上拉电阻R1不要取得太大，不然上升沿过于缓慢，适应不了1MHz。而且这个电路实际测试的时候输出在下降沿的振铃非常大，大概是杂散电容和寄生电感的影响（毕竟是焊接到洞洞板上的）。</p><p>低电平转高电平用的是右边的电路，因为左边的电路这时候就不能用了。</p><h1 id="环路滤波器">环路滤波器</h1><p>这是锁相环相当重要的一环。环路滤波器的职责就是将鉴相器输出的高频分量尽可能地滤干净。网上关于环路滤波器的设计方法资料并不是很多，可以参见该博客：<ahref="https://www.cnblogs.com/qm1412/p/18222379">锁相环学习---CD4046</a></p><p>环路滤波器有专用的设计软件，但是非常古老，必须再下载一个XP系统的虚拟机，非常麻烦，所以我就直接使用博客里设计好的电路了：</p><p><img src="https://i.imgur.com/yCQpeqy.jpg" /></p><p>LTspice仿真得到其幅频响应和相频响应如下：</p><p><img src="https://i.imgur.com/LWBPZIo.png" /></p><p>实测这个滤波器可以用于1kHz~1MHz的范围。</p><h1 id="对vco输出进行整形">对VCO输出进行整形</h1><p>这一步其实并不是必要的，但是我还是使用告诉比较器把输出波形整成好看一点的方波，这主要是因为我所用的10V转5V的电平转换电路上升沿非常慢，以至于方波几乎已经变成锯齿波了，非常难受。</p><p><img src="https://i.imgur.com/NrkVsnV.png" /></p><p>注意我最终电路中VIN是经过电容之后才送入比较器，这样隔离直流分量，比较器容易产生正确的结果。另外R1可以稍微取得大一些，比如500欧，对噪声的抑制能力也会强一些。这个比较器的输出为3.3V、0V，可以直接送入单片机的外部时钟输入引脚用来测量频率。</p><h1 id="总结">总结</h1><p>最后实现的效果如图（输入信号与输出信号稳定同频显示不漂移）只拍了N=1的情况，N=64也能非常稳</p><p><img src="https://i.imgur.com/PvEWWA3.jpg" /></p><p>这次与锁相环有关的电路基本都是我负责的，焊接在一大块洞洞板上，焊锡丝的助焊剂快熏死我了。。。不过好在最后的成品表现非常不错，最大能锁定到1.2MHz的频率，已经接近CD4046B的极限了。另外队友也买了一大堆CD4046B，过几天我想用这些多余的芯片测试一下锁相环的FM解调功能。</p>]]></content>
    
    
    <categories>
      
      <category>电子设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日語中的「くの字点」</title>
    <link href="/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/"/>
    <url>/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>最近在青空文庫上閲讀日語圖書的時候發現了這樣一段文字：</p><blockquote><p>表記について<br />このファイルは W3C 勧告 XHTML1.1 にそった形式で作成されています。<br />「くの字点」は「／＼」で表しました。</p></blockquote><p>即：此文件是根据W3C推荐的XHTML1.1格式制作的。'くの字点'用'／＼'表示。</p><p>「くの字点」是什麽？</p><p>我找到了這樣一篇解釋文章：<ahref="https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf">https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf</a></p><p>所謂'くの字点'，就是在重复两个字以上的假名，或漢字与假名時使用的標記符號。如果在重複時漢字的讀音變爲濁音，那麽くの字点也要相應地加上濁音符號。一個くの字点要占用兩個字節的位置。以下圖爲例：</p><p><img src="https://i.imgur.com/7NyGuQV.png" /></p><p>まあまあー＞まあ／＼ 大致，還算過得去<br />しかじかー＞しか／"＼　云云，等等<br />見る見るー＞見る／＼　眼看著，轉眼間<br />離れ離れー＞離れ／＼　失散</p><p>由於日語文章經常按照縱向排列，因此青空文庫就使用“／＼”來代替這個符號了。</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LTspice中SW元件的使用</title>
    <link href="/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LTspice不像Multisim那样有现成的手动开关。开关功能可以用<strong>S.Voltage Controlled Switch</strong>（压控开关）实现。</p><p><img src="https://i.imgur.com/1EAGN5i.png" /></p><ol type="1"><li>按P键打开元件库，搜索"SW"，放置在图纸中</li><li>插入指令定义SW元件的行为，例如：<code>.model MYSW SW(Ron=1 Roff=1Meg Vt=.5 Vh=-.4)</code>，其中<code>Ron</code>是导通电阻（<strong>导通电阻不能为0！</strong>），<code>Roff</code>为断开电阻，Vt和Vh决定了开关的阈值电压，在本例中为0.9V和0.1V</li><li>将开关模型的名称改成MYSW</li><li>放置一个电压源用来控制开关，这里用的是Pulse，开关在闭合1s后保持关断状态。</li></ol><p>SW相关的所有参数如下表格：</p><table><thead><tr><th style="text-align: center;">Name</th><th style="text-align: center;">Description</th><th style="text-align: center;">Units</th><th style="text-align: center;">default</th></tr></thead><tbody><tr><td style="text-align: center;">Vt</td><td style="text-align: center;">阈值电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vh</td><td style="text-align: center;">滞后电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ron</td><td style="text-align: center;">导通电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1.0</td></tr><tr><td style="text-align: center;">Roff</td><td style="text-align: center;">关断电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1/Gmin</td></tr><tr><td style="text-align: center;">Lser</td><td style="text-align: center;">串联电感</td><td style="text-align: center;">H</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vser</td><td style="text-align: center;">串联电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ilimit</td><td style="text-align: center;">限制电流</td><td style="text-align: center;">A</td><td style="text-align: center;">Infin.</td></tr></tbody></table><p><strong>该开关根据滞回电压 Vh的值，具有三种不同的电压控制模式:</strong></p><ul><li>如果 Vh为零，开关将始终完全导通或关断，具体取决于输入电压是否超过阈值电压。</li><li>如果 Vh为正值，开关将表现出滞回现象，就像通过施密特触发器控制一样，触发点为 Vt- Vh 和 Vt + Vh。需要注意的是，Vh是触发点之间电压的一半，这与常见的实验室术语有所不同。</li><li>如果 Vh为负值，开关将在导通和关断阻抗之间平滑过渡。过渡发生在控制电压 Vt - Vh和 Vt + Vh 之间，且平滑过渡遵循开关导通行为的对数的低阶多项式拟合。</li></ul><p>平时设Vh为负值就好。</p><p>参考链接：<br /><ahref="https://www.analog.com/cn/resources/technical-articles/ltspiceiv-voltage-controlled-switches.html#:~:text=To%20insert%20and%20configure%20a%20switch%20in%20LTspice%E2%80%A6,this%20example%3A.model%20MYSW%20SW%20%28Ron%3D1%20Roff%3D1Meg%20Vt%3D.5%20Vh%3D-.4%29">LTspice:Voltage Controlled Switches</a></p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Fluid主题首页的副标题添加淡入效果</title>
    <link href="/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/"/>
    <url>/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近又折腾了一下博客的美化。默认Fluid主题的首页副标题用的是打字机特效，不过我不太喜欢，于是琢磨了一下淡入效果。我并没有学过前端，一下代码主要靠chatgpt和其他网友得到。</p><h1 id="过程">过程</h1><p>使用F12打开开发者模式，定位副标题：<br /><img src="https://i.imgur.com/mgjRfJ2.jpg" alt="Imgur" />目标对应的元素为<code>.h2 #subtitle</code>，在外部CSS文件中加入下列代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Si Yuan&quot;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;../fonts/Si Yuan.otf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;truetype&quot;</span>);<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Si Yuan&#x27;</span>, sans-serif; <span class="hljs-comment">/* 替换为你想要的字体 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>; <span class="hljs-comment">/* 调整字体大小 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>; <span class="hljs-comment">/* 设置字体颜色 */</span><br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始透明度为0，隐藏 */</span><br>    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1.5s</span> linear; <span class="hljs-comment">/* 设置过渡效果 */</span><br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span><span class="hljs-selector-class">.visible</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 完全可见 */</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>由于这里我使用的是思源宋体，并非系统自带的字体，因此额外使用<code>@font-face</code>引入外来字体。</p><p>另外，注意文章页的标题和首页的标题用的是同一个元素，二者会同时发生变更。</p><p>再向外部js文件中加入下列代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> subtitle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;subtitle&#x27;</span>);<br>    subtitle.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;visible&#x27;</span>); <span class="hljs-comment">// 页面加载后添加 visible 类</span><br>&#125;);<br></code></pre></td></tr></table></figure> 完成。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雪酷字幕组的特效注释字幕分析</title>
    <link href="/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>雪酷字幕组在2011至2012年期间与曙光字幕组合作完成了《命运石之门》的翻译工作，这也是我最早看的一个版本，翻译非常贴切自然，并且动漫中出现的流行词汇也都附上了详尽的注释。可惜在2014年之后雪酷字幕组就突然失踪了……这里我想分析一下他们在为《命运石之门》做字幕注释时用到的特效方案，从中窥视那个时代的字幕组对待字幕工作是何等敬业。</p><span id="more"></span><p>以繁体版第10集3:46处的注释为例，ass文件代码如下：</p><pre><code class="hljs">3:46.19~3:51.20     &#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune3:45.90~3:51.41   &#123;\fscx0\pos(15,20)\t(0,200,1,\fscx100)\t(5300,0,1,\fscx0)&#125;————3:46.19~3:51.20   &#123;\move(15,20,15,50,0,200)\pos(15,50)\fad(300, 300)&#125;（架空）ＴＶ動畫『BLOOD TUNE THE ANIMATION』。\N原作是漫畫，隨著多元媒體化的風潮終於在去年動畫化。\N作品被製作成為全２６話的作品，受到了動漫愛好者們的廣泛關注，\N特別是女主角『星來Orujeru』的PVC模型擁有相當高的人氣。</code></pre><p>上面一共用了三段字幕来完成对【BloodTune】的注释。而且，三段字幕分别使用了三种不同大小的字体（在1080p清晰度下）：</p><ol type="1"><li>neta1-微软雅黑，用于注释对象的名称，字号26，边框2，阴影0</li><li>neta2-微软雅黑，用于创造分界线，字号40，边框2，阴影0</li><li>neta3-微软雅黑，用于注释的具体内容，字号28，边框2，阴影0</li></ol><p>实现的效果如图 <imgsrc="https://media.giphy.com/media/EuIDh9scyssnZXBT39/giphy.gif" /></p><p>下面对这三段代码进行逐行分析。</p><h1 id="平滑的文本展示效果">平滑的文本展示效果</h1><p><code>\move</code>用于设置文本的<strong>移动轨迹</strong>，其基本语法是<code>\move(x1,y1,x2,y2,start_time,end_time)</code>，其中<code>(x1,y1)</code>是起始位置，<code>(x2,y2)</code>是结束位置，<code>start_time</code>和<code>end_time</code>定义动画的开始和结束时间（单位：毫秒）。</p><p><code>\pos</code>用于设置文本的<strong>绝对位置</strong>，其语法是(x,y)，其中 x 和 y是屏幕坐标。这个命令将文本固定在指定的位置，不随时间变化。</p><p><code>\fad</code>用于设置文本的<strong>淡入淡出</strong>效果，其基本语法是<code>\fad(fade_in_time, fade_out_time)</code>，其中<code>fade_in_time</code>是淡入持续的时间（毫秒），<code>fade_out_time</code>是淡出持续的时间（毫秒）。</p><p><code>&#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune</code>是一串复合代码，综合以上三点，其作用为：- 文本从屏幕坐标<code>(15, 20)</code>移动到<code>(15, 10)</code>，在 0毫秒时开始，200 毫秒时结束。 -文本运动到<code>(15,10)</code>后会被固定到这个位置。 -在文本开始移动的同时，会附加一个300毫秒的淡入效果，在文本消失时则有300毫秒的淡出效果。</p><h1 id="动态的分界线">动态的分界线</h1><p><code>\fscx</code>用于设置文本的<strong>水平缩放</strong>(<strong>f</strong>ront<strong>sc</strong>ale<strong>x</strong>)，其基本语法是<code>\fscx&lt;value&gt;</code>，其中<code>&lt;value&gt;</code>是缩放的百分比值。例如：</p><ul><li><code>\fscx100</code>表示正常大小</li><li><code>\fscx50</code>表示正常大小的一半</li></ul><p><code>\t</code>用于创建<strong>动画效果</strong>（transformation），从一个样式动画渐变到另外一个。Aegisub手册给出的语法如下：</p><pre><code class="hljs">\t(&lt;style modifiers&gt;)\t(&lt;accel&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;accel&gt;,&lt;style modifiers&gt;)</code></pre><p>本例使用的是第四个。其中<code>&lt;style modifiers&gt;</code>参数是特效标签，<code>accel</code>参数可以让动画效果不再是匀速的，而是满足一条指数曲线。该参数为1时，运动速度是恒定的。参数在0和1之间时，运动速度逐渐变慢。参数大于1时，运动速度越来越快。</p><p>整个代码的运行逻辑可以用下图概括：<br /><img src="https://i.imgur.com/r6Rsdn7.png" /></p>]]></content>
    
    
    <categories>
      
      <category>字幕</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid主题渲染LaTeX数学公式的问题总结</title>
    <link href="/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Fluid的<ahref="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">官方指南文档</a>中已经做了详尽的说明，一步一步跟着做就没问题。值得注意的是，在主题配置的代码</p><pre><code class="hljs">post:math:enable: truespecific: falseengine: mathjax</code></pre><p>中，要想使用数学公式，<code>enable</code>一项必须是<code>true</code>才行，否则会出现渲染错误，比如像下面这样：</p><p><imgsrc="https://github.com/banyee19/blog_images/blob/main/%E4%B8%8D%E5%90%AF%E7%94%A8.jpg?raw=true" /></p><p>同样的公式渲染了一次之后又重复了一次。</p><p>另外，Hexo中无法使用换行符<code>\\</code>，原因是<code>\</code>在Markdown属于特殊字符，用于字符转义，所以两个<code>\</code>经过Markdown引擎处理为html后，只剩下一个，等到LaTex渲染引擎处理时，实际上只看到一个<code>\</code>，渲染引擎把它当作LaTeX 中的空格。</p><p>在不改动现有代码的情况下，我的解决方法是直接改变公式的写法。比如下边这个公式</p><pre><code class="hljs">$$a_11=b_11 \\a_22=b_22+c_22$$</code></pre><p>改为</p><pre><code class="hljs">$$\begin&#123;aligned&#125;a_&#123;11&#125;&amp; =b_&#123;11&#125;\\a_&#123;22&#125;&amp; =b_&#123;22&#125;+c_&#123;22&#125;\end&#123;aligned&#125;$$</code></pre><p>渲染效果如下： <span class="math display">\[\begin{aligned}a_{11}&amp; =b_{11}\\a_{22}&amp; =b_{22}+c_{22}\end{aligned}\]</span> 更复杂的公式同理： <span class="math display">\[\begin{aligned}    F_x&#39;&amp;=\gamma\{q[\frac{-i\gamma}{c}(u_t&#39;+i\betau_x&#39;)E_x+u_y&#39;B_z-u_z&#39;B_y]    +i\beta\frac{iq}{c}[\gamma(u_x&#39;-i\betau_t&#39;)E_x+u_y&#39;E_y+u_z&#39;E_z] \}\\    &amp;=\frac{-iq\gamma^2}{c}(1-\beta^2)E_xu_t&#39;-q\gamma(B_y+\frac{\beta}{c}E_z)u_z&#39;+q\gamma(B_z-\frac{\beta}{c}E_y)u_y&#39;\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序章-新博客的诞生</title>
    <link href="/2024/09/13/hello-world/"/>
    <url>/2024/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>新博客建成祝贺！ <span id="more"></span>经过两天的配置，，终于成功用Github把博客搭建出来了！</p><p>其实之前我一直是在博客园上面写博客的（虽然也才刚写了几个月），但是最近博客园的运营情况令人堪忧，可能再过几个月就要被收购了，嘛这样的话到时候博客园大概率要植入广告了，所以索性自己创建一个博客好了。另一方面，我写博客的目的是把自己的想法记录下来，或者分享自己的知识，所以博客园那种类似于论坛式的模式其实并不是很适合我。只要把博文发出来，我就达到目的了，就算没有人看也没关系。</p><p>不出意外的话这个博客应该会长期更新下去。毕竟是自己费了好大的功夫才建出来的嘛（笑）我在生活中并不喜欢和别人交流，周围能和我一起交流喜欢的事物的人几乎没有，但是我还是希望把自己思考的东西分享出来。那干脆就借助博客好了。以后这个博客上会发布各种我感兴趣的内容。</p><p>总之，我宣布，Banyee's Blog从今天开始正式成立了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>初次见面</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
